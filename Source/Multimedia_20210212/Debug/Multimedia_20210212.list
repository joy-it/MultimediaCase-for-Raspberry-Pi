
Multimedia_25062020.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .isr_vector   000000c0  08000000  08000000  00010000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         000037d8  080000c0  080000c0  000100c0  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .rodata       0000022c  08003898  08003898  00013898  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .ARM.extab    00000000  08003ac4  08003ac4  00020030  2**0
                  CONTENTS
  4 .ARM          00000000  08003ac4  08003ac4  00020030  2**0
                  CONTENTS
  5 .preinit_array 00000000  08003ac4  08003ac4  00020030  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  6 .init_array   00000004  08003ac4  08003ac4  00013ac4  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  7 .fini_array   00000004  08003ac8  08003ac8  00013ac8  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  8 .data         00000030  20000000  08003acc  00020000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  9 .bss          00000458  20000030  08003afc  00020030  2**3
                  ALLOC
 10 ._user_heap_stack 00000600  20000488  08003afc  00020488  2**0
                  ALLOC
 11 .ARM.attributes 00000028  00000000  00000000  00020030  2**0
                  CONTENTS, READONLY
 12 .debug_info   0001463a  00000000  00000000  00020058  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_abbrev 00003055  00000000  00000000  00034692  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_loc    0000abd3  00000000  00000000  000376e7  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_aranges 00000d68  00000000  00000000  000422c0  2**3
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_ranges 00001468  00000000  00000000  00043028  2**3
                  CONTENTS, READONLY, DEBUGGING
 17 .debug_macro  000103de  00000000  00000000  00044490  2**0
                  CONTENTS, READONLY, DEBUGGING
 18 .debug_line   0000db01  00000000  00000000  0005486e  2**0
                  CONTENTS, READONLY, DEBUGGING
 19 .debug_str    00061b8c  00000000  00000000  0006236f  2**0
                  CONTENTS, READONLY, DEBUGGING
 20 .comment      0000007b  00000000  00000000  000c3efb  2**0
                  CONTENTS, READONLY
 21 .debug_frame  00002ab8  00000000  00000000  000c3f78  2**2
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

080000c0 <__do_global_dtors_aux>:
 80000c0:	b510      	push	{r4, lr}
 80000c2:	4c06      	ldr	r4, [pc, #24]	; (80000dc <__do_global_dtors_aux+0x1c>)
 80000c4:	7823      	ldrb	r3, [r4, #0]
 80000c6:	2b00      	cmp	r3, #0
 80000c8:	d107      	bne.n	80000da <__do_global_dtors_aux+0x1a>
 80000ca:	4b05      	ldr	r3, [pc, #20]	; (80000e0 <__do_global_dtors_aux+0x20>)
 80000cc:	2b00      	cmp	r3, #0
 80000ce:	d002      	beq.n	80000d6 <__do_global_dtors_aux+0x16>
 80000d0:	4804      	ldr	r0, [pc, #16]	; (80000e4 <__do_global_dtors_aux+0x24>)
 80000d2:	e000      	b.n	80000d6 <__do_global_dtors_aux+0x16>
 80000d4:	bf00      	nop
 80000d6:	2301      	movs	r3, #1
 80000d8:	7023      	strb	r3, [r4, #0]
 80000da:	bd10      	pop	{r4, pc}
 80000dc:	20000030 	.word	0x20000030
 80000e0:	00000000 	.word	0x00000000
 80000e4:	08003880 	.word	0x08003880

080000e8 <frame_dummy>:
 80000e8:	4b04      	ldr	r3, [pc, #16]	; (80000fc <frame_dummy+0x14>)
 80000ea:	b510      	push	{r4, lr}
 80000ec:	2b00      	cmp	r3, #0
 80000ee:	d003      	beq.n	80000f8 <frame_dummy+0x10>
 80000f0:	4903      	ldr	r1, [pc, #12]	; (8000100 <frame_dummy+0x18>)
 80000f2:	4804      	ldr	r0, [pc, #16]	; (8000104 <frame_dummy+0x1c>)
 80000f4:	e000      	b.n	80000f8 <frame_dummy+0x10>
 80000f6:	bf00      	nop
 80000f8:	bd10      	pop	{r4, pc}
 80000fa:	46c0      	nop			; (mov r8, r8)
 80000fc:	00000000 	.word	0x00000000
 8000100:	20000034 	.word	0x20000034
 8000104:	08003880 	.word	0x08003880

08000108 <strcmp>:
 8000108:	7802      	ldrb	r2, [r0, #0]
 800010a:	780b      	ldrb	r3, [r1, #0]
 800010c:	2a00      	cmp	r2, #0
 800010e:	d003      	beq.n	8000118 <strcmp+0x10>
 8000110:	3001      	adds	r0, #1
 8000112:	3101      	adds	r1, #1
 8000114:	429a      	cmp	r2, r3
 8000116:	d0f7      	beq.n	8000108 <strcmp>
 8000118:	1ad0      	subs	r0, r2, r3
 800011a:	4770      	bx	lr

0800011c <__gnu_thumb1_case_uqi>:
 800011c:	b402      	push	{r1}
 800011e:	4671      	mov	r1, lr
 8000120:	0849      	lsrs	r1, r1, #1
 8000122:	0049      	lsls	r1, r1, #1
 8000124:	5c09      	ldrb	r1, [r1, r0]
 8000126:	0049      	lsls	r1, r1, #1
 8000128:	448e      	add	lr, r1
 800012a:	bc02      	pop	{r1}
 800012c:	4770      	bx	lr
 800012e:	46c0      	nop			; (mov r8, r8)

08000130 <__udivsi3>:
 8000130:	2200      	movs	r2, #0
 8000132:	0843      	lsrs	r3, r0, #1
 8000134:	428b      	cmp	r3, r1
 8000136:	d374      	bcc.n	8000222 <__udivsi3+0xf2>
 8000138:	0903      	lsrs	r3, r0, #4
 800013a:	428b      	cmp	r3, r1
 800013c:	d35f      	bcc.n	80001fe <__udivsi3+0xce>
 800013e:	0a03      	lsrs	r3, r0, #8
 8000140:	428b      	cmp	r3, r1
 8000142:	d344      	bcc.n	80001ce <__udivsi3+0x9e>
 8000144:	0b03      	lsrs	r3, r0, #12
 8000146:	428b      	cmp	r3, r1
 8000148:	d328      	bcc.n	800019c <__udivsi3+0x6c>
 800014a:	0c03      	lsrs	r3, r0, #16
 800014c:	428b      	cmp	r3, r1
 800014e:	d30d      	bcc.n	800016c <__udivsi3+0x3c>
 8000150:	22ff      	movs	r2, #255	; 0xff
 8000152:	0209      	lsls	r1, r1, #8
 8000154:	ba12      	rev	r2, r2
 8000156:	0c03      	lsrs	r3, r0, #16
 8000158:	428b      	cmp	r3, r1
 800015a:	d302      	bcc.n	8000162 <__udivsi3+0x32>
 800015c:	1212      	asrs	r2, r2, #8
 800015e:	0209      	lsls	r1, r1, #8
 8000160:	d065      	beq.n	800022e <__udivsi3+0xfe>
 8000162:	0b03      	lsrs	r3, r0, #12
 8000164:	428b      	cmp	r3, r1
 8000166:	d319      	bcc.n	800019c <__udivsi3+0x6c>
 8000168:	e000      	b.n	800016c <__udivsi3+0x3c>
 800016a:	0a09      	lsrs	r1, r1, #8
 800016c:	0bc3      	lsrs	r3, r0, #15
 800016e:	428b      	cmp	r3, r1
 8000170:	d301      	bcc.n	8000176 <__udivsi3+0x46>
 8000172:	03cb      	lsls	r3, r1, #15
 8000174:	1ac0      	subs	r0, r0, r3
 8000176:	4152      	adcs	r2, r2
 8000178:	0b83      	lsrs	r3, r0, #14
 800017a:	428b      	cmp	r3, r1
 800017c:	d301      	bcc.n	8000182 <__udivsi3+0x52>
 800017e:	038b      	lsls	r3, r1, #14
 8000180:	1ac0      	subs	r0, r0, r3
 8000182:	4152      	adcs	r2, r2
 8000184:	0b43      	lsrs	r3, r0, #13
 8000186:	428b      	cmp	r3, r1
 8000188:	d301      	bcc.n	800018e <__udivsi3+0x5e>
 800018a:	034b      	lsls	r3, r1, #13
 800018c:	1ac0      	subs	r0, r0, r3
 800018e:	4152      	adcs	r2, r2
 8000190:	0b03      	lsrs	r3, r0, #12
 8000192:	428b      	cmp	r3, r1
 8000194:	d301      	bcc.n	800019a <__udivsi3+0x6a>
 8000196:	030b      	lsls	r3, r1, #12
 8000198:	1ac0      	subs	r0, r0, r3
 800019a:	4152      	adcs	r2, r2
 800019c:	0ac3      	lsrs	r3, r0, #11
 800019e:	428b      	cmp	r3, r1
 80001a0:	d301      	bcc.n	80001a6 <__udivsi3+0x76>
 80001a2:	02cb      	lsls	r3, r1, #11
 80001a4:	1ac0      	subs	r0, r0, r3
 80001a6:	4152      	adcs	r2, r2
 80001a8:	0a83      	lsrs	r3, r0, #10
 80001aa:	428b      	cmp	r3, r1
 80001ac:	d301      	bcc.n	80001b2 <__udivsi3+0x82>
 80001ae:	028b      	lsls	r3, r1, #10
 80001b0:	1ac0      	subs	r0, r0, r3
 80001b2:	4152      	adcs	r2, r2
 80001b4:	0a43      	lsrs	r3, r0, #9
 80001b6:	428b      	cmp	r3, r1
 80001b8:	d301      	bcc.n	80001be <__udivsi3+0x8e>
 80001ba:	024b      	lsls	r3, r1, #9
 80001bc:	1ac0      	subs	r0, r0, r3
 80001be:	4152      	adcs	r2, r2
 80001c0:	0a03      	lsrs	r3, r0, #8
 80001c2:	428b      	cmp	r3, r1
 80001c4:	d301      	bcc.n	80001ca <__udivsi3+0x9a>
 80001c6:	020b      	lsls	r3, r1, #8
 80001c8:	1ac0      	subs	r0, r0, r3
 80001ca:	4152      	adcs	r2, r2
 80001cc:	d2cd      	bcs.n	800016a <__udivsi3+0x3a>
 80001ce:	09c3      	lsrs	r3, r0, #7
 80001d0:	428b      	cmp	r3, r1
 80001d2:	d301      	bcc.n	80001d8 <__udivsi3+0xa8>
 80001d4:	01cb      	lsls	r3, r1, #7
 80001d6:	1ac0      	subs	r0, r0, r3
 80001d8:	4152      	adcs	r2, r2
 80001da:	0983      	lsrs	r3, r0, #6
 80001dc:	428b      	cmp	r3, r1
 80001de:	d301      	bcc.n	80001e4 <__udivsi3+0xb4>
 80001e0:	018b      	lsls	r3, r1, #6
 80001e2:	1ac0      	subs	r0, r0, r3
 80001e4:	4152      	adcs	r2, r2
 80001e6:	0943      	lsrs	r3, r0, #5
 80001e8:	428b      	cmp	r3, r1
 80001ea:	d301      	bcc.n	80001f0 <__udivsi3+0xc0>
 80001ec:	014b      	lsls	r3, r1, #5
 80001ee:	1ac0      	subs	r0, r0, r3
 80001f0:	4152      	adcs	r2, r2
 80001f2:	0903      	lsrs	r3, r0, #4
 80001f4:	428b      	cmp	r3, r1
 80001f6:	d301      	bcc.n	80001fc <__udivsi3+0xcc>
 80001f8:	010b      	lsls	r3, r1, #4
 80001fa:	1ac0      	subs	r0, r0, r3
 80001fc:	4152      	adcs	r2, r2
 80001fe:	08c3      	lsrs	r3, r0, #3
 8000200:	428b      	cmp	r3, r1
 8000202:	d301      	bcc.n	8000208 <__udivsi3+0xd8>
 8000204:	00cb      	lsls	r3, r1, #3
 8000206:	1ac0      	subs	r0, r0, r3
 8000208:	4152      	adcs	r2, r2
 800020a:	0883      	lsrs	r3, r0, #2
 800020c:	428b      	cmp	r3, r1
 800020e:	d301      	bcc.n	8000214 <__udivsi3+0xe4>
 8000210:	008b      	lsls	r3, r1, #2
 8000212:	1ac0      	subs	r0, r0, r3
 8000214:	4152      	adcs	r2, r2
 8000216:	0843      	lsrs	r3, r0, #1
 8000218:	428b      	cmp	r3, r1
 800021a:	d301      	bcc.n	8000220 <__udivsi3+0xf0>
 800021c:	004b      	lsls	r3, r1, #1
 800021e:	1ac0      	subs	r0, r0, r3
 8000220:	4152      	adcs	r2, r2
 8000222:	1a41      	subs	r1, r0, r1
 8000224:	d200      	bcs.n	8000228 <__udivsi3+0xf8>
 8000226:	4601      	mov	r1, r0
 8000228:	4152      	adcs	r2, r2
 800022a:	4610      	mov	r0, r2
 800022c:	4770      	bx	lr
 800022e:	e7ff      	b.n	8000230 <__udivsi3+0x100>
 8000230:	b501      	push	{r0, lr}
 8000232:	2000      	movs	r0, #0
 8000234:	f000 f806 	bl	8000244 <__aeabi_idiv0>
 8000238:	bd02      	pop	{r1, pc}
 800023a:	46c0      	nop			; (mov r8, r8)

0800023c <__aeabi_uidivmod>:
 800023c:	2900      	cmp	r1, #0
 800023e:	d0f7      	beq.n	8000230 <__udivsi3+0x100>
 8000240:	e776      	b.n	8000130 <__udivsi3>
 8000242:	4770      	bx	lr

08000244 <__aeabi_idiv0>:
 8000244:	4770      	bx	lr
 8000246:	46c0      	nop			; (mov r8, r8)

08000248 <__aeabi_llsr>:
 8000248:	40d0      	lsrs	r0, r2
 800024a:	1c0b      	adds	r3, r1, #0
 800024c:	40d1      	lsrs	r1, r2
 800024e:	469c      	mov	ip, r3
 8000250:	3a20      	subs	r2, #32
 8000252:	40d3      	lsrs	r3, r2
 8000254:	4318      	orrs	r0, r3
 8000256:	4252      	negs	r2, r2
 8000258:	4663      	mov	r3, ip
 800025a:	4093      	lsls	r3, r2
 800025c:	4318      	orrs	r0, r3
 800025e:	4770      	bx	lr

08000260 <irmp_store_bit>:
// verhindert, dass irmp_store_bit() inline compiliert wird:
// static void irmp_store_bit (uint_fast8_t) __attribute__ ((noinline));

static void
irmp_store_bit (uint_fast8_t value)
{
 8000260:	b5f0      	push	{r4, r5, r6, r7, lr}
        first_bit = value;
    }
    else
#endif

    if (irmp_bit >= irmp_param.address_offset && irmp_bit < irmp_param.address_end)
 8000262:	4a29      	ldr	r2, [pc, #164]	; (8000308 <irmp_store_bit+0xa8>)
 8000264:	4c29      	ldr	r4, [pc, #164]	; (800030c <irmp_store_bit+0xac>)
 8000266:	6a55      	ldr	r5, [r2, #36]	; 0x24
 8000268:	6823      	ldr	r3, [r4, #0]
 800026a:	429d      	cmp	r5, r3
 800026c:	d803      	bhi.n	8000276 <irmp_store_bit+0x16>
 800026e:	6a91      	ldr	r1, [r2, #40]	; 0x28
 8000270:	4e27      	ldr	r6, [pc, #156]	; (8000310 <irmp_store_bit+0xb0>)
 8000272:	428b      	cmp	r3, r1
 8000274:	d306      	bcc.n	8000284 <irmp_store_bit+0x24>
        {
            irmp_tmp_address <<= 1;
            irmp_tmp_address |= value;
        }
    }
    else if (irmp_bit >= irmp_param.command_offset && irmp_bit < irmp_param.command_end)
 8000276:	6ad5      	ldr	r5, [r2, #44]	; 0x2c
 8000278:	42ab      	cmp	r3, r5
 800027a:	d30c      	bcc.n	8000296 <irmp_store_bit+0x36>
 800027c:	6b11      	ldr	r1, [r2, #48]	; 0x30
 800027e:	428b      	cmp	r3, r1
 8000280:	d209      	bcs.n	8000296 <irmp_store_bit+0x36>
 8000282:	4e24      	ldr	r6, [pc, #144]	; (8000314 <irmp_store_bit+0xb4>)
    {
        if (irmp_param.lsb_first)
 8000284:	6bd7      	ldr	r7, [r2, #60]	; 0x3c
 8000286:	6831      	ldr	r1, [r6, #0]
 8000288:	2f00      	cmp	r7, #0
 800028a:	d013      	beq.n	80002b4 <irmp_store_bit+0x54>
                irmp_tmp_id |= (((uint_fast16_t) (value)) << (irmp_bit - 32));   // CV wants cast
            }
            else
#endif
            {
                irmp_tmp_command |= (((uint_fast16_t) (value)) << (irmp_bit - irmp_param.command_offset));   // CV wants cast
 800028c:	0007      	movs	r7, r0
 800028e:	1b5d      	subs	r5, r3, r5
 8000290:	40af      	lsls	r7, r5
 8000292:	4339      	orrs	r1, r7
            }
        }
        else
        {
            irmp_tmp_command <<= 1;
            irmp_tmp_command |= value;
 8000294:	6031      	str	r1, [r6, #0]
    }
    else
#endif

#if IRMP_SUPPORT_SAMSUNG_PROTOCOL == 1
    if (irmp_param.protocol == IRMP_SAMSUNG_PROTOCOL && irmp_bit >= SAMSUNG_ID_OFFSET && irmp_bit < SAMSUNG_ID_OFFSET + SAMSUNG_ID_LEN)
 8000296:	6812      	ldr	r2, [r2, #0]
 8000298:	2a03      	cmp	r2, #3
 800029a:	d10e      	bne.n	80002ba <irmp_store_bit+0x5a>
 800029c:	0019      	movs	r1, r3
 800029e:	3911      	subs	r1, #17
 80002a0:	2903      	cmp	r1, #3
 80002a2:	d804      	bhi.n	80002ae <irmp_store_bit+0x4e>
    {
        irmp_tmp_id |= (((uint_fast16_t) (value)) << (irmp_bit - SAMSUNG_ID_OFFSET));                    // store with LSB first
 80002a4:	4088      	lsls	r0, r1
 80002a6:	4a1c      	ldr	r2, [pc, #112]	; (8000318 <irmp_store_bit+0xb8>)
 80002a8:	6811      	ldr	r1, [r2, #0]
 80002aa:	4308      	orrs	r0, r1
 80002ac:	6010      	str	r0, [r2, #0]
#endif // IRMP_SUPPORT_MITSU_HEAVY_PROTOCOL
    {
        ;
    }

    irmp_bit++;
 80002ae:	3301      	adds	r3, #1
 80002b0:	6023      	str	r3, [r4, #0]
}
 80002b2:	bdf0      	pop	{r4, r5, r6, r7, pc}
            irmp_tmp_command <<= 1;
 80002b4:	0049      	lsls	r1, r1, #1
            irmp_tmp_command |= value;
 80002b6:	4301      	orrs	r1, r0
 80002b8:	e7ec      	b.n	8000294 <irmp_store_bit+0x34>
    if (irmp_param.protocol == IRMP_KASEIKYO_PROTOCOL)
 80002ba:	2a05      	cmp	r2, #5
 80002bc:	d1f7      	bne.n	80002ae <irmp_store_bit+0x4e>
        if (irmp_bit >= 20 && irmp_bit < 24)
 80002be:	001a      	movs	r2, r3
 80002c0:	3a14      	subs	r2, #20
 80002c2:	2a03      	cmp	r2, #3
 80002c4:	d814      	bhi.n	80002f0 <irmp_store_bit+0x90>
            irmp_tmp_command |= (((uint_fast16_t) (value)) << (irmp_bit - 8));      // store 4 system bits (genre 1) in upper nibble with LSB first
 80002c6:	4913      	ldr	r1, [pc, #76]	; (8000314 <irmp_store_bit+0xb4>)
 80002c8:	320c      	adds	r2, #12
            genre2 |= (((uint_fast8_t) (value)) << (irmp_bit - 20));                // store 4 system bits (genre 2) in upper nibble with LSB first
 80002ca:	0005      	movs	r5, r0
 80002cc:	4095      	lsls	r5, r2
 80002ce:	002a      	movs	r2, r5
 80002d0:	680d      	ldr	r5, [r1, #0]
 80002d2:	432a      	orrs	r2, r5
 80002d4:	600a      	str	r2, [r1, #0]
 80002d6:	2207      	movs	r2, #7
 80002d8:	2101      	movs	r1, #1
 80002da:	401a      	ands	r2, r3
 80002dc:	4091      	lsls	r1, r2
 80002de:	4e0f      	ldr	r6, [pc, #60]	; (800031c <irmp_store_bit+0xbc>)
 80002e0:	08dd      	lsrs	r5, r3, #3
 80002e2:	5777      	ldrsb	r7, [r6, r5]
 80002e4:	b24a      	sxtb	r2, r1
            if (value)
 80002e6:	2800      	cmp	r0, #0
 80002e8:	d00b      	beq.n	8000302 <irmp_store_bit+0xa2>
                xor_check[irmp_bit / 8] |= 1 << (irmp_bit % 8);
 80002ea:	433a      	orrs	r2, r7
 80002ec:	5572      	strb	r2, [r6, r5]
 80002ee:	e7de      	b.n	80002ae <irmp_store_bit+0x4e>
        else if (irmp_bit >= 24 && irmp_bit < 28)
 80002f0:	0019      	movs	r1, r3
 80002f2:	3918      	subs	r1, #24
 80002f4:	2903      	cmp	r1, #3
 80002f6:	d801      	bhi.n	80002fc <irmp_store_bit+0x9c>
            genre2 |= (((uint_fast8_t) (value)) << (irmp_bit - 20));                // store 4 system bits (genre 2) in upper nibble with LSB first
 80002f8:	4909      	ldr	r1, [pc, #36]	; (8000320 <irmp_store_bit+0xc0>)
 80002fa:	e7e6      	b.n	80002ca <irmp_store_bit+0x6a>
        if (irmp_bit < KASEIKYO_COMPLETE_DATA_LEN)
 80002fc:	2b2f      	cmp	r3, #47	; 0x2f
 80002fe:	d8d6      	bhi.n	80002ae <irmp_store_bit+0x4e>
 8000300:	e7e9      	b.n	80002d6 <irmp_store_bit+0x76>
                xor_check[irmp_bit / 8] &= ~(1 << (irmp_bit % 8));
 8000302:	4397      	bics	r7, r2
 8000304:	5577      	strb	r7, [r6, r5]
 8000306:	e7d2      	b.n	80002ae <irmp_store_bit+0x4e>
 8000308:	20000068 	.word	0x20000068
 800030c:	20000054 	.word	0x20000054
 8000310:	200000bc 	.word	0x200000bc
 8000314:	200000c0 	.word	0x200000c0
 8000318:	200000c4 	.word	0x200000c4
 800031c:	200000e4 	.word	0x200000e4
 8000320:	2000004c 	.word	0x2000004c

08000324 <irmp_init>:
}
 8000324:	4770      	bx	lr
	...

08000328 <irmp_get_data>:
{
 8000328:	0002      	movs	r2, r0
    uint_fast8_t   rtc = FALSE;
 800032a:	2000      	movs	r0, #0
    if (irmp_ir_detected)
 800032c:	4b34      	ldr	r3, [pc, #208]	; (8000400 <irmp_get_data+0xd8>)
{
 800032e:	b5f0      	push	{r4, r5, r6, r7, lr}
    if (irmp_ir_detected)
 8000330:	469c      	mov	ip, r3
 8000332:	681b      	ldr	r3, [r3, #0]
 8000334:	4283      	cmp	r3, r0
 8000336:	d020      	beq.n	800037a <irmp_get_data+0x52>
        switch (irmp_protocol)
 8000338:	4932      	ldr	r1, [pc, #200]	; (8000404 <irmp_get_data+0xdc>)
 800033a:	4b33      	ldr	r3, [pc, #204]	; (8000408 <irmp_get_data+0xe0>)
 800033c:	680d      	ldr	r5, [r1, #0]
 800033e:	4833      	ldr	r0, [pc, #204]	; (800040c <irmp_get_data+0xe4>)
 8000340:	2d03      	cmp	r5, #3
 8000342:	d029      	beq.n	8000398 <irmp_get_data+0x70>
 8000344:	d81a      	bhi.n	800037c <irmp_get_data+0x54>
 8000346:	2d02      	cmp	r5, #2
 8000348:	d038      	beq.n	80003bc <irmp_get_data+0x94>
            irmp_data_p->protocol = irmp_protocol;
 800034a:	6809      	ldr	r1, [r1, #0]
 800034c:	7011      	strb	r1, [r2, #0]
            irmp_data_p->address  = irmp_address;
 800034e:	6801      	ldr	r1, [r0, #0]
 8000350:	2001      	movs	r0, #1
 8000352:	b289      	uxth	r1, r1
 8000354:	7051      	strb	r1, [r2, #1]
 8000356:	0a09      	lsrs	r1, r1, #8
 8000358:	7091      	strb	r1, [r2, #2]
            irmp_data_p->command  = irmp_command;
 800035a:	6819      	ldr	r1, [r3, #0]
 800035c:	b289      	uxth	r1, r1
 800035e:	70d1      	strb	r1, [r2, #3]
 8000360:	0a09      	lsrs	r1, r1, #8
 8000362:	7111      	strb	r1, [r2, #4]
            irmp_data_p->flags    = irmp_flags;
 8000364:	492a      	ldr	r1, [pc, #168]	; (8000410 <irmp_get_data+0xe8>)
 8000366:	6809      	ldr	r1, [r1, #0]
 8000368:	7151      	strb	r1, [r2, #5]
        irmp_command  = 0;                                      // don't reset irmp_protocol here, needed for detection of NEC & JVC repetition frames!
 800036a:	2200      	movs	r2, #0
 800036c:	601a      	str	r2, [r3, #0]
        irmp_address  = 0;
 800036e:	4b27      	ldr	r3, [pc, #156]	; (800040c <irmp_get_data+0xe4>)
 8000370:	601a      	str	r2, [r3, #0]
        irmp_flags    = 0;
 8000372:	4b27      	ldr	r3, [pc, #156]	; (8000410 <irmp_get_data+0xe8>)
 8000374:	601a      	str	r2, [r3, #0]
        irmp_ir_detected = FALSE;
 8000376:	4663      	mov	r3, ip
 8000378:	601a      	str	r2, [r3, #0]
}
 800037a:	bdf0      	pop	{r4, r5, r6, r7, pc}
        switch (irmp_protocol)
 800037c:	2d07      	cmp	r5, #7
 800037e:	d037      	beq.n	80003f0 <irmp_get_data+0xc8>
 8000380:	2d32      	cmp	r5, #50	; 0x32
 8000382:	d1e2      	bne.n	800034a <irmp_get_data+0x22>
                if ((irmp_command >> 8) == (irmp_command & 0x00FF))
 8000384:	27ff      	movs	r7, #255	; 0xff
 8000386:	681d      	ldr	r5, [r3, #0]
 8000388:	681e      	ldr	r6, [r3, #0]
 800038a:	0a2d      	lsrs	r5, r5, #8
 800038c:	403e      	ands	r6, r7
 800038e:	42b5      	cmp	r5, r6
 8000390:	d133      	bne.n	80003fa <irmp_get_data+0xd2>
                    irmp_command &= 0xff;
 8000392:	681d      	ldr	r5, [r3, #0]
 8000394:	403d      	ands	r5, r7
 8000396:	e00f      	b.n	80003b8 <irmp_get_data+0x90>
                if ((irmp_command >> 8) == (~irmp_command & 0x00FF))
 8000398:	27ff      	movs	r7, #255	; 0xff
 800039a:	003c      	movs	r4, r7
 800039c:	681e      	ldr	r6, [r3, #0]
 800039e:	681d      	ldr	r5, [r3, #0]
 80003a0:	0a36      	lsrs	r6, r6, #8
 80003a2:	43ac      	bics	r4, r5
 80003a4:	42a6      	cmp	r6, r4
 80003a6:	d128      	bne.n	80003fa <irmp_get_data+0xd2>
                    irmp_command &= 0xff;
 80003a8:	681d      	ldr	r5, [r3, #0]
 80003aa:	403d      	ands	r5, r7
 80003ac:	601d      	str	r5, [r3, #0]
                    irmp_command |= irmp_id << 8;
 80003ae:	4d19      	ldr	r5, [pc, #100]	; (8000414 <irmp_get_data+0xec>)
 80003b0:	682d      	ldr	r5, [r5, #0]
 80003b2:	681e      	ldr	r6, [r3, #0]
 80003b4:	022d      	lsls	r5, r5, #8
 80003b6:	4335      	orrs	r5, r6
                    irmp_command &= 0xff;
 80003b8:	601d      	str	r5, [r3, #0]
 80003ba:	e7c6      	b.n	800034a <irmp_get_data+0x22>
                if ((irmp_command >> 8) == (~irmp_command & 0x00FF))
 80003bc:	26ff      	movs	r6, #255	; 0xff
 80003be:	0034      	movs	r4, r6
 80003c0:	681d      	ldr	r5, [r3, #0]
 80003c2:	681f      	ldr	r7, [r3, #0]
 80003c4:	0a2d      	lsrs	r5, r5, #8
 80003c6:	43bc      	bics	r4, r7
 80003c8:	42a5      	cmp	r5, r4
 80003ca:	d103      	bne.n	80003d4 <irmp_get_data+0xac>
                    irmp_command &= 0x00FF;
 80003cc:	681d      	ldr	r5, [r3, #0]
 80003ce:	402e      	ands	r6, r5
 80003d0:	601e      	str	r6, [r3, #0]
 80003d2:	e7ba      	b.n	800034a <irmp_get_data+0x22>
                else if (irmp_address == 0x87EE)
 80003d4:	6807      	ldr	r7, [r0, #0]
 80003d6:	4d10      	ldr	r5, [pc, #64]	; (8000418 <irmp_get_data+0xf0>)
 80003d8:	42af      	cmp	r7, r5
 80003da:	d106      	bne.n	80003ea <irmp_get_data+0xc2>
                    irmp_protocol = IRMP_APPLE_PROTOCOL;
 80003dc:	250b      	movs	r5, #11
 80003de:	600d      	str	r5, [r1, #0]
                    irmp_address = (irmp_command & 0xFF00) >> 8;
 80003e0:	681d      	ldr	r5, [r3, #0]
 80003e2:	0a2d      	lsrs	r5, r5, #8
 80003e4:	4035      	ands	r5, r6
 80003e6:	6005      	str	r5, [r0, #0]
 80003e8:	e7f0      	b.n	80003cc <irmp_get_data+0xa4>
                    irmp_protocol = IRMP_ONKYO_PROTOCOL;
 80003ea:	2538      	movs	r5, #56	; 0x38
 80003ec:	600d      	str	r5, [r1, #0]
 80003ee:	e7ac      	b.n	800034a <irmp_get_data+0x22>
                irmp_address &= ~0x20;                              // clear toggle bit
 80003f0:	2620      	movs	r6, #32
 80003f2:	6805      	ldr	r5, [r0, #0]
 80003f4:	43b5      	bics	r5, r6
 80003f6:	6005      	str	r5, [r0, #0]
 80003f8:	e7a7      	b.n	800034a <irmp_get_data+0x22>
            irmp_protocol = IRMP_UNKNOWN_PROTOCOL;
 80003fa:	2000      	movs	r0, #0
 80003fc:	6008      	str	r0, [r1, #0]
 80003fe:	e7b4      	b.n	800036a <irmp_get_data+0x42>
 8000400:	20000064 	.word	0x20000064
 8000404:	200000b0 	.word	0x200000b0
 8000408:	20000058 	.word	0x20000058
 800040c:	20000050 	.word	0x20000050
 8000410:	2000005c 	.word	0x2000005c
 8000414:	20000060 	.word	0x20000060
 8000418:	000087ee 	.word	0x000087ee

0800041c <irmp_ISR>:
 *  @details  ISR routine, called 10000 times per second
 *---------------------------------------------------------------------------------------------------------------------------------------------------
 */
uint_fast8_t
irmp_ISR (void)
{
 800041c:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    irmp_input = input(IRMP_GPIO_STRUCT->IDR)
#elif defined(__MBED__)
    //irmp_input = inputPin;
    irmp_input = gpio_read (&gpioIRin);
#else
    irmp_input = input(IRMP_PIN);
 800041e:	2090      	movs	r0, #144	; 0x90
 8000420:	2140      	movs	r1, #64	; 0x40
 8000422:	05c0      	lsls	r0, r0, #23
 8000424:	f001 ff40 	bl	80022a8 <HAL_GPIO_ReadPin>
    }
#endif // IRMP_USE_CALLBACK == 1

    irmp_log(irmp_input);                                                       // log ir signal, if IRMP_LOGGING defined

    if (! irmp_ir_detected)                                                     // ir code already detected?
 8000428:	4bb6      	ldr	r3, [pc, #728]	; (8000704 <irmp_ISR+0x2e8>)
 800042a:	6819      	ldr	r1, [r3, #0]
 800042c:	2900      	cmp	r1, #0
 800042e:	d109      	bne.n	8000444 <irmp_ISR+0x28>
    {                                                                           // no...
        if (! irmp_start_bit_detected)                                          // start bit detected?
 8000430:	4ab5      	ldr	r2, [pc, #724]	; (8000708 <irmp_ISR+0x2ec>)
 8000432:	6813      	ldr	r3, [r2, #0]
 8000434:	2b00      	cmp	r3, #0
 8000436:	d127      	bne.n	8000488 <irmp_ISR+0x6c>
 8000438:	4cb4      	ldr	r4, [pc, #720]	; (800070c <irmp_ISR+0x2f0>)
 800043a:	6821      	ldr	r1, [r4, #0]
        {                                                                       // no...
            if (! irmp_input)                                                   // receiving burst?
 800043c:	2800      	cmp	r0, #0
 800043e:	d104      	bne.n	800044a <irmp_ISR+0x2e>
                if (! irmp_pulse_time)
                {
                    ANALYZE_PRINTF("%8.3fms [starting pulse]\n", (double) (time_counter * 1000) / F_INTERRUPTS);
                }
#endif // ANALYZE
                irmp_pulse_time++;                                              // increment counter
 8000440:	3101      	adds	r1, #1
 8000442:	6021      	str	r1, [r4, #0]

        irmp_idle();
    }
#endif // IRMP_USE_IDLE_CALL

    return (irmp_ir_detected);
 8000444:	4baf      	ldr	r3, [pc, #700]	; (8000704 <irmp_ISR+0x2e8>)
 8000446:	6818      	ldr	r0, [r3, #0]
}
 8000448:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
                if (irmp_pulse_time)                                            // it's dark....
 800044a:	2900      	cmp	r1, #0
 800044c:	d015      	beq.n	800047a <irmp_ISR+0x5e>
                    irmp_start_bit_detected = 1;
 800044e:	2101      	movs	r1, #1
                    irmp_bit                = 0xff;
 8000450:	20ff      	movs	r0, #255	; 0xff
                    irmp_start_bit_detected = 1;
 8000452:	6011      	str	r1, [r2, #0]
                    wait_for_start_space    = 1;
 8000454:	4aae      	ldr	r2, [pc, #696]	; (8000710 <irmp_ISR+0x2f4>)
 8000456:	6011      	str	r1, [r2, #0]
                    wait_for_space          = 0;
 8000458:	4aae      	ldr	r2, [pc, #696]	; (8000714 <irmp_ISR+0x2f8>)
 800045a:	6013      	str	r3, [r2, #0]
                    irmp_tmp_command        = 0;
 800045c:	4aae      	ldr	r2, [pc, #696]	; (8000718 <irmp_ISR+0x2fc>)
 800045e:	6013      	str	r3, [r2, #0]
                    irmp_tmp_address        = 0;
 8000460:	4aae      	ldr	r2, [pc, #696]	; (800071c <irmp_ISR+0x300>)
 8000462:	6013      	str	r3, [r2, #0]
                    genre2                  = 0;
 8000464:	4aae      	ldr	r2, [pc, #696]	; (8000720 <irmp_ISR+0x304>)
 8000466:	6013      	str	r3, [r2, #0]
                    irmp_tmp_id = 0;
 8000468:	4aae      	ldr	r2, [pc, #696]	; (8000724 <irmp_ISR+0x308>)
 800046a:	6013      	str	r3, [r2, #0]
                    irmp_bit                = 0xff;
 800046c:	4aae      	ldr	r2, [pc, #696]	; (8000728 <irmp_ISR+0x30c>)
 800046e:	6010      	str	r0, [r2, #0]
                    irmp_pause_time         = 1;                                // 1st pause: set to 1, not to 0!
 8000470:	4aae      	ldr	r2, [pc, #696]	; (800072c <irmp_ISR+0x310>)
 8000472:	7011      	strb	r1, [r2, #0]
                    rc5_cmd_bit6            = 0;                                // fm 2010-03-07: bugfix: reset it after incomplete RC5 frame!
 8000474:	4aae      	ldr	r2, [pc, #696]	; (8000730 <irmp_ISR+0x314>)
                        key_repetition_len++;
 8000476:	6013      	str	r3, [r2, #0]
 8000478:	e7e4      	b.n	8000444 <irmp_ISR+0x28>
                    if (key_repetition_len < 0xFFFF)                            // avoid overflow of counter
 800047a:	4aae      	ldr	r2, [pc, #696]	; (8000734 <irmp_ISR+0x318>)
 800047c:	49ae      	ldr	r1, [pc, #696]	; (8000738 <irmp_ISR+0x31c>)
 800047e:	6813      	ldr	r3, [r2, #0]
 8000480:	428b      	cmp	r3, r1
 8000482:	d8df      	bhi.n	8000444 <irmp_ISR+0x28>
                        key_repetition_len++;
 8000484:	3301      	adds	r3, #1
 8000486:	e7f6      	b.n	8000476 <irmp_ISR+0x5a>
            if (wait_for_start_space)                                           // we have received start bit...
 8000488:	4ba1      	ldr	r3, [pc, #644]	; (8000710 <irmp_ISR+0x2f4>)
 800048a:	681b      	ldr	r3, [r3, #0]
 800048c:	2b00      	cmp	r3, #0
 800048e:	d100      	bne.n	8000492 <irmp_ISR+0x76>
 8000490:	e114      	b.n	80006bc <irmp_ISR+0x2a0>
 8000492:	4ca6      	ldr	r4, [pc, #664]	; (800072c <irmp_ISR+0x310>)
                if (irmp_input)                                                 // still dark?
 8000494:	2800      	cmp	r0, #0
 8000496:	d065      	beq.n	8000564 <irmp_ISR+0x148>
                    irmp_pause_time++;                                          // increment counter
 8000498:	7823      	ldrb	r3, [r4, #0]
 800049a:	3301      	adds	r3, #1
 800049c:	b2db      	uxtb	r3, r3
 800049e:	7023      	strb	r3, [r4, #0]
                    if (irmp_pause_time > IRMP_TIMEOUT_LEN)                     // timeout?
 80004a0:	2bc2      	cmp	r3, #194	; 0xc2
 80004a2:	d905      	bls.n	80004b0 <irmp_ISR+0x94>
                        if (irmp_protocol == IRMP_JVC_PROTOCOL)                 // don't show eror if JVC protocol, irmp_pulse_time has been set below!
 80004a4:	4ba5      	ldr	r3, [pc, #660]	; (800073c <irmp_ISR+0x320>)
                        irmp_start_bit_detected = 0;                            // reset flags, let's wait for another start bit
 80004a6:	6011      	str	r1, [r2, #0]
                        if (irmp_protocol == IRMP_JVC_PROTOCOL)                 // don't show eror if JVC protocol, irmp_pulse_time has been set below!
 80004a8:	681b      	ldr	r3, [r3, #0]
                        irmp_pulse_time         = 0;
 80004aa:	4b98      	ldr	r3, [pc, #608]	; (800070c <irmp_ISR+0x2f0>)
                        irmp_pause_time         = 0;
 80004ac:	7021      	strb	r1, [r4, #0]
                        irmp_pulse_time         = 0;
 80004ae:	6019      	str	r1, [r3, #0]
            if (irmp_start_bit_detected && irmp_bit == irmp_param.complete_len && irmp_param.stop_bit == 0)    // enough bits received?
 80004b0:	4995      	ldr	r1, [pc, #596]	; (8000708 <irmp_ISR+0x2ec>)
 80004b2:	680b      	ldr	r3, [r1, #0]
 80004b4:	2b00      	cmp	r3, #0
 80004b6:	d0c5      	beq.n	8000444 <irmp_ISR+0x28>
 80004b8:	4aa1      	ldr	r2, [pc, #644]	; (8000740 <irmp_ISR+0x324>)
 80004ba:	4b9b      	ldr	r3, [pc, #620]	; (8000728 <irmp_ISR+0x30c>)
 80004bc:	6b54      	ldr	r4, [r2, #52]	; 0x34
 80004be:	681b      	ldr	r3, [r3, #0]
 80004c0:	429c      	cmp	r4, r3
 80004c2:	d1bf      	bne.n	8000444 <irmp_ISR+0x28>
 80004c4:	6b90      	ldr	r0, [r2, #56]	; 0x38
 80004c6:	2800      	cmp	r0, #0
 80004c8:	d1bc      	bne.n	8000444 <irmp_ISR+0x28>
                if (last_irmp_command == irmp_tmp_command && key_repetition_len < AUTO_FRAME_REPETITION_LEN)
 80004ca:	489e      	ldr	r0, [pc, #632]	; (8000744 <irmp_ISR+0x328>)
 80004cc:	6805      	ldr	r5, [r0, #0]
 80004ce:	4892      	ldr	r0, [pc, #584]	; (8000718 <irmp_ISR+0x2fc>)
 80004d0:	6806      	ldr	r6, [r0, #0]
 80004d2:	489d      	ldr	r0, [pc, #628]	; (8000748 <irmp_ISR+0x32c>)
 80004d4:	42b5      	cmp	r5, r6
 80004d6:	d000      	beq.n	80004da <irmp_ISR+0xbe>
 80004d8:	e278      	b.n	80009cc <irmp_ISR+0x5b0>
 80004da:	4f96      	ldr	r7, [pc, #600]	; (8000734 <irmp_ISR+0x318>)
 80004dc:	4e9b      	ldr	r6, [pc, #620]	; (800074c <irmp_ISR+0x330>)
 80004de:	683f      	ldr	r7, [r7, #0]
 80004e0:	42b7      	cmp	r7, r6
 80004e2:	d900      	bls.n	80004e6 <irmp_ISR+0xca>
 80004e4:	e272      	b.n	80009cc <irmp_ISR+0x5b0>
                    repetition_frame_number++;
 80004e6:	6806      	ldr	r6, [r0, #0]
 80004e8:	3601      	adds	r6, #1
                if (irmp_param.protocol == IRMP_SIRCS_PROTOCOL && (repetition_frame_number == 1 || repetition_frame_number == 2))
 80004ea:	6812      	ldr	r2, [r2, #0]
                    repetition_frame_number = 0;
 80004ec:	6006      	str	r6, [r0, #0]
                if (irmp_param.protocol == IRMP_SIRCS_PROTOCOL && (repetition_frame_number == 1 || repetition_frame_number == 2))
 80004ee:	2a01      	cmp	r2, #1
 80004f0:	d000      	beq.n	80004f4 <irmp_ISR+0xd8>
 80004f2:	e26d      	b.n	80009d0 <irmp_ISR+0x5b4>
 80004f4:	6800      	ldr	r0, [r0, #0]
 80004f6:	3801      	subs	r0, #1
 80004f8:	2801      	cmp	r0, #1
 80004fa:	d900      	bls.n	80004fe <irmp_ISR+0xe2>
 80004fc:	e268      	b.n	80009d0 <irmp_ISR+0x5b4>
                    key_repetition_len = 0;
 80004fe:	2200      	movs	r2, #0
 8000500:	4b8c      	ldr	r3, [pc, #560]	; (8000734 <irmp_ISR+0x318>)
                        irmp_id = irmp_tmp_id;
 8000502:	601a      	str	r2, [r3, #0]
                if (irmp_ir_detected)
 8000504:	4b7f      	ldr	r3, [pc, #508]	; (8000704 <irmp_ISR+0x2e8>)
 8000506:	681b      	ldr	r3, [r3, #0]
 8000508:	2b00      	cmp	r3, #0
 800050a:	d01c      	beq.n	8000546 <irmp_ISR+0x12a>
                    if (last_irmp_command == irmp_tmp_command &&
 800050c:	4b82      	ldr	r3, [pc, #520]	; (8000718 <irmp_ISR+0x2fc>)
 800050e:	4889      	ldr	r0, [pc, #548]	; (8000734 <irmp_ISR+0x318>)
 8000510:	681c      	ldr	r4, [r3, #0]
 8000512:	4b82      	ldr	r3, [pc, #520]	; (800071c <irmp_ISR+0x300>)
 8000514:	4d8e      	ldr	r5, [pc, #568]	; (8000750 <irmp_ISR+0x334>)
 8000516:	681e      	ldr	r6, [r3, #0]
 8000518:	4b8a      	ldr	r3, [pc, #552]	; (8000744 <irmp_ISR+0x328>)
 800051a:	681b      	ldr	r3, [r3, #0]
 800051c:	42a3      	cmp	r3, r4
 800051e:	d10d      	bne.n	800053c <irmp_ISR+0x120>
 8000520:	682b      	ldr	r3, [r5, #0]
 8000522:	42b3      	cmp	r3, r6
 8000524:	d10a      	bne.n	800053c <irmp_ISR+0x120>
                        last_irmp_address == irmp_tmp_address &&
 8000526:	4b8b      	ldr	r3, [pc, #556]	; (8000754 <irmp_ISR+0x338>)
 8000528:	6807      	ldr	r7, [r0, #0]
 800052a:	429f      	cmp	r7, r3
 800052c:	d806      	bhi.n	800053c <irmp_ISR+0x120>
                        irmp_flags |= IRMP_FLAG_REPETITION;
 800052e:	4f8a      	ldr	r7, [pc, #552]	; (8000758 <irmp_ISR+0x33c>)
 8000530:	683b      	ldr	r3, [r7, #0]
 8000532:	469c      	mov	ip, r3
 8000534:	2301      	movs	r3, #1
 8000536:	4662      	mov	r2, ip
 8000538:	4313      	orrs	r3, r2
 800053a:	603b      	str	r3, [r7, #0]
                    last_irmp_command = irmp_tmp_command;                           // store as last command, too
 800053c:	4b81      	ldr	r3, [pc, #516]	; (8000744 <irmp_ISR+0x328>)
                    last_irmp_address = irmp_tmp_address;                           // store as last address, too
 800053e:	602e      	str	r6, [r5, #0]
                    last_irmp_command = irmp_tmp_command;                           // store as last command, too
 8000540:	601c      	str	r4, [r3, #0]
                    key_repetition_len = 0;
 8000542:	2300      	movs	r3, #0
 8000544:	6003      	str	r3, [r0, #0]
                irmp_start_bit_detected = 0;                                        // and wait for next start bit
 8000546:	2300      	movs	r3, #0
                irmp_tmp_command        = 0;
 8000548:	4a73      	ldr	r2, [pc, #460]	; (8000718 <irmp_ISR+0x2fc>)
                irmp_start_bit_detected = 0;                                        // and wait for next start bit
 800054a:	600b      	str	r3, [r1, #0]
                irmp_tmp_command        = 0;
 800054c:	6013      	str	r3, [r2, #0]
                irmp_pause_time         = 0;
 800054e:	4977      	ldr	r1, [pc, #476]	; (800072c <irmp_ISR+0x310>)
                irmp_pulse_time         = 0;
 8000550:	4a6e      	ldr	r2, [pc, #440]	; (800070c <irmp_ISR+0x2f0>)
                irmp_pause_time         = 0;
 8000552:	700b      	strb	r3, [r1, #0]
                irmp_pulse_time         = 0;
 8000554:	6013      	str	r3, [r2, #0]
                if (irmp_protocol == IRMP_JVC_PROTOCOL)                             // the stop bit of JVC frame is also start bit of next frame
 8000556:	4b79      	ldr	r3, [pc, #484]	; (800073c <irmp_ISR+0x320>)
 8000558:	681b      	ldr	r3, [r3, #0]
 800055a:	2b14      	cmp	r3, #20
 800055c:	d000      	beq.n	8000560 <irmp_ISR+0x144>
 800055e:	e771      	b.n	8000444 <irmp_ISR+0x28>
                    irmp_pulse_time = ((uint_fast8_t)(F_INTERRUPTS * JVC_START_BIT_PULSE_TIME));
 8000560:	335c      	adds	r3, #92	; 0x5c
 8000562:	e788      	b.n	8000476 <irmp_ISR+0x5a>
                    if (irmp_pulse_time >= SIRCS_START_BIT_PULSE_LEN_MIN && irmp_pulse_time <= SIRCS_START_BIT_PULSE_LEN_MAX &&
 8000564:	4f69      	ldr	r7, [pc, #420]	; (800070c <irmp_ISR+0x2f0>)
 8000566:	683b      	ldr	r3, [r7, #0]
 8000568:	0019      	movs	r1, r3
 800056a:	391a      	subs	r1, #26
 800056c:	2908      	cmp	r1, #8
 800056e:	d804      	bhi.n	800057a <irmp_ISR+0x15e>
 8000570:	7820      	ldrb	r0, [r4, #0]
                        irmp_param_p = (IRMP_PARAMETER *) &sircs_param;
 8000572:	497a      	ldr	r1, [pc, #488]	; (800075c <irmp_ISR+0x340>)
                    if (irmp_pulse_time >= SIRCS_START_BIT_PULSE_LEN_MIN && irmp_pulse_time <= SIRCS_START_BIT_PULSE_LEN_MAX &&
 8000574:	3805      	subs	r0, #5
 8000576:	2804      	cmp	r0, #4
 8000578:	d922      	bls.n	80005c0 <irmp_ISR+0x1a4>
                    if (irmp_protocol == IRMP_JVC_PROTOCOL &&                                                       // last protocol was JVC, awaiting repeat frame
 800057a:	4d70      	ldr	r5, [pc, #448]	; (800073c <irmp_ISR+0x320>)
 800057c:	6829      	ldr	r1, [r5, #0]
 800057e:	2914      	cmp	r1, #20
 8000580:	d108      	bne.n	8000594 <irmp_ISR+0x178>
 8000582:	0019      	movs	r1, r3
 8000584:	3942      	subs	r1, #66	; 0x42
 8000586:	295c      	cmp	r1, #92	; 0x5c
 8000588:	d804      	bhi.n	8000594 <irmp_ISR+0x178>
                        irmp_pulse_time >= JVC_START_BIT_PULSE_LEN_MIN && irmp_pulse_time <= JVC_START_BIT_PULSE_LEN_MAX &&
 800058a:	7820      	ldrb	r0, [r4, #0]
                        irmp_param_p = (IRMP_PARAMETER *) &nec_param;
 800058c:	4974      	ldr	r1, [pc, #464]	; (8000760 <irmp_ISR+0x344>)
                        irmp_pulse_time >= JVC_START_BIT_PULSE_LEN_MIN && irmp_pulse_time <= JVC_START_BIT_PULSE_LEN_MAX &&
 800058e:	3830      	subs	r0, #48	; 0x30
 8000590:	2859      	cmp	r0, #89	; 0x59
 8000592:	d915      	bls.n	80005c0 <irmp_ISR+0x1a4>
                    if (irmp_pulse_time >= NEC_START_BIT_PULSE_LEN_MIN && irmp_pulse_time <= NEC_START_BIT_PULSE_LEN_MAX &&
 8000594:	214e      	movs	r1, #78	; 0x4e
 8000596:	4249      	negs	r1, r1
 8000598:	468c      	mov	ip, r1
 800059a:	449c      	add	ip, r3
 800059c:	4661      	mov	r1, ip
 800059e:	2945      	cmp	r1, #69	; 0x45
 80005a0:	d834      	bhi.n	800060c <irmp_ISR+0x1f0>
                        irmp_pause_time >= NEC_START_BIT_PAUSE_LEN_MIN && irmp_pause_time <= NEC_START_BIT_PAUSE_LEN_MAX)
 80005a2:	7820      	ldrb	r0, [r4, #0]
                    if (irmp_pulse_time >= NEC_START_BIT_PULSE_LEN_MIN && irmp_pulse_time <= NEC_START_BIT_PULSE_LEN_MAX &&
 80005a4:	0001      	movs	r1, r0
 80005a6:	3926      	subs	r1, #38	; 0x26
 80005a8:	000e      	movs	r6, r1
                        irmp_param_p = (IRMP_PARAMETER *) &nec_param;
 80005aa:	496d      	ldr	r1, [pc, #436]	; (8000760 <irmp_ISR+0x344>)
                    if (irmp_pulse_time >= NEC_START_BIT_PULSE_LEN_MIN && irmp_pulse_time <= NEC_START_BIT_PULSE_LEN_MAX &&
 80005ac:	2e24      	cmp	r6, #36	; 0x24
 80005ae:	d907      	bls.n	80005c0 <irmp_ISR+0x1a4>
                    else if (irmp_pulse_time >= NEC_START_BIT_PULSE_LEN_MIN        && irmp_pulse_time <= NEC_START_BIT_PULSE_LEN_MAX &&
 80005b0:	3813      	subs	r0, #19
 80005b2:	2813      	cmp	r0, #19
 80005b4:	d82a      	bhi.n	800060c <irmp_ISR+0x1f0>
                        if (irmp_protocol == IRMP_JVC_PROTOCOL)                 // last protocol was JVC, awaiting repeat frame
 80005b6:	682b      	ldr	r3, [r5, #0]
                            irmp_param_p = (IRMP_PARAMETER *) &nec_rep_param;
 80005b8:	496a      	ldr	r1, [pc, #424]	; (8000764 <irmp_ISR+0x348>)
                        if (irmp_protocol == IRMP_JVC_PROTOCOL)                 // last protocol was JVC, awaiting repeat frame
 80005ba:	2b14      	cmp	r3, #20
 80005bc:	d100      	bne.n	80005c0 <irmp_ISR+0x1a4>
                        irmp_param_p = (IRMP_PARAMETER *) &nec_param;
 80005be:	4968      	ldr	r1, [pc, #416]	; (8000760 <irmp_ISR+0x344>)
                    if (irmp_start_bit_detected)
 80005c0:	6813      	ldr	r3, [r2, #0]
 80005c2:	4d5f      	ldr	r5, [pc, #380]	; (8000740 <irmp_ISR+0x324>)
 80005c4:	2b00      	cmp	r3, #0
 80005c6:	d003      	beq.n	80005d0 <irmp_ISR+0x1b4>
                        memcpy_P (&irmp_param, irmp_param_p, sizeof (IRMP_PARAMETER));
 80005c8:	2244      	movs	r2, #68	; 0x44
 80005ca:	0028      	movs	r0, r5
 80005cc:	f003 f92e 	bl	800382c <memcpy>
                    irmp_bit = 0;
 80005d0:	2200      	movs	r2, #0
                    if ((irmp_param.flags & IRMP_PARAM_FLAG_IS_MANCHESTER) &&
 80005d2:	2001      	movs	r0, #1
                    irmp_bit = 0;
 80005d4:	4b54      	ldr	r3, [pc, #336]	; (8000728 <irmp_ISR+0x30c>)
 80005d6:	601a      	str	r2, [r3, #0]
                    if ((irmp_param.flags & IRMP_PARAM_FLAG_IS_MANCHESTER) &&
 80005d8:	6c2b      	ldr	r3, [r5, #64]	; 0x40
 80005da:	4203      	tst	r3, r0
 80005dc:	d00f      	beq.n	80005fe <irmp_ISR+0x1e2>
                         irmp_param.protocol != IRMP_RUWIDO_PROTOCOL && // Manchester, but not RUWIDO
 80005de:	682a      	ldr	r2, [r5, #0]
                    if ((irmp_param.flags & IRMP_PARAM_FLAG_IS_MANCHESTER) &&
 80005e0:	2a17      	cmp	r2, #23
 80005e2:	d00c      	beq.n	80005fe <irmp_ISR+0x1e2>
                         irmp_param.protocol != IRMP_RUWIDO_PROTOCOL && // Manchester, but not RUWIDO
 80005e4:	2a09      	cmp	r2, #9
 80005e6:	d00a      	beq.n	80005fe <irmp_ISR+0x1e2>
                        if (irmp_pause_time > irmp_param.pulse_1_len_max && irmp_pause_time <= 2 * irmp_param.pulse_1_len_max)
 80005e8:	7821      	ldrb	r1, [r4, #0]
 80005ea:	68aa      	ldr	r2, [r5, #8]
 80005ec:	4291      	cmp	r1, r2
 80005ee:	d95e      	bls.n	80006ae <irmp_ISR+0x292>
 80005f0:	4082      	lsls	r2, r0
 80005f2:	4291      	cmp	r1, r2
 80005f4:	d85b      	bhi.n	80006ae <irmp_ISR+0x292>
                            irmp_store_bit ((irmp_param.flags & IRMP_PARAM_FLAG_1ST_PULSE_IS_1) ? 0 : 1);
 80005f6:	40c3      	lsrs	r3, r0
 80005f8:	4398      	bics	r0, r3
                            irmp_store_bit ((irmp_param.flags & IRMP_PARAM_FLAG_1ST_PULSE_IS_1) ? 1 : 0);
 80005fa:	f7ff fe31 	bl	8000260 <irmp_store_bit>
                    irmp_pulse_time = 1;                                        // set counter to 1, not 0
 80005fe:	2301      	movs	r3, #1
 8000600:	603b      	str	r3, [r7, #0]
                    irmp_pause_time = 0;
 8000602:	2300      	movs	r3, #0
                    wait_for_start_space = 0;
 8000604:	4a42      	ldr	r2, [pc, #264]	; (8000710 <irmp_ISR+0x2f4>)
                    irmp_pause_time = 0;
 8000606:	7023      	strb	r3, [r4, #0]
                    irmp_pulse_time++;                                              // increment counter
 8000608:	6013      	str	r3, [r2, #0]
 800060a:	e751      	b.n	80004b0 <irmp_ISR+0x94>
                    if (irmp_protocol == IRMP_JVC_PROTOCOL &&                   // last protocol was JVC, awaiting repeat frame
 800060c:	6829      	ldr	r1, [r5, #0]
 800060e:	2914      	cmp	r1, #20
 8000610:	d107      	bne.n	8000622 <irmp_ISR+0x206>
 8000612:	4661      	mov	r1, ip
 8000614:	2945      	cmp	r1, #69	; 0x45
 8000616:	d804      	bhi.n	8000622 <irmp_ISR+0x206>
                        irmp_pulse_time >= NEC_START_BIT_PULSE_LEN_MIN && irmp_pulse_time <= NEC_START_BIT_PULSE_LEN_MAX &&
 8000618:	7820      	ldrb	r0, [r4, #0]
                        irmp_param_p = (IRMP_PARAMETER *) &nec_param;
 800061a:	4951      	ldr	r1, [pc, #324]	; (8000760 <irmp_ISR+0x344>)
                        irmp_pulse_time >= NEC_START_BIT_PULSE_LEN_MIN && irmp_pulse_time <= NEC_START_BIT_PULSE_LEN_MAX &&
 800061c:	3804      	subs	r0, #4
 800061e:	2806      	cmp	r0, #6
 8000620:	d9ce      	bls.n	80005c0 <irmp_ISR+0x1a4>
                    if (irmp_pulse_time >= SAMSUNG_START_BIT_PULSE_LEN_MIN && irmp_pulse_time <= SAMSUNG_START_BIT_PULSE_LEN_MAX &&
 8000622:	0019      	movs	r1, r3
 8000624:	3932      	subs	r1, #50	; 0x32
 8000626:	290d      	cmp	r1, #13
 8000628:	d804      	bhi.n	8000634 <irmp_ISR+0x218>
 800062a:	7820      	ldrb	r0, [r4, #0]
                        irmp_param_p = (IRMP_PARAMETER *) &samsung_param;
 800062c:	494e      	ldr	r1, [pc, #312]	; (8000768 <irmp_ISR+0x34c>)
                    if (irmp_pulse_time >= SAMSUNG_START_BIT_PULSE_LEN_MIN && irmp_pulse_time <= SAMSUNG_START_BIT_PULSE_LEN_MAX &&
 800062e:	3832      	subs	r0, #50	; 0x32
 8000630:	280d      	cmp	r0, #13
 8000632:	d9c5      	bls.n	80005c0 <irmp_ISR+0x1a4>
                    if (irmp_pulse_time >= KASEIKYO_START_BIT_PULSE_LEN_MIN && irmp_pulse_time <= KASEIKYO_START_BIT_PULSE_LEN_MAX &&
 8000634:	0019      	movs	r1, r3
 8000636:	3921      	subs	r1, #33	; 0x21
 8000638:	2913      	cmp	r1, #19
 800063a:	d804      	bhi.n	8000646 <irmp_ISR+0x22a>
 800063c:	7820      	ldrb	r0, [r4, #0]
                        irmp_param_p = (IRMP_PARAMETER *) &kaseikyo_param;
 800063e:	494b      	ldr	r1, [pc, #300]	; (800076c <irmp_ISR+0x350>)
                    if (irmp_pulse_time >= KASEIKYO_START_BIT_PULSE_LEN_MIN && irmp_pulse_time <= KASEIKYO_START_BIT_PULSE_LEN_MAX &&
 8000640:	3810      	subs	r0, #16
 8000642:	280a      	cmp	r0, #10
 8000644:	d9bc      	bls.n	80005c0 <irmp_ISR+0x1a4>
                    if (((irmp_pulse_time >= RC5_START_BIT_LEN_MIN     && irmp_pulse_time <= RC5_START_BIT_LEN_MAX) ||
 8000646:	0019      	movs	r1, r3
 8000648:	3909      	subs	r1, #9
 800064a:	2904      	cmp	r1, #4
 800064c:	d902      	bls.n	8000654 <irmp_ISR+0x238>
                         (irmp_pulse_time >= 2 * RC5_START_BIT_LEN_MIN && irmp_pulse_time <= 2 * RC5_START_BIT_LEN_MAX)) &&
 800064e:	3909      	subs	r1, #9
                    if (((irmp_pulse_time >= RC5_START_BIT_LEN_MIN     && irmp_pulse_time <= RC5_START_BIT_LEN_MAX) ||
 8000650:	2908      	cmp	r1, #8
 8000652:	d81a      	bhi.n	800068a <irmp_ISR+0x26e>
                        ((irmp_pause_time >= RC5_START_BIT_LEN_MIN     && irmp_pause_time <= RC5_START_BIT_LEN_MAX) ||
 8000654:	7820      	ldrb	r0, [r4, #0]
                         (irmp_pulse_time >= 2 * RC5_START_BIT_LEN_MIN && irmp_pulse_time <= 2 * RC5_START_BIT_LEN_MAX)) &&
 8000656:	0001      	movs	r1, r0
 8000658:	3909      	subs	r1, #9
 800065a:	2904      	cmp	r1, #4
 800065c:	d902      	bls.n	8000664 <irmp_ISR+0x248>
                        ((irmp_pause_time >= RC5_START_BIT_LEN_MIN     && irmp_pause_time <= RC5_START_BIT_LEN_MAX) ||
 800065e:	3909      	subs	r1, #9
 8000660:	2908      	cmp	r1, #8
 8000662:	d812      	bhi.n	800068a <irmp_ISR+0x26e>
                        last_pause = irmp_pause_time;
 8000664:	4942      	ldr	r1, [pc, #264]	; (8000770 <irmp_ISR+0x354>)
                        if ((irmp_pulse_time > RC5_START_BIT_LEN_MAX && irmp_pulse_time <= 2 * RC5_START_BIT_LEN_MAX) ||
 8000666:	3b0e      	subs	r3, #14
                        last_pause = irmp_pause_time;
 8000668:	7008      	strb	r0, [r1, #0]
 800066a:	4d42      	ldr	r5, [pc, #264]	; (8000774 <irmp_ISR+0x358>)
 800066c:	4942      	ldr	r1, [pc, #264]	; (8000778 <irmp_ISR+0x35c>)
                        if ((irmp_pulse_time > RC5_START_BIT_LEN_MAX && irmp_pulse_time <= 2 * RC5_START_BIT_LEN_MAX) ||
 800066e:	2b0c      	cmp	r3, #12
 8000670:	d902      	bls.n	8000678 <irmp_ISR+0x25c>
 8000672:	380e      	subs	r0, #14
 8000674:	280c      	cmp	r0, #12
 8000676:	d805      	bhi.n	8000684 <irmp_ISR+0x268>
                            last_value  = 0;
 8000678:	2300      	movs	r3, #0
                            rc5_cmd_bit6 = 1<<6;
 800067a:	2040      	movs	r0, #64	; 0x40
                            last_value  = 0;
 800067c:	602b      	str	r3, [r5, #0]
                            rc5_cmd_bit6 = 1<<6;
 800067e:	4b2c      	ldr	r3, [pc, #176]	; (8000730 <irmp_ISR+0x314>)
 8000680:	6018      	str	r0, [r3, #0]
 8000682:	e79d      	b.n	80005c0 <irmp_ISR+0x1a4>
                            last_value  = 1;
 8000684:	2301      	movs	r3, #1
 8000686:	602b      	str	r3, [r5, #0]
 8000688:	e79a      	b.n	80005c0 <irmp_ISR+0x1a4>
                    if (irmp_pulse_time >= RC6_START_BIT_PULSE_LEN_MIN && irmp_pulse_time <= RC6_START_BIT_PULSE_LEN_MAX &&
 800068a:	3b1d      	subs	r3, #29
 800068c:	2b09      	cmp	r3, #9
 800068e:	d80b      	bhi.n	80006a8 <irmp_ISR+0x28c>
 8000690:	7823      	ldrb	r3, [r4, #0]
 8000692:	3b09      	subs	r3, #9
 8000694:	2b04      	cmp	r3, #4
 8000696:	d807      	bhi.n	80006a8 <irmp_ISR+0x28c>
                        last_pause = 0;
 8000698:	2100      	movs	r1, #0
 800069a:	4b35      	ldr	r3, [pc, #212]	; (8000770 <irmp_ISR+0x354>)
 800069c:	7019      	strb	r1, [r3, #0]
                        last_value = 1;
 800069e:	4b35      	ldr	r3, [pc, #212]	; (8000774 <irmp_ISR+0x358>)
 80006a0:	3101      	adds	r1, #1
 80006a2:	6019      	str	r1, [r3, #0]
                        irmp_param_p = (IRMP_PARAMETER *) &rc6_param;
 80006a4:	4935      	ldr	r1, [pc, #212]	; (800077c <irmp_ISR+0x360>)
                        last_value = 1;
 80006a6:	e78b      	b.n	80005c0 <irmp_ISR+0x1a4>
                        irmp_start_bit_detected = 0;                            // wait for another start bit...
 80006a8:	2100      	movs	r1, #0
 80006aa:	6011      	str	r1, [r2, #0]
 80006ac:	e788      	b.n	80005c0 <irmp_ISR+0x1a4>
                        else if (! last_value)  // && irmp_pause_time >= irmp_param.pause_1_len_min && irmp_pause_time <= irmp_param.pause_1_len_max)
 80006ae:	4a31      	ldr	r2, [pc, #196]	; (8000774 <irmp_ISR+0x358>)
 80006b0:	6812      	ldr	r2, [r2, #0]
 80006b2:	2a00      	cmp	r2, #0
 80006b4:	d1a3      	bne.n	80005fe <irmp_ISR+0x1e2>
                            irmp_store_bit ((irmp_param.flags & IRMP_PARAM_FLAG_1ST_PULSE_IS_1) ? 1 : 0);
 80006b6:	0798      	lsls	r0, r3, #30
 80006b8:	0fc0      	lsrs	r0, r0, #31
 80006ba:	e79e      	b.n	80005fa <irmp_ISR+0x1de>
            else if (wait_for_space)                                            // the data section....
 80006bc:	4a15      	ldr	r2, [pc, #84]	; (8000714 <irmp_ISR+0x2f8>)
 80006be:	6813      	ldr	r3, [r2, #0]
 80006c0:	2b00      	cmp	r3, #0
 80006c2:	d100      	bne.n	80006c6 <irmp_ISR+0x2aa>
 80006c4:	e17a      	b.n	80009bc <irmp_ISR+0x5a0>
 80006c6:	2701      	movs	r7, #1
 80006c8:	4b1d      	ldr	r3, [pc, #116]	; (8000740 <irmp_ISR+0x324>)
 80006ca:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 80006cc:	4694      	mov	ip, r2
 80006ce:	4017      	ands	r7, r2
                if (irmp_input)                                                 // still dark?
 80006d0:	2800      	cmp	r0, #0
 80006d2:	d070      	beq.n	80007b6 <irmp_ISR+0x39a>
                    if (irmp_bit == irmp_param.complete_len && irmp_param.stop_bit == 1)
 80006d4:	4a14      	ldr	r2, [pc, #80]	; (8000728 <irmp_ISR+0x30c>)
 80006d6:	6b5c      	ldr	r4, [r3, #52]	; 0x34
 80006d8:	6812      	ldr	r2, [r2, #0]
 80006da:	4294      	cmp	r4, r2
 80006dc:	d150      	bne.n	8000780 <irmp_ISR+0x364>
 80006de:	6b99      	ldr	r1, [r3, #56]	; 0x38
 80006e0:	2901      	cmp	r1, #1
 80006e2:	d14d      	bne.n	8000780 <irmp_ISR+0x364>
                        if (
 80006e4:	2f00      	cmp	r7, #0
 80006e6:	d109      	bne.n	80006fc <irmp_ISR+0x2e0>
                            (irmp_pulse_time >= irmp_param.pulse_0_len_min && irmp_pulse_time <= irmp_param.pulse_0_len_max))
 80006e8:	4a08      	ldr	r2, [pc, #32]	; (800070c <irmp_ISR+0x2f0>)
                            (irmp_param.flags & IRMP_PARAM_FLAG_IS_MANCHESTER) ||
 80006ea:	6959      	ldr	r1, [r3, #20]
                            (irmp_pulse_time >= irmp_param.pulse_0_len_min && irmp_pulse_time <= irmp_param.pulse_0_len_max))
 80006ec:	6812      	ldr	r2, [r2, #0]
                            (irmp_param.flags & IRMP_PARAM_FLAG_IS_MANCHESTER) ||
 80006ee:	4291      	cmp	r1, r2
 80006f0:	d900      	bls.n	80006f4 <irmp_ISR+0x2d8>
 80006f2:	e0a9      	b.n	8000848 <irmp_ISR+0x42c>
                            (irmp_pulse_time >= irmp_param.pulse_0_len_min && irmp_pulse_time <= irmp_param.pulse_0_len_max))
 80006f4:	6999      	ldr	r1, [r3, #24]
 80006f6:	428a      	cmp	r2, r1
 80006f8:	d900      	bls.n	80006fc <irmp_ISR+0x2e0>
 80006fa:	e0a5      	b.n	8000848 <irmp_ISR+0x42c>
                            irmp_param.stop_bit = 0;
 80006fc:	2200      	movs	r2, #0
 80006fe:	639a      	str	r2, [r3, #56]	; 0x38
 8000700:	e6d6      	b.n	80004b0 <irmp_ISR+0x94>
 8000702:	46c0      	nop			; (mov r8, r8)
 8000704:	20000064 	.word	0x20000064
 8000708:	200000b8 	.word	0x200000b8
 800070c:	200000b4 	.word	0x200000b4
 8000710:	200000e0 	.word	0x200000e0
 8000714:	200000dc 	.word	0x200000dc
 8000718:	200000c0 	.word	0x200000c0
 800071c:	200000bc 	.word	0x200000bc
 8000720:	2000004c 	.word	0x2000004c
 8000724:	200000c4 	.word	0x200000c4
 8000728:	20000054 	.word	0x20000054
 800072c:	200000ac 	.word	0x200000ac
 8000730:	200000d4 	.word	0x200000d4
 8000734:	200000c8 	.word	0x200000c8
 8000738:	0000fffe 	.word	0x0000fffe
 800073c:	200000b0 	.word	0x200000b0
 8000740:	20000068 	.word	0x20000068
 8000744:	20000004 	.word	0x20000004
 8000748:	200000d8 	.word	0x200000d8
 800074c:	000003e7 	.word	0x000003e7
 8000750:	20000000 	.word	0x20000000
 8000754:	00000752 	.word	0x00000752
 8000758:	2000005c 	.word	0x2000005c
 800075c:	08003a50 	.word	0x08003a50
 8000760:	080038fc 	.word	0x080038fc
 8000764:	08003940 	.word	0x08003940
 8000768:	08003a0c 	.word	0x08003a0c
 800076c:	080038b8 	.word	0x080038b8
 8000770:	200000cc 	.word	0x200000cc
 8000774:	200000d0 	.word	0x200000d0
 8000778:	08003984 	.word	0x08003984
 800077c:	080039c8 	.word	0x080039c8
                        irmp_pause_time++;                                                          // increment counter
 8000780:	4eb4      	ldr	r6, [pc, #720]	; (8000a54 <irmp_ISR+0x638>)
                        if (irmp_param.protocol == IRMP_SIRCS_PROTOCOL &&                           // Sony has a variable number of bits:
 8000782:	49b5      	ldr	r1, [pc, #724]	; (8000a58 <irmp_ISR+0x63c>)
                        irmp_pause_time++;                                                          // increment counter
 8000784:	7830      	ldrb	r0, [r6, #0]
                        if (irmp_param.protocol == IRMP_SIRCS_PROTOCOL &&                           // Sony has a variable number of bits:
 8000786:	680d      	ldr	r5, [r1, #0]
                        irmp_pause_time++;                                                          // increment counter
 8000788:	3001      	adds	r0, #1
 800078a:	b2c0      	uxtb	r0, r0
 800078c:	7030      	strb	r0, [r6, #0]
                        if (irmp_param.protocol == IRMP_SIRCS_PROTOCOL &&                           // Sony has a variable number of bits:
 800078e:	2d01      	cmp	r5, #1
 8000790:	d137      	bne.n	8000802 <irmp_ISR+0x3e6>
 8000792:	2809      	cmp	r0, #9
 8000794:	d935      	bls.n	8000802 <irmp_ISR+0x3e6>
                            irmp_pause_time > SIRCS_PAUSE_LEN_MAX &&                                // minimum is 12
 8000796:	2a0a      	cmp	r2, #10
 8000798:	d933      	bls.n	8000802 <irmp_ISR+0x3e6>
                            irmp_tmp_address |= (irmp_bit - SIRCS_MINIMUM_DATA_LEN + 1) << 8;       // new: store number of additional bits in upper byte of address!
 800079a:	48b0      	ldr	r0, [pc, #704]	; (8000a5c <irmp_ISR+0x640>)
                            irmp_param.complete_len = irmp_bit + 1;                                 // set new complete length
 800079c:	1c53      	adds	r3, r2, #1
                            irmp_tmp_address |= (irmp_bit - SIRCS_MINIMUM_DATA_LEN + 1) << 8;       // new: store number of additional bits in upper byte of address!
 800079e:	6804      	ldr	r4, [r0, #0]
                            irmp_param.complete_len = irmp_bit + 1;                                 // set new complete length
 80007a0:	634b      	str	r3, [r1, #52]	; 0x34
                            irmp_tmp_address |= (irmp_bit - SIRCS_MINIMUM_DATA_LEN + 1) << 8;       // new: store number of additional bits in upper byte of address!
 80007a2:	3b0c      	subs	r3, #12
 80007a4:	021b      	lsls	r3, r3, #8
 80007a6:	4323      	orrs	r3, r4
 80007a8:	6003      	str	r3, [r0, #0]
                            irmp_param.command_end = irmp_param.command_offset + irmp_bit + 1;      // correct command length
 80007aa:	6acb      	ldr	r3, [r1, #44]	; 0x2c
 80007ac:	18d2      	adds	r2, r2, r3
                            irmp_pause_time = SIRCS_PAUSE_LEN_MAX - 1;                              // correct pause length
 80007ae:	2308      	movs	r3, #8
                            irmp_param.command_end = irmp_param.command_offset + irmp_bit + 1;      // correct command length
 80007b0:	3201      	adds	r2, #1
 80007b2:	630a      	str	r2, [r1, #48]	; 0x30
                            irmp_pause_time = SIRCS_PAUSE_LEN_MAX - 1;                              // correct pause length
 80007b4:	7033      	strb	r3, [r6, #0]
 80007b6:	4baa      	ldr	r3, [pc, #680]	; (8000a60 <irmp_ISR+0x644>)
 80007b8:	4aaa      	ldr	r2, [pc, #680]	; (8000a64 <irmp_ISR+0x648>)
 80007ba:	681d      	ldr	r5, [r3, #0]
 80007bc:	4ea5      	ldr	r6, [pc, #660]	; (8000a54 <irmp_ISR+0x638>)
 80007be:	4ca6      	ldr	r4, [pc, #664]	; (8000a58 <irmp_ISR+0x63c>)
                    if ((irmp_param.flags & IRMP_PARAM_FLAG_IS_MANCHESTER))                                     // Manchester
 80007c0:	2f00      	cmp	r7, #0
 80007c2:	d100      	bne.n	80007c6 <irmp_ISR+0x3aa>
 80007c4:	e0b7      	b.n	8000936 <irmp_ISR+0x51a>
                        if (irmp_pulse_time > irmp_param.pulse_1_len_max /* && irmp_pulse_time <= 2 * irmp_param.pulse_1_len_max */)
 80007c6:	68a3      	ldr	r3, [r4, #8]
 80007c8:	42ab      	cmp	r3, r5
 80007ca:	d300      	bcc.n	80007ce <irmp_ISR+0x3b2>
 80007cc:	e087      	b.n	80008de <irmp_ISR+0x4c2>
                            if (irmp_param.protocol == IRMP_RC6_PROTOCOL && irmp_bit == 4 && irmp_pulse_time > RC6_TOGGLE_BIT_LEN_MIN)         // RC6 toggle bit
 80007ce:	6823      	ldr	r3, [r4, #0]
 80007d0:	9300      	str	r3, [sp, #0]
 80007d2:	2b09      	cmp	r3, #9
 80007d4:	d15c      	bne.n	8000890 <irmp_ISR+0x474>
 80007d6:	4ba4      	ldr	r3, [pc, #656]	; (8000a68 <irmp_ISR+0x64c>)
 80007d8:	681b      	ldr	r3, [r3, #0]
 80007da:	2b04      	cmp	r3, #4
 80007dc:	d158      	bne.n	8000890 <irmp_ISR+0x474>
 80007de:	2d09      	cmp	r5, #9
 80007e0:	d956      	bls.n	8000890 <irmp_ISR+0x474>
                                if (irmp_param.complete_len == RC6_COMPLETE_DATA_LEN_LONG)                      // RC6 mode 6A
 80007e2:	6b63      	ldr	r3, [r4, #52]	; 0x34
 80007e4:	4ca1      	ldr	r4, [pc, #644]	; (8000a6c <irmp_ISR+0x650>)
 80007e6:	2b24      	cmp	r3, #36	; 0x24
 80007e8:	d14d      	bne.n	8000886 <irmp_ISR+0x46a>
                                    irmp_store_bit (1);
 80007ea:	2001      	movs	r0, #1
 80007ec:	f7ff fd38 	bl	8000260 <irmp_store_bit>
                                    last_value = 1;
 80007f0:	2301      	movs	r3, #1
                                    last_value = 0;
 80007f2:	6023      	str	r3, [r4, #0]
                        last_pause      = irmp_pause_time;
 80007f4:	7833      	ldrb	r3, [r6, #0]
 80007f6:	4a9e      	ldr	r2, [pc, #632]	; (8000a70 <irmp_ISR+0x654>)
 80007f8:	7013      	strb	r3, [r2, #0]
                                wait_for_space = 0;
 80007fa:	2200      	movs	r2, #0
 80007fc:	4b9d      	ldr	r3, [pc, #628]	; (8000a74 <irmp_ISR+0x658>)
 80007fe:	601a      	str	r2, [r3, #0]
 8000800:	e0ac      	b.n	800095c <irmp_ISR+0x540>
                        if ((irmp_param.flags & IRMP_PARAM_FLAG_IS_MANCHESTER) &&
 8000802:	2f00      	cmp	r7, #0
 8000804:	d00c      	beq.n	8000820 <irmp_ISR+0x404>
                            irmp_pause_time >= 2 * irmp_param.pause_1_len_max && irmp_bit >= irmp_param.complete_len - 2 && !irmp_param.stop_bit)
 8000806:	690e      	ldr	r6, [r1, #16]
 8000808:	0076      	lsls	r6, r6, #1
                        if ((irmp_param.flags & IRMP_PARAM_FLAG_IS_MANCHESTER) &&
 800080a:	42b0      	cmp	r0, r6
 800080c:	d308      	bcc.n	8000820 <irmp_ISR+0x404>
                            irmp_pause_time >= 2 * irmp_param.pause_1_len_max && irmp_bit >= irmp_param.complete_len - 2 && !irmp_param.stop_bit)
 800080e:	1ea6      	subs	r6, r4, #2
 8000810:	42b2      	cmp	r2, r6
 8000812:	d305      	bcc.n	8000820 <irmp_ISR+0x404>
 8000814:	6b8e      	ldr	r6, [r1, #56]	; 0x38
 8000816:	2e00      	cmp	r6, #0
 8000818:	d102      	bne.n	8000820 <irmp_ISR+0x404>
                            irmp_param.stop_bit = TRUE;                         // set flag
 800081a:	2301      	movs	r3, #1
 800081c:	638b      	str	r3, [r1, #56]	; 0x38
 800081e:	e7ca      	b.n	80007b6 <irmp_ISR+0x39a>
                        if (irmp_pause_time > IRMP_TIMEOUT_LEN)                 // timeout?
 8000820:	28c2      	cmp	r0, #194	; 0xc2
 8000822:	d800      	bhi.n	8000826 <irmp_ISR+0x40a>
 8000824:	e644      	b.n	80004b0 <irmp_ISR+0x94>
                            if (irmp_bit == irmp_param.complete_len - 1 && irmp_param.stop_bit == 0)
 8000826:	1e60      	subs	r0, r4, #1
 8000828:	4282      	cmp	r2, r0
 800082a:	d105      	bne.n	8000838 <irmp_ISR+0x41c>
 800082c:	6b89      	ldr	r1, [r1, #56]	; 0x38
 800082e:	2900      	cmp	r1, #0
 8000830:	d102      	bne.n	8000838 <irmp_ISR+0x41c>
                                irmp_bit++;
 8000832:	4b8d      	ldr	r3, [pc, #564]	; (8000a68 <irmp_ISR+0x64c>)
 8000834:	601c      	str	r4, [r3, #0]
 8000836:	e63b      	b.n	80004b0 <irmp_ISR+0x94>
                            else if ((irmp_param.protocol == IRMP_NEC_PROTOCOL || irmp_param.protocol == IRMP_NEC42_PROTOCOL) && irmp_bit == 0)
 8000838:	2d02      	cmp	r5, #2
 800083a:	d100      	bne.n	800083e <irmp_ISR+0x422>
 800083c:	e14d      	b.n	8000ada <irmp_ISR+0x6be>
 800083e:	2d1c      	cmp	r5, #28
 8000840:	d102      	bne.n	8000848 <irmp_ISR+0x42c>
 8000842:	2a00      	cmp	r2, #0
 8000844:	d100      	bne.n	8000848 <irmp_ISR+0x42c>
 8000846:	e14b      	b.n	8000ae0 <irmp_ISR+0x6c4>
                            irmp_start_bit_detected = 0;                        // wait for another start bit...
 8000848:	2300      	movs	r3, #0
 800084a:	4a86      	ldr	r2, [pc, #536]	; (8000a64 <irmp_ISR+0x648>)
 800084c:	6013      	str	r3, [r2, #0]
                            irmp_pulse_time         = 0;
 800084e:	4a84      	ldr	r2, [pc, #528]	; (8000a60 <irmp_ISR+0x644>)
                    wait_for_space  = 1;                                            // let's count the time (see above)
 8000850:	6013      	str	r3, [r2, #0]
                    irmp_pause_time = 1;                                            // set pause counter to 1, not 0
 8000852:	4a80      	ldr	r2, [pc, #512]	; (8000a54 <irmp_ISR+0x638>)
 8000854:	7013      	strb	r3, [r2, #0]
 8000856:	e62b      	b.n	80004b0 <irmp_ISR+0x94>
                                    irmp_ir_detected = FALSE;
 8000858:	2300      	movs	r3, #0
 800085a:	4a87      	ldr	r2, [pc, #540]	; (8000a78 <irmp_ISR+0x65c>)
 800085c:	e6d4      	b.n	8000608 <irmp_ISR+0x1ec>
                            else if (irmp_param.protocol == IRMP_NEC_PROTOCOL && (irmp_bit == 16 || irmp_bit == 17))      // it was a JVC stop bit
 800085e:	0011      	movs	r1, r2
 8000860:	3910      	subs	r1, #16
 8000862:	2901      	cmp	r1, #1
 8000864:	d8f0      	bhi.n	8000848 <irmp_ISR+0x42c>
                                irmp_param.stop_bit     = TRUE;                                     // set flag
 8000866:	2101      	movs	r1, #1
                                irmp_param.protocol     = IRMP_JVC_PROTOCOL;                        // switch protocol
 8000868:	2014      	movs	r0, #20
                                irmp_param.complete_len = irmp_bit;                                 // patch length: 16 or 17
 800086a:	635a      	str	r2, [r3, #52]	; 0x34
                                irmp_tmp_command        = (irmp_tmp_address >> 4);                  // set command: upper 12 bits are command bits
 800086c:	4a7b      	ldr	r2, [pc, #492]	; (8000a5c <irmp_ISR+0x640>)
                                irmp_param.protocol     = IRMP_JVC_PROTOCOL;                        // switch protocol
 800086e:	6018      	str	r0, [r3, #0]
                                irmp_param.stop_bit     = TRUE;                                     // set flag
 8000870:	6399      	str	r1, [r3, #56]	; 0x38
                                irmp_tmp_command        = (irmp_tmp_address >> 4);                  // set command: upper 12 bits are command bits
 8000872:	6813      	ldr	r3, [r2, #0]
 8000874:	4881      	ldr	r0, [pc, #516]	; (8000a7c <irmp_ISR+0x660>)
 8000876:	091c      	lsrs	r4, r3, #4
 8000878:	6004      	str	r4, [r0, #0]
                                irmp_tmp_address        = irmp_tmp_address & 0x000F;                // lower 4 bits are address bits
 800087a:	200f      	movs	r0, #15
 800087c:	4003      	ands	r3, r0
 800087e:	6013      	str	r3, [r2, #0]
                                irmp_start_bit_detected = 1;                                        // tricky: don't wait for another start bit...
 8000880:	4b78      	ldr	r3, [pc, #480]	; (8000a64 <irmp_ISR+0x648>)
 8000882:	6019      	str	r1, [r3, #0]
 8000884:	e614      	b.n	80004b0 <irmp_ISR+0x94>
                                    irmp_store_bit (0);
 8000886:	2000      	movs	r0, #0
 8000888:	f7ff fcea 	bl	8000260 <irmp_store_bit>
                                    last_value = 0;
 800088c:	2300      	movs	r3, #0
 800088e:	e7b0      	b.n	80007f2 <irmp_ISR+0x3d6>
                                irmp_store_bit ((irmp_param.flags & IRMP_PARAM_FLAG_1ST_PULSE_IS_1) ? 0  :  1 );
 8000890:	4663      	mov	r3, ip
 8000892:	2001      	movs	r0, #1
 8000894:	085b      	lsrs	r3, r3, #1
 8000896:	4398      	bics	r0, r3
 8000898:	9301      	str	r3, [sp, #4]
 800089a:	f7ff fce1 	bl	8000260 <irmp_store_bit>
                                if (irmp_param.protocol == IRMP_RC6_PROTOCOL && irmp_bit == 4 && irmp_pulse_time > RC6_TOGGLE_BIT_LEN_MIN)      // RC6 toggle bit
 800089e:	9b00      	ldr	r3, [sp, #0]
 80008a0:	4f72      	ldr	r7, [pc, #456]	; (8000a6c <irmp_ISR+0x650>)
 80008a2:	2b09      	cmp	r3, #9
 80008a4:	d112      	bne.n	80008cc <irmp_ISR+0x4b0>
 80008a6:	4b70      	ldr	r3, [pc, #448]	; (8000a68 <irmp_ISR+0x64c>)
 80008a8:	681b      	ldr	r3, [r3, #0]
 80008aa:	2b04      	cmp	r3, #4
 80008ac:	d10e      	bne.n	80008cc <irmp_ISR+0x4b0>
 80008ae:	2d09      	cmp	r5, #9
 80008b0:	d90c      	bls.n	80008cc <irmp_ISR+0x4b0>
                                    irmp_store_bit (1);
 80008b2:	2001      	movs	r0, #1
 80008b4:	7835      	ldrb	r5, [r6, #0]
 80008b6:	f7ff fcd3 	bl	8000260 <irmp_store_bit>
                                    if (irmp_pause_time > 2 * irmp_param.pause_1_len_max)
 80008ba:	6923      	ldr	r3, [r4, #16]
 80008bc:	005b      	lsls	r3, r3, #1
 80008be:	429d      	cmp	r5, r3
 80008c0:	d902      	bls.n	80008c8 <irmp_ISR+0x4ac>
                                        last_value = 0;
 80008c2:	2300      	movs	r3, #0
                                        last_value = 1;
 80008c4:	603b      	str	r3, [r7, #0]
 80008c6:	e795      	b.n	80007f4 <irmp_ISR+0x3d8>
 80008c8:	2301      	movs	r3, #1
 80008ca:	e7fb      	b.n	80008c4 <irmp_ISR+0x4a8>
                                    irmp_store_bit ((irmp_param.flags & IRMP_PARAM_FLAG_1ST_PULSE_IS_1) ? 1 :   0 );
 80008cc:	2401      	movs	r4, #1
 80008ce:	9b01      	ldr	r3, [sp, #4]
 80008d0:	4023      	ands	r3, r4
 80008d2:	001c      	movs	r4, r3
 80008d4:	0018      	movs	r0, r3
 80008d6:	f7ff fcc3 	bl	8000260 <irmp_store_bit>
                                    last_value = (irmp_param.flags & IRMP_PARAM_FLAG_1ST_PULSE_IS_1) ? 1 : 0;
 80008da:	603c      	str	r4, [r7, #0]
 80008dc:	e78a      	b.n	80007f4 <irmp_ISR+0x3d8>
                        else if (irmp_pulse_time >= irmp_param.pulse_1_len_min && irmp_pulse_time <= irmp_param.pulse_1_len_max
 80008de:	6863      	ldr	r3, [r4, #4]
 80008e0:	42ab      	cmp	r3, r5
 80008e2:	d824      	bhi.n	800092e <irmp_ISR+0x512>
                            if (last_pause > irmp_param.pause_1_len_max && last_pause <= 2 * irmp_param.pause_1_len_max)
 80008e4:	4b62      	ldr	r3, [pc, #392]	; (8000a70 <irmp_ISR+0x654>)
 80008e6:	4a61      	ldr	r2, [pc, #388]	; (8000a6c <irmp_ISR+0x650>)
 80008e8:	7819      	ldrb	r1, [r3, #0]
 80008ea:	6923      	ldr	r3, [r4, #16]
 80008ec:	6810      	ldr	r0, [r2, #0]
 80008ee:	4299      	cmp	r1, r3
 80008f0:	d905      	bls.n	80008fe <irmp_ISR+0x4e2>
 80008f2:	005b      	lsls	r3, r3, #1
 80008f4:	4299      	cmp	r1, r3
 80008f6:	d802      	bhi.n	80008fe <irmp_ISR+0x4e2>
                                manchester_value = last_value ? 0 : 1;
 80008f8:	4243      	negs	r3, r0
 80008fa:	4158      	adcs	r0, r3
                                last_value  = manchester_value;
 80008fc:	6010      	str	r0, [r2, #0]
                            if (irmp_param.protocol == IRMP_RC6_PROTOCOL && irmp_bit == 1 && manchester_value == 1)     // RC6 mode != 0 ???
 80008fe:	6823      	ldr	r3, [r4, #0]
 8000900:	2b09      	cmp	r3, #9
 8000902:	d111      	bne.n	8000928 <irmp_ISR+0x50c>
 8000904:	4b58      	ldr	r3, [pc, #352]	; (8000a68 <irmp_ISR+0x64c>)
 8000906:	681b      	ldr	r3, [r3, #0]
 8000908:	2b01      	cmp	r3, #1
 800090a:	d10d      	bne.n	8000928 <irmp_ISR+0x50c>
 800090c:	2801      	cmp	r0, #1
 800090e:	d10b      	bne.n	8000928 <irmp_ISR+0x50c>
                                irmp_param.address_offset = 5;
 8000910:	2205      	movs	r2, #5
 8000912:	6262      	str	r2, [r4, #36]	; 0x24
                                irmp_param.address_end = irmp_param.address_offset + 15;
 8000914:	320f      	adds	r2, #15
 8000916:	62a2      	str	r2, [r4, #40]	; 0x28
                                irmp_param.command_offset = irmp_param.address_end + 1;                                 // skip 1 system bit, changes like a toggle bit
 8000918:	3201      	adds	r2, #1
 800091a:	62e2      	str	r2, [r4, #44]	; 0x2c
                                irmp_tmp_address = 0;
 800091c:	2200      	movs	r2, #0
                                irmp_param.complete_len = RC6_COMPLETE_DATA_LEN_LONG;
 800091e:	3323      	adds	r3, #35	; 0x23
 8000920:	6363      	str	r3, [r4, #52]	; 0x34
                                irmp_param.command_end = irmp_param.command_offset + 16 - 1;
 8000922:	6323      	str	r3, [r4, #48]	; 0x30
                                irmp_tmp_address = 0;
 8000924:	4b4d      	ldr	r3, [pc, #308]	; (8000a5c <irmp_ISR+0x640>)
 8000926:	601a      	str	r2, [r3, #0]
                            irmp_store_bit (manchester_value);
 8000928:	f7ff fc9a 	bl	8000260 <irmp_store_bit>
                        {
 800092c:	e762      	b.n	80007f4 <irmp_ISR+0x3d8>
                                irmp_start_bit_detected = 0;                            // reset flags and wait for next start bit
 800092e:	2300      	movs	r3, #0
 8000930:	6013      	str	r3, [r2, #0]
                                irmp_pause_time         = 0;
 8000932:	7033      	strb	r3, [r6, #0]
 8000934:	e75e      	b.n	80007f4 <irmp_ISR+0x3d8>
                    if (irmp_param.protocol == IRMP_SAMSUNG_PROTOCOL && irmp_bit == 16)       // Samsung: 16th bit
 8000936:	6823      	ldr	r3, [r4, #0]
 8000938:	2b03      	cmp	r3, #3
 800093a:	d123      	bne.n	8000984 <irmp_ISR+0x568>
 800093c:	484a      	ldr	r0, [pc, #296]	; (8000a68 <irmp_ISR+0x64c>)
 800093e:	6801      	ldr	r1, [r0, #0]
 8000940:	2910      	cmp	r1, #16
 8000942:	d11f      	bne.n	8000984 <irmp_ISR+0x568>
                        if (irmp_pulse_time >= SAMSUNG_PULSE_LEN_MIN && irmp_pulse_time <= SAMSUNG_PULSE_LEN_MAX &&
 8000944:	3d04      	subs	r5, #4
 8000946:	2d06      	cmp	r5, #6
 8000948:	d818      	bhi.n	800097c <irmp_ISR+0x560>
                            irmp_pause_time >= SAMSUNG_START_BIT_PAUSE_LEN_MIN && irmp_pause_time <= SAMSUNG_START_BIT_PAUSE_LEN_MAX)
 800094a:	7833      	ldrb	r3, [r6, #0]
                        if (irmp_pulse_time >= SAMSUNG_PULSE_LEN_MIN && irmp_pulse_time <= SAMSUNG_PULSE_LEN_MAX &&
 800094c:	001a      	movs	r2, r3
 800094e:	3a32      	subs	r2, #50	; 0x32
 8000950:	2a0d      	cmp	r2, #13
 8000952:	d806      	bhi.n	8000962 <irmp_ISR+0x546>
                            wait_for_space = 0;
 8000954:	4b47      	ldr	r3, [pc, #284]	; (8000a74 <irmp_ISR+0x658>)
 8000956:	601f      	str	r7, [r3, #0]
                            irmp_bit++;
 8000958:	2311      	movs	r3, #17
 800095a:	6003      	str	r3, [r0, #0]
                    irmp_pulse_time = 1;                                            // set counter to 1, not 0
 800095c:	2301      	movs	r3, #1
 800095e:	4a40      	ldr	r2, [pc, #256]	; (8000a60 <irmp_ISR+0x644>)
 8000960:	e652      	b.n	8000608 <irmp_ISR+0x1ec>
                            irmp_param.protocol         = IRMP_SAMSUNG32_PROTOCOL;
 8000962:	220a      	movs	r2, #10
                            if (irmp_pause_time >= SAMSUNG_1_PAUSE_LEN_MIN && irmp_pause_time <= SAMSUNG_1_PAUSE_LEN_MAX)
 8000964:	3b0c      	subs	r3, #12
                            irmp_param.protocol         = IRMP_SAMSUNG32_PROTOCOL;
 8000966:	6022      	str	r2, [r4, #0]
                            irmp_param.command_end      = SAMSUNG32_COMMAND_OFFSET + SAMSUNG32_COMMAND_LEN;
 8000968:	3216      	adds	r2, #22
                            irmp_param.command_offset   = SAMSUNG32_COMMAND_OFFSET;
 800096a:	62e1      	str	r1, [r4, #44]	; 0x2c
                            irmp_param.command_end      = SAMSUNG32_COMMAND_OFFSET + SAMSUNG32_COMMAND_LEN;
 800096c:	6322      	str	r2, [r4, #48]	; 0x30
                            irmp_param.complete_len     = SAMSUNG32_COMPLETE_DATA_LEN;
 800096e:	6362      	str	r2, [r4, #52]	; 0x34
                            if (irmp_pause_time >= SAMSUNG_1_PAUSE_LEN_MIN && irmp_pause_time <= SAMSUNG_1_PAUSE_LEN_MAX)
 8000970:	2b0d      	cmp	r3, #13
 8000972:	d821      	bhi.n	80009b8 <irmp_ISR+0x59c>
                                irmp_store_bit (1);
 8000974:	2001      	movs	r0, #1
 8000976:	f7ff fc73 	bl	8000260 <irmp_store_bit>
 800097a:	e73e      	b.n	80007fa <irmp_ISR+0x3de>
                            irmp_start_bit_detected = 0;                            // reset flags and wait for next start bit
 800097c:	2300      	movs	r3, #0
 800097e:	6013      	str	r3, [r2, #0]
                            irmp_pause_time         = 0;
 8000980:	7033      	strb	r3, [r6, #0]
 8000982:	e7eb      	b.n	800095c <irmp_ISR+0x540>
                    if (irmp_pulse_time >= irmp_param.pulse_1_len_min && irmp_pulse_time <= irmp_param.pulse_1_len_max &&
 8000984:	6863      	ldr	r3, [r4, #4]
 8000986:	42ab      	cmp	r3, r5
 8000988:	d809      	bhi.n	800099e <irmp_ISR+0x582>
 800098a:	68a3      	ldr	r3, [r4, #8]
 800098c:	42ab      	cmp	r3, r5
 800098e:	d306      	bcc.n	800099e <irmp_ISR+0x582>
                        irmp_pause_time >= irmp_param.pause_1_len_min && irmp_pause_time <= irmp_param.pause_1_len_max)
 8000990:	7833      	ldrb	r3, [r6, #0]
                    if (irmp_pulse_time >= irmp_param.pulse_1_len_min && irmp_pulse_time <= irmp_param.pulse_1_len_max &&
 8000992:	68e1      	ldr	r1, [r4, #12]
 8000994:	428b      	cmp	r3, r1
 8000996:	d302      	bcc.n	800099e <irmp_ISR+0x582>
                        irmp_pause_time >= irmp_param.pause_1_len_min && irmp_pause_time <= irmp_param.pause_1_len_max)
 8000998:	6921      	ldr	r1, [r4, #16]
 800099a:	428b      	cmp	r3, r1
 800099c:	d9ea      	bls.n	8000974 <irmp_ISR+0x558>
                    else if (irmp_pulse_time >= irmp_param.pulse_0_len_min && irmp_pulse_time <= irmp_param.pulse_0_len_max &&
 800099e:	6963      	ldr	r3, [r4, #20]
 80009a0:	42ab      	cmp	r3, r5
 80009a2:	d8eb      	bhi.n	800097c <irmp_ISR+0x560>
 80009a4:	69a3      	ldr	r3, [r4, #24]
 80009a6:	42ab      	cmp	r3, r5
 80009a8:	d3e8      	bcc.n	800097c <irmp_ISR+0x560>
                             irmp_pause_time >= irmp_param.pause_0_len_min && irmp_pause_time <= irmp_param.pause_0_len_max)
 80009aa:	7833      	ldrb	r3, [r6, #0]
                    else if (irmp_pulse_time >= irmp_param.pulse_0_len_min && irmp_pulse_time <= irmp_param.pulse_0_len_max &&
 80009ac:	69e1      	ldr	r1, [r4, #28]
 80009ae:	428b      	cmp	r3, r1
 80009b0:	d3e4      	bcc.n	800097c <irmp_ISR+0x560>
                             irmp_pause_time >= irmp_param.pause_0_len_min && irmp_pause_time <= irmp_param.pause_0_len_max)
 80009b2:	6a21      	ldr	r1, [r4, #32]
 80009b4:	428b      	cmp	r3, r1
 80009b6:	d8e1      	bhi.n	800097c <irmp_ISR+0x560>
                                irmp_store_bit (0);
 80009b8:	2000      	movs	r0, #0
 80009ba:	e7dc      	b.n	8000976 <irmp_ISR+0x55a>
                if (! irmp_input)                                                   // still light?
 80009bc:	2800      	cmp	r0, #0
 80009be:	d103      	bne.n	80009c8 <irmp_ISR+0x5ac>
                    irmp_pulse_time++;                                              // increment counter
 80009c0:	4a27      	ldr	r2, [pc, #156]	; (8000a60 <irmp_ISR+0x644>)
 80009c2:	6813      	ldr	r3, [r2, #0]
 80009c4:	3301      	adds	r3, #1
 80009c6:	e61f      	b.n	8000608 <irmp_ISR+0x1ec>
                    wait_for_space  = 1;                                            // let's count the time (see above)
 80009c8:	2301      	movs	r3, #1
 80009ca:	e741      	b.n	8000850 <irmp_ISR+0x434>
                    repetition_frame_number = 0;
 80009cc:	2600      	movs	r6, #0
 80009ce:	e58c      	b.n	80004ea <irmp_ISR+0xce>
                    irmp_ir_detected = TRUE;
 80009d0:	2001      	movs	r0, #1
 80009d2:	4e29      	ldr	r6, [pc, #164]	; (8000a78 <irmp_ISR+0x65c>)
 80009d4:	6030      	str	r0, [r6, #0]
                        if (irmp_param.protocol == IRMP_NEC_PROTOCOL && irmp_bit == 0)  // repetition frame
 80009d6:	2a02      	cmp	r2, #2
 80009d8:	d117      	bne.n	8000a0a <irmp_ISR+0x5ee>
 80009da:	2b00      	cmp	r3, #0
 80009dc:	d10f      	bne.n	80009fe <irmp_ISR+0x5e2>
                            if (key_repetition_len < NEC_FRAME_REPEAT_PAUSE_LEN_MAX)
 80009de:	4c28      	ldr	r4, [pc, #160]	; (8000a80 <irmp_ISR+0x664>)
 80009e0:	4e28      	ldr	r6, [pc, #160]	; (8000a84 <irmp_ISR+0x668>)
 80009e2:	6827      	ldr	r7, [r4, #0]
 80009e4:	42b7      	cmp	r7, r6
 80009e6:	d80d      	bhi.n	8000a04 <irmp_ISR+0x5e8>
                                irmp_tmp_address = last_irmp_address;                   // address is last address
 80009e8:	4e27      	ldr	r6, [pc, #156]	; (8000a88 <irmp_ISR+0x66c>)
                                key_repetition_len = 0;
 80009ea:	6023      	str	r3, [r4, #0]
                                irmp_tmp_address = last_irmp_address;                   // address is last address
 80009ec:	6837      	ldr	r7, [r6, #0]
 80009ee:	4e1b      	ldr	r6, [pc, #108]	; (8000a5c <irmp_ISR+0x640>)
 80009f0:	6037      	str	r7, [r6, #0]
                                irmp_tmp_command = last_irmp_command;                   // command is last command
 80009f2:	4e22      	ldr	r6, [pc, #136]	; (8000a7c <irmp_ISR+0x660>)
 80009f4:	6035      	str	r5, [r6, #0]
                                irmp_flags |= IRMP_FLAG_REPETITION;
 80009f6:	4d25      	ldr	r5, [pc, #148]	; (8000a8c <irmp_ISR+0x670>)
 80009f8:	682e      	ldr	r6, [r5, #0]
 80009fa:	4330      	orrs	r0, r6
 80009fc:	6028      	str	r0, [r5, #0]
                            irmp_protocol = irmp_param.protocol;
 80009fe:	4b24      	ldr	r3, [pc, #144]	; (8000a90 <irmp_ISR+0x674>)
 8000a00:	601a      	str	r2, [r3, #0]
 8000a02:	e052      	b.n	8000aaa <irmp_ISR+0x68e>
                                irmp_ir_detected = FALSE;
 8000a04:	481c      	ldr	r0, [pc, #112]	; (8000a78 <irmp_ISR+0x65c>)
                            irmp_flags |= genre2;       // write the genre2 bits into MSB of the flag byte
 8000a06:	6003      	str	r3, [r0, #0]
 8000a08:	e7f9      	b.n	80009fe <irmp_ISR+0x5e2>
                        if (irmp_param.protocol == IRMP_KASEIKYO_PROTOCOL)
 8000a0a:	2a05      	cmp	r2, #5
 8000a0c:	d146      	bne.n	8000a9c <irmp_ISR+0x680>
                            if (xor_value != (xor_check[2] & 0x0F))
 8000a0e:	250f      	movs	r5, #15
                            xor_value = (xor_check[0] & 0x0F) ^ ((xor_check[0] & 0xF0) >> 4) ^ (xor_check[1] & 0x0F) ^ ((xor_check[1] & 0xF0) >> 4);
 8000a10:	4c20      	ldr	r4, [pc, #128]	; (8000a94 <irmp_ISR+0x678>)
 8000a12:	7827      	ldrb	r7, [r4, #0]
 8000a14:	7866      	ldrb	r6, [r4, #1]
 8000a16:	093b      	lsrs	r3, r7, #4
                            if (xor_value != (xor_check[2] & 0x0F))
 8000a18:	402f      	ands	r7, r5
 8000a1a:	407b      	eors	r3, r7
 8000a1c:	0037      	movs	r7, r6
 8000a1e:	78a0      	ldrb	r0, [r4, #2]
 8000a20:	402f      	ands	r7, r5
 8000a22:	407b      	eors	r3, r7
                            xor_value = (xor_check[0] & 0x0F) ^ ((xor_check[0] & 0xF0) >> 4) ^ (xor_check[1] & 0x0F) ^ ((xor_check[1] & 0xF0) >> 4);
 8000a24:	0936      	lsrs	r6, r6, #4
                            if (xor_value != (xor_check[2] & 0x0F))
 8000a26:	4073      	eors	r3, r6
 8000a28:	4005      	ands	r5, r0
 8000a2a:	42ab      	cmp	r3, r5
 8000a2c:	d002      	beq.n	8000a34 <irmp_ISR+0x618>
                                irmp_ir_detected = FALSE;
 8000a2e:	2300      	movs	r3, #0
 8000a30:	4d11      	ldr	r5, [pc, #68]	; (8000a78 <irmp_ISR+0x65c>)
 8000a32:	602b      	str	r3, [r5, #0]
                            xor_value = xor_check[2] ^ xor_check[3] ^ xor_check[4];
 8000a34:	78e3      	ldrb	r3, [r4, #3]
 8000a36:	7925      	ldrb	r5, [r4, #4]
 8000a38:	4058      	eors	r0, r3
                            if (xor_value != xor_check[5])
 8000a3a:	7963      	ldrb	r3, [r4, #5]
 8000a3c:	4068      	eors	r0, r5
 8000a3e:	4283      	cmp	r3, r0
 8000a40:	d002      	beq.n	8000a48 <irmp_ISR+0x62c>
                                irmp_ir_detected = FALSE;
 8000a42:	2300      	movs	r3, #0
 8000a44:	480c      	ldr	r0, [pc, #48]	; (8000a78 <irmp_ISR+0x65c>)
 8000a46:	6003      	str	r3, [r0, #0]
                            irmp_flags |= genre2;       // write the genre2 bits into MSB of the flag byte
 8000a48:	4810      	ldr	r0, [pc, #64]	; (8000a8c <irmp_ISR+0x670>)
 8000a4a:	4c13      	ldr	r4, [pc, #76]	; (8000a98 <irmp_ISR+0x67c>)
 8000a4c:	6803      	ldr	r3, [r0, #0]
 8000a4e:	6824      	ldr	r4, [r4, #0]
 8000a50:	4323      	orrs	r3, r4
 8000a52:	e7d8      	b.n	8000a06 <irmp_ISR+0x5ea>
 8000a54:	200000ac 	.word	0x200000ac
 8000a58:	20000068 	.word	0x20000068
 8000a5c:	200000bc 	.word	0x200000bc
 8000a60:	200000b4 	.word	0x200000b4
 8000a64:	200000b8 	.word	0x200000b8
 8000a68:	20000054 	.word	0x20000054
 8000a6c:	200000d0 	.word	0x200000d0
 8000a70:	200000cc 	.word	0x200000cc
 8000a74:	200000dc 	.word	0x200000dc
 8000a78:	20000064 	.word	0x20000064
 8000a7c:	200000c0 	.word	0x200000c0
 8000a80:	200000c8 	.word	0x200000c8
 8000a84:	000005db 	.word	0x000005db
 8000a88:	20000000 	.word	0x20000000
 8000a8c:	2000005c 	.word	0x2000005c
 8000a90:	200000b0 	.word	0x200000b0
 8000a94:	200000e4 	.word	0x200000e4
 8000a98:	2000004c 	.word	0x2000004c
                        if (irmp_param.protocol == IRMP_RC6_PROTOCOL && irmp_param.complete_len == RC6_COMPLETE_DATA_LEN_LONG)     // RC6 mode = 6?
 8000a9c:	2a09      	cmp	r2, #9
 8000a9e:	d1ae      	bne.n	80009fe <irmp_ISR+0x5e2>
 8000aa0:	2c24      	cmp	r4, #36	; 0x24
 8000aa2:	d1ac      	bne.n	80009fe <irmp_ISR+0x5e2>
                            irmp_protocol = IRMP_RC6A_PROTOCOL;
 8000aa4:	2015      	movs	r0, #21
 8000aa6:	4b1b      	ldr	r3, [pc, #108]	; (8000b14 <irmp_ISR+0x6f8>)
 8000aa8:	6018      	str	r0, [r3, #0]
                        irmp_address = irmp_tmp_address;                            // store address
 8000aaa:	4b1b      	ldr	r3, [pc, #108]	; (8000b18 <irmp_ISR+0x6fc>)
 8000aac:	6818      	ldr	r0, [r3, #0]
 8000aae:	4b1b      	ldr	r3, [pc, #108]	; (8000b1c <irmp_ISR+0x700>)
 8000ab0:	6018      	str	r0, [r3, #0]
 8000ab2:	4b1b      	ldr	r3, [pc, #108]	; (8000b20 <irmp_ISR+0x704>)
                        if (irmp_param.protocol == IRMP_NEC_PROTOCOL)
 8000ab4:	2a02      	cmp	r2, #2
 8000ab6:	d108      	bne.n	8000aca <irmp_ISR+0x6ae>
                            last_irmp_address = irmp_tmp_address;                   // store as last address, too
 8000ab8:	4a1a      	ldr	r2, [pc, #104]	; (8000b24 <irmp_ISR+0x708>)
 8000aba:	6010      	str	r0, [r2, #0]
                        irmp_command = irmp_tmp_command;                            // store command
 8000abc:	681a      	ldr	r2, [r3, #0]
 8000abe:	4b1a      	ldr	r3, [pc, #104]	; (8000b28 <irmp_ISR+0x70c>)
 8000ac0:	601a      	str	r2, [r3, #0]
                        irmp_id = irmp_tmp_id;
 8000ac2:	4b1a      	ldr	r3, [pc, #104]	; (8000b2c <irmp_ISR+0x710>)
 8000ac4:	681a      	ldr	r2, [r3, #0]
 8000ac6:	4b1a      	ldr	r3, [pc, #104]	; (8000b30 <irmp_ISR+0x714>)
 8000ac8:	e51b      	b.n	8000502 <irmp_ISR+0xe6>
                        if (irmp_param.protocol == IRMP_RC5_PROTOCOL)
 8000aca:	2a07      	cmp	r2, #7
 8000acc:	d1f6      	bne.n	8000abc <irmp_ISR+0x6a0>
                            irmp_tmp_command |= rc5_cmd_bit6;                       // store bit 6
 8000ace:	4a19      	ldr	r2, [pc, #100]	; (8000b34 <irmp_ISR+0x718>)
 8000ad0:	6818      	ldr	r0, [r3, #0]
 8000ad2:	6812      	ldr	r2, [r2, #0]
 8000ad4:	4302      	orrs	r2, r0
 8000ad6:	601a      	str	r2, [r3, #0]
 8000ad8:	e7f0      	b.n	8000abc <irmp_ISR+0x6a0>
                            else if ((irmp_param.protocol == IRMP_NEC_PROTOCOL || irmp_param.protocol == IRMP_NEC42_PROTOCOL) && irmp_bit == 0)
 8000ada:	2a00      	cmp	r2, #0
 8000adc:	d000      	beq.n	8000ae0 <irmp_ISR+0x6c4>
 8000ade:	e6be      	b.n	800085e <irmp_ISR+0x442>
                                if (key_repetition_len < NEC_FRAME_REPEAT_PAUSE_LEN_MAX)
 8000ae0:	4915      	ldr	r1, [pc, #84]	; (8000b38 <irmp_ISR+0x71c>)
 8000ae2:	4a16      	ldr	r2, [pc, #88]	; (8000b3c <irmp_ISR+0x720>)
 8000ae4:	6808      	ldr	r0, [r1, #0]
 8000ae6:	4290      	cmp	r0, r2
 8000ae8:	d900      	bls.n	8000aec <irmp_ISR+0x6d0>
 8000aea:	e6b5      	b.n	8000858 <irmp_ISR+0x43c>
                                    irmp_param.protocol     = IRMP_NEC_PROTOCOL;            // switch protocol
 8000aec:	2002      	movs	r0, #2
                                    irmp_param.stop_bit     = TRUE;                         // set flag
 8000aee:	2201      	movs	r2, #1
                                    irmp_param.protocol     = IRMP_NEC_PROTOCOL;            // switch protocol
 8000af0:	6018      	str	r0, [r3, #0]
                                    irmp_param.complete_len = irmp_bit;                     // patch length: 16 or 17
 8000af2:	2000      	movs	r0, #0
                                    irmp_param.stop_bit     = TRUE;                         // set flag
 8000af4:	639a      	str	r2, [r3, #56]	; 0x38
                                    irmp_param.complete_len = irmp_bit;                     // patch length: 16 or 17
 8000af6:	6358      	str	r0, [r3, #52]	; 0x34
                                    irmp_tmp_address = last_irmp_address;                   // address is last address
 8000af8:	4b0a      	ldr	r3, [pc, #40]	; (8000b24 <irmp_ISR+0x708>)
                                    key_repetition_len = 0;
 8000afa:	6008      	str	r0, [r1, #0]
                                    irmp_tmp_address = last_irmp_address;                   // address is last address
 8000afc:	681c      	ldr	r4, [r3, #0]
 8000afe:	4b06      	ldr	r3, [pc, #24]	; (8000b18 <irmp_ISR+0x6fc>)
 8000b00:	601c      	str	r4, [r3, #0]
                                    irmp_tmp_command = last_irmp_command;                   // command is last command
 8000b02:	4b0f      	ldr	r3, [pc, #60]	; (8000b40 <irmp_ISR+0x724>)
 8000b04:	681c      	ldr	r4, [r3, #0]
 8000b06:	4b06      	ldr	r3, [pc, #24]	; (8000b20 <irmp_ISR+0x704>)
 8000b08:	601c      	str	r4, [r3, #0]
                                    irmp_flags |= IRMP_FLAG_REPETITION;
 8000b0a:	4b0e      	ldr	r3, [pc, #56]	; (8000b44 <irmp_ISR+0x728>)
 8000b0c:	681c      	ldr	r4, [r3, #0]
 8000b0e:	4322      	orrs	r2, r4
 8000b10:	601a      	str	r2, [r3, #0]
 8000b12:	e4cd      	b.n	80004b0 <irmp_ISR+0x94>
 8000b14:	200000b0 	.word	0x200000b0
 8000b18:	200000bc 	.word	0x200000bc
 8000b1c:	20000050 	.word	0x20000050
 8000b20:	200000c0 	.word	0x200000c0
 8000b24:	20000000 	.word	0x20000000
 8000b28:	20000058 	.word	0x20000058
 8000b2c:	200000c4 	.word	0x200000c4
 8000b30:	20000060 	.word	0x20000060
 8000b34:	200000d4 	.word	0x200000d4
 8000b38:	200000c8 	.word	0x200000c8
 8000b3c:	000005db 	.word	0x000005db
 8000b40:	20000004 	.word	0x20000004
 8000b44:	2000005c 	.word	0x2000005c

08000b48 <WS2812_ChangeColor>:
}

/*** Controls all LEDs at once ***/

static void WS2812_ChangeColor(ws28xx_Color_TypeDef Color)
{
 8000b48:	b510      	push	{r4, lr}
 8000b4a:	0004      	movs	r4, r0
	  ws28xx_SetColor(0, Color);
 8000b4c:	0001      	movs	r1, r0
 8000b4e:	2000      	movs	r0, #0
 8000b50:	f000 fe44 	bl	80017dc <ws28xx_SetColor>
	  ws28xx_SetColor(1, Color);
 8000b54:	0021      	movs	r1, r4
 8000b56:	2001      	movs	r0, #1
 8000b58:	f000 fe40 	bl	80017dc <ws28xx_SetColor>
	  ws28xx_SetColor(2, Color);
 8000b5c:	0021      	movs	r1, r4
 8000b5e:	2002      	movs	r0, #2
 8000b60:	f000 fe3c 	bl	80017dc <ws28xx_SetColor>
	  ws28xx_SetColor(3, Color);
 8000b64:	0021      	movs	r1, r4
 8000b66:	2003      	movs	r0, #3
 8000b68:	f000 fe38 	bl	80017dc <ws28xx_SetColor>
	  ws28xx_Update();
 8000b6c:	f000 fe2e 	bl	80017cc <ws28xx_Update>
}
 8000b70:	bd10      	pop	{r4, pc}

08000b72 <SystemClock_Config>:
{
 8000b72:	b530      	push	{r4, r5, lr}
  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
 8000b74:	2410      	movs	r4, #16
{
 8000b76:	b095      	sub	sp, #84	; 0x54
  RCC_OscInitTypeDef RCC_OscInitStruct = {0};
 8000b78:	222c      	movs	r2, #44	; 0x2c
 8000b7a:	2100      	movs	r1, #0
 8000b7c:	a809      	add	r0, sp, #36	; 0x24
 8000b7e:	f002 fe5e 	bl	800383e <memset>
  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
 8000b82:	0022      	movs	r2, r4
 8000b84:	2100      	movs	r1, #0
 8000b86:	4668      	mov	r0, sp
 8000b88:	f002 fe59 	bl	800383e <memset>
  RCC_PeriphCLKInitTypeDef PeriphClkInit = {0};
 8000b8c:	0022      	movs	r2, r4
 8000b8e:	2100      	movs	r1, #0
 8000b90:	a804      	add	r0, sp, #16
 8000b92:	f002 fe54 	bl	800383e <memset>
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI|RCC_OSCILLATORTYPE_HSI14;
 8000b96:	2312      	movs	r3, #18
 8000b98:	9308      	str	r3, [sp, #32]
  RCC_OscInitStruct.PLL.PLLMUL = RCC_PLL_MUL5;
 8000b9a:	23c0      	movs	r3, #192	; 0xc0
  RCC_OscInitStruct.HSIState = RCC_HSI_ON;
 8000b9c:	2501      	movs	r5, #1
  RCC_OscInitStruct.HSICalibrationValue = RCC_HSICALIBRATION_DEFAULT;
 8000b9e:	940c      	str	r4, [sp, #48]	; 0x30
  RCC_OscInitStruct.HSI14CalibrationValue = 16;
 8000ba0:	940e      	str	r4, [sp, #56]	; 0x38
  RCC_OscInitStruct.PLL.PLLMUL = RCC_PLL_MUL5;
 8000ba2:	031b      	lsls	r3, r3, #12
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
 8000ba4:	3c0e      	subs	r4, #14
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
 8000ba6:	a808      	add	r0, sp, #32
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
 8000ba8:	9410      	str	r4, [sp, #64]	; 0x40
  RCC_OscInitStruct.PLL.PLLMUL = RCC_PLL_MUL5;
 8000baa:	9312      	str	r3, [sp, #72]	; 0x48
  RCC_OscInitStruct.HSIState = RCC_HSI_ON;
 8000bac:	950b      	str	r5, [sp, #44]	; 0x2c
  RCC_OscInitStruct.HSI14State = RCC_HSI14_ON;
 8000bae:	950d      	str	r5, [sp, #52]	; 0x34
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
 8000bb0:	f001 fb94 	bl	80022dc <HAL_RCC_OscConfig>
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
 8000bb4:	9401      	str	r4, [sp, #4]
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
 8000bb6:	2400      	movs	r4, #0
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
 8000bb8:	2307      	movs	r3, #7
  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_0) != HAL_OK)
 8000bba:	0021      	movs	r1, r4
 8000bbc:	4668      	mov	r0, sp
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
 8000bbe:	9300      	str	r3, [sp, #0]
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
 8000bc0:	9402      	str	r4, [sp, #8]
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
 8000bc2:	9403      	str	r4, [sp, #12]
  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_0) != HAL_OK)
 8000bc4:	f001 fdbe 	bl	8002744 <HAL_RCC_ClockConfig>
  if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInit) != HAL_OK)
 8000bc8:	a804      	add	r0, sp, #16
  PeriphClkInit.PeriphClockSelection = RCC_PERIPHCLK_USART1;
 8000bca:	9504      	str	r5, [sp, #16]
  PeriphClkInit.Usart1ClockSelection = RCC_USART1CLKSOURCE_PCLK1;
 8000bcc:	9406      	str	r4, [sp, #24]
  if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInit) != HAL_OK)
 8000bce:	f001 fe4d 	bl	800286c <HAL_RCCEx_PeriphCLKConfig>
}
 8000bd2:	b015      	add	sp, #84	; 0x54
 8000bd4:	bd30      	pop	{r4, r5, pc}

08000bd6 <RPi_Power_Up>:
	HAL_GPIO_WritePin(CTRL_VUSB_GPIO_Port, CTRL_VUSB_Pin, GPIO_PIN_SET);
 8000bd6:	2201      	movs	r2, #1
 8000bd8:	2090      	movs	r0, #144	; 0x90
{
 8000bda:	b510      	push	{r4, lr}
	HAL_GPIO_WritePin(CTRL_VUSB_GPIO_Port, CTRL_VUSB_Pin, GPIO_PIN_SET);
 8000bdc:	0011      	movs	r1, r2
 8000bde:	05c0      	lsls	r0, r0, #23
 8000be0:	f001 fb68 	bl	80022b4 <HAL_GPIO_WritePin>
}
 8000be4:	bd10      	pop	{r4, pc}

08000be6 <RPi_Power_Down>:
	HAL_GPIO_WritePin(CTRL_VUSB_GPIO_Port, CTRL_VUSB_Pin, GPIO_PIN_RESET);
 8000be6:	2090      	movs	r0, #144	; 0x90
{
 8000be8:	b510      	push	{r4, lr}
	HAL_GPIO_WritePin(CTRL_VUSB_GPIO_Port, CTRL_VUSB_Pin, GPIO_PIN_RESET);
 8000bea:	2200      	movs	r2, #0
 8000bec:	2101      	movs	r1, #1
 8000bee:	05c0      	lsls	r0, r0, #23
 8000bf0:	f001 fb60 	bl	80022b4 <HAL_GPIO_WritePin>
}
 8000bf4:	bd10      	pop	{r4, pc}

08000bf6 <RGB_RPi>:
{
 8000bf6:	b510      	push	{r4, lr}
	HAL_GPIO_WritePin(RGB_MCU_EN_GPIO_Port, RGB_MCU_EN_Pin, GPIO_PIN_SET);
 8000bf8:	2490      	movs	r4, #144	; 0x90
 8000bfa:	05e4      	lsls	r4, r4, #23
 8000bfc:	0020      	movs	r0, r4
 8000bfe:	2201      	movs	r2, #1
 8000c00:	2104      	movs	r1, #4
 8000c02:	f001 fb57 	bl	80022b4 <HAL_GPIO_WritePin>
	HAL_GPIO_WritePin(RGB_RPi_EN_GPIO_Port, RGB_RPi_EN_Pin, GPIO_PIN_RESET);
 8000c06:	2200      	movs	r2, #0
 8000c08:	2108      	movs	r1, #8
 8000c0a:	0020      	movs	r0, r4
 8000c0c:	f001 fb52 	bl	80022b4 <HAL_GPIO_WritePin>
}
 8000c10:	bd10      	pop	{r4, pc}

08000c12 <RGB_MCU>:
{
 8000c12:	b510      	push	{r4, lr}
	HAL_GPIO_WritePin(RGB_MCU_EN_GPIO_Port, RGB_MCU_EN_Pin, GPIO_PIN_RESET);
 8000c14:	2490      	movs	r4, #144	; 0x90
 8000c16:	05e4      	lsls	r4, r4, #23
 8000c18:	0020      	movs	r0, r4
 8000c1a:	2200      	movs	r2, #0
 8000c1c:	2104      	movs	r1, #4
 8000c1e:	f001 fb49 	bl	80022b4 <HAL_GPIO_WritePin>
	HAL_GPIO_WritePin(RGB_RPi_EN_GPIO_Port, RGB_RPi_EN_Pin, GPIO_PIN_SET);
 8000c22:	2201      	movs	r2, #1
 8000c24:	2108      	movs	r1, #8
 8000c26:	0020      	movs	r0, r4
 8000c28:	f001 fb44 	bl	80022b4 <HAL_GPIO_WritePin>
}
 8000c2c:	bd10      	pop	{r4, pc}

08000c2e <flashValue>:
	HAL_FLASH_Lock();

}

void flashValue(uint32_t address, uint32_t data)
{
 8000c2e:	b510      	push	{r4, lr}
 8000c30:	000a      	movs	r2, r1
	 if (HAL_FLASH_Program(FLASH_TYPEPROGRAM_WORD, address , data) != HAL_OK)
 8000c32:	2300      	movs	r3, #0
 8000c34:	0001      	movs	r1, r0
 8000c36:	2002      	movs	r0, #2
 8000c38:	f001 f9d6 	bl	8001fe8 <HAL_FLASH_Program>
	      User can add here some code to deal with this error.
	      PAGEError will contain the faulty page and then to know the code error on this page,
	      user can call function 'HAL_FLASH_GetError()'
	    */
	  }
}
 8000c3c:	bd10      	pop	{r4, pc}
	...

08000c40 <flashConfig>:
{
 8000c40:	b530      	push	{r4, r5, lr}
 8000c42:	b085      	sub	sp, #20
	HAL_FLASH_Unlock();
 8000c44:	f001 f988 	bl	8001f58 <HAL_FLASH_Unlock>
	EraseInitStruct.TypeErase   = FLASH_TYPEERASE_PAGES;
 8000c48:	2300      	movs	r3, #0
	EraseInitStruct.PageAddress = 0x8007C00;
 8000c4a:	4d12      	ldr	r5, [pc, #72]	; (8000c94 <flashConfig+0x54>)
	EraseInitStruct.TypeErase   = FLASH_TYPEERASE_PAGES;
 8000c4c:	9301      	str	r3, [sp, #4]
	 if (HAL_FLASHEx_Erase(&EraseInitStruct, &PAGEError) != HAL_OK)
 8000c4e:	4912      	ldr	r1, [pc, #72]	; (8000c98 <flashConfig+0x58>)
	EraseInitStruct.NbPages     = 1;
 8000c50:	3301      	adds	r3, #1
	 if (HAL_FLASHEx_Erase(&EraseInitStruct, &PAGEError) != HAL_OK)
 8000c52:	a801      	add	r0, sp, #4
	EraseInitStruct.NbPages     = 1;
 8000c54:	9303      	str	r3, [sp, #12]
	EraseInitStruct.PageAddress = 0x8007C00;
 8000c56:	9502      	str	r5, [sp, #8]
	 if (HAL_FLASHEx_Erase(&EraseInitStruct, &PAGEError) != HAL_OK)
 8000c58:	f001 fa2c 	bl	80020b4 <HAL_FLASHEx_Erase>
	  flashValue(irmp_protocol_FlashAdress,irmp_new_data.protocol);
 8000c5c:	4c0f      	ldr	r4, [pc, #60]	; (8000c9c <flashConfig+0x5c>)
 8000c5e:	0028      	movs	r0, r5
 8000c60:	7821      	ldrb	r1, [r4, #0]
 8000c62:	f7ff ffe4 	bl	8000c2e <flashValue>
	  flashValue(irmp_address_FlashAdress,irmp_new_data.address);
 8000c66:	78a1      	ldrb	r1, [r4, #2]
 8000c68:	7863      	ldrb	r3, [r4, #1]
 8000c6a:	0209      	lsls	r1, r1, #8
 8000c6c:	4319      	orrs	r1, r3
 8000c6e:	480c      	ldr	r0, [pc, #48]	; (8000ca0 <flashConfig+0x60>)
 8000c70:	f7ff ffdd 	bl	8000c2e <flashValue>
	  flashValue(irmp_command_FlashAdress,irmp_new_data.command);
 8000c74:	7921      	ldrb	r1, [r4, #4]
 8000c76:	78e3      	ldrb	r3, [r4, #3]
 8000c78:	0209      	lsls	r1, r1, #8
 8000c7a:	4319      	orrs	r1, r3
 8000c7c:	4809      	ldr	r0, [pc, #36]	; (8000ca4 <flashConfig+0x64>)
 8000c7e:	f7ff ffd6 	bl	8000c2e <flashValue>
	  flashValue(led_mode_FlashAdress,ledMode);
 8000c82:	4b09      	ldr	r3, [pc, #36]	; (8000ca8 <flashConfig+0x68>)
 8000c84:	4809      	ldr	r0, [pc, #36]	; (8000cac <flashConfig+0x6c>)
 8000c86:	7819      	ldrb	r1, [r3, #0]
 8000c88:	f7ff ffd1 	bl	8000c2e <flashValue>
	HAL_FLASH_Lock();
 8000c8c:	f001 f978 	bl	8001f80 <HAL_FLASH_Lock>
}
 8000c90:	b005      	add	sp, #20
 8000c92:	bd30      	pop	{r4, r5, pc}
 8000c94:	08007c00 	.word	0x08007c00
 8000c98:	200000ec 	.word	0x200000ec
 8000c9c:	20000102 	.word	0x20000102
 8000ca0:	08007c10 	.word	0x08007c10
 8000ca4:	08007c20 	.word	0x08007c20
 8000ca8:	200000f1 	.word	0x200000f1
 8000cac:	08007c30 	.word	0x08007c30

08000cb0 <learningmode>:

/*** Function for learning a new IR-remote ***/

void learningmode()
{
 8000cb0:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	  uint8_t learningMode_on;

	  learningMode_on = 0;
	  RGB_MCU();
 8000cb2:	f7ff ffae 	bl	8000c12 <RGB_MCU>
	  learningMode_on = 0;
 8000cb6:	2500      	movs	r5, #0

		  /*** fetching IR data ***/
		  if(irmp_get_data (&irmp_temp_data))
	  	  	{
			  /*** checking IR repetition ***/
			  if(!(irmp_temp_data.flags & IRMP_FLAG_REPETITION))
 8000cb8:	2701      	movs	r7, #1
		WS2812_ChangeColor(ws28xx_Color_Blue);
 8000cba:	2003      	movs	r0, #3
 8000cbc:	f7ff ff44 	bl	8000b48 <WS2812_ChangeColor>
		HAL_Delay(300);
 8000cc0:	2096      	movs	r0, #150	; 0x96
 8000cc2:	0040      	lsls	r0, r0, #1
 8000cc4:	f000 feac 	bl	8001a20 <HAL_Delay>
	  	WS2812_ChangeColor(ws28xx_Color_Orange);
 8000cc8:	2010      	movs	r0, #16
 8000cca:	f7ff ff3d 	bl	8000b48 <WS2812_ChangeColor>
		HAL_Delay(300);
 8000cce:	2096      	movs	r0, #150	; 0x96
 8000cd0:	0040      	lsls	r0, r0, #1
 8000cd2:	f000 fea5 	bl	8001a20 <HAL_Delay>
		  if(irmp_get_data (&irmp_temp_data))
 8000cd6:	4c41      	ldr	r4, [pc, #260]	; (8000ddc <learningmode+0x12c>)
 8000cd8:	0020      	movs	r0, r4
 8000cda:	f7ff fb25 	bl	8000328 <irmp_get_data>
 8000cde:	2800      	cmp	r0, #0
 8000ce0:	d030      	beq.n	8000d44 <learningmode+0x94>
			  if(!(irmp_temp_data.flags & IRMP_FLAG_REPETITION))
 8000ce2:	7966      	ldrb	r6, [r4, #5]
 8000ce4:	403e      	ands	r6, r7
 8000ce6:	d12d      	bne.n	8000d44 <learningmode+0x94>
			  {
	  		  	  WS2812_ChangeColor(ws28xx_Color_Black);
 8000ce8:	0030      	movs	r0, r6
 8000cea:	f7ff ff2d 	bl	8000b48 <WS2812_ChangeColor>
	  		  	  HAL_Delay(500);
 8000cee:	20fa      	movs	r0, #250	; 0xfa
 8000cf0:	0040      	lsls	r0, r0, #1
 8000cf2:	f000 fe95 	bl	8001a20 <HAL_Delay>
 8000cf6:	483a      	ldr	r0, [pc, #232]	; (8000de0 <learningmode+0x130>)
	  		  	  if (learningMode_on == 0)
 8000cf8:	2d00      	cmp	r5, #0
 8000cfa:	d133      	bne.n	8000d64 <learningmode+0xb4>
	  		  	  {
	  		  		  irmp_new_data = irmp_temp_data;
 8000cfc:	2206      	movs	r2, #6
 8000cfe:	0021      	movs	r1, r4
 8000d00:	f002 fd94 	bl	800382c <memcpy>
	  		  		  learningMode_on++;
	  		  		  WS2812_ChangeColor(ws28xx_Color_White);
 8000d04:	2013      	movs	r0, #19
 8000d06:	f7ff ff1f 	bl	8000b48 <WS2812_ChangeColor>

		  			  HAL_Delay(350);
 8000d0a:	20af      	movs	r0, #175	; 0xaf
 8000d0c:	0040      	lsls	r0, r0, #1
 8000d0e:	f000 fe87 	bl	8001a20 <HAL_Delay>
		  			  WS2812_ChangeColor(ws28xx_Color_Black);
 8000d12:	0028      	movs	r0, r5
 8000d14:	f7ff ff18 	bl	8000b48 <WS2812_ChangeColor>

		  			  HAL_Delay(350);
 8000d18:	20af      	movs	r0, #175	; 0xaf
 8000d1a:	0040      	lsls	r0, r0, #1
 8000d1c:	f000 fe80 	bl	8001a20 <HAL_Delay>
	  		  		  learningMode_on++;
 8000d20:	003d      	movs	r5, r7
	  		  			  HAL_Delay(350);
	  		  			  learningMode_on = 0;
	  		  		  }
	  		  	  }

	  		  	if (ledMode == 0)
 8000d22:	4b30      	ldr	r3, [pc, #192]	; (8000de4 <learningmode+0x134>)
	  		  	{
	  		  		WS2812_ChangeColor(ws28xx_Color_Green);
 8000d24:	2002      	movs	r0, #2
	  		  	if (ledMode == 0)
 8000d26:	781b      	ldrb	r3, [r3, #0]
 8000d28:	2b00      	cmp	r3, #0
 8000d2a:	d14e      	bne.n	8000dca <learningmode+0x11a>

	  		  	else
	  		  	{
	  		  	WS2812_ChangeColor(ws28xx_Color_Green);
	  		  	HAL_Delay(500);
	  		  	WS2812_ChangeColor(ws28xx_Color_Black);
 8000d2c:	f7ff ff0c 	bl	8000b48 <WS2812_ChangeColor>
	  		  	}

	  		  	irmp_data = irmp_temp_data;
 8000d30:	2206      	movs	r2, #6
 8000d32:	0021      	movs	r1, r4
 8000d34:	482c      	ldr	r0, [pc, #176]	; (8000de8 <learningmode+0x138>)
 8000d36:	f002 fd79 	bl	800382c <memcpy>
	  		  memset(&irmp_temp_data, 0, sizeof(IRMP_DATA));
 8000d3a:	2206      	movs	r2, #6
 8000d3c:	2100      	movs	r1, #0
 8000d3e:	0020      	movs	r0, r4
 8000d40:	f002 fd7d 	bl	800383e <memset>
	  while (learningMode_on < 3)
 8000d44:	2d03      	cmp	r5, #3
 8000d46:	d1b8      	bne.n	8000cba <learningmode+0xa>
	  	  	}
	  	  }
	  }
	flashConfig();
 8000d48:	f7ff ff7a 	bl	8000c40 <flashConfig>
	HAL_Delay(2000);
 8000d4c:	20fa      	movs	r0, #250	; 0xfa
 8000d4e:	00c0      	lsls	r0, r0, #3
 8000d50:	f000 fe66 	bl	8001a20 <HAL_Delay>
	RGB_RPi();
 8000d54:	f7ff ff4f 	bl	8000bf6 <RGB_RPi>
	memset(&irmp_temp_data, 0, sizeof(IRMP_DATA));
 8000d58:	2206      	movs	r2, #6
 8000d5a:	2100      	movs	r1, #0
 8000d5c:	0020      	movs	r0, r4
 8000d5e:	f002 fd6e 	bl	800383e <memset>
}
 8000d62:	bdf7      	pop	{r0, r1, r2, r4, r5, r6, r7, pc}
	  		  		  if (irmp_new_data.command == irmp_temp_data.command)
 8000d64:	78c3      	ldrb	r3, [r0, #3]
 8000d66:	7902      	ldrb	r2, [r0, #4]
 8000d68:	469c      	mov	ip, r3
 8000d6a:	7923      	ldrb	r3, [r4, #4]
 8000d6c:	78e1      	ldrb	r1, [r4, #3]
 8000d6e:	021b      	lsls	r3, r3, #8
 8000d70:	9301      	str	r3, [sp, #4]
 8000d72:	4663      	mov	r3, ip
 8000d74:	0212      	lsls	r2, r2, #8
 8000d76:	431a      	orrs	r2, r3
 8000d78:	9b01      	ldr	r3, [sp, #4]
 8000d7a:	430b      	orrs	r3, r1
 8000d7c:	429a      	cmp	r2, r3
 8000d7e:	d114      	bne.n	8000daa <learningmode+0xfa>
	  		  			irmp_new_data = irmp_temp_data;
 8000d80:	2206      	movs	r2, #6
 8000d82:	0021      	movs	r1, r4
 8000d84:	f002 fd52 	bl	800382c <memcpy>
	  		  			  WS2812_ChangeColor(ws28xx_Color_White);
 8000d88:	2013      	movs	r0, #19
 8000d8a:	f7ff fedd 	bl	8000b48 <WS2812_ChangeColor>
	  		  			  HAL_Delay(350);
 8000d8e:	20af      	movs	r0, #175	; 0xaf
 8000d90:	0040      	lsls	r0, r0, #1
 8000d92:	f000 fe45 	bl	8001a20 <HAL_Delay>
	  		  			  WS2812_ChangeColor(ws28xx_Color_Black);
 8000d96:	0030      	movs	r0, r6
 8000d98:	f7ff fed6 	bl	8000b48 <WS2812_ChangeColor>
	  		  			  HAL_Delay(350);
 8000d9c:	20af      	movs	r0, #175	; 0xaf
	  		  			learningMode_on++;
 8000d9e:	3501      	adds	r5, #1
	  		  			  HAL_Delay(350);
 8000da0:	0040      	lsls	r0, r0, #1
	  		  			learningMode_on++;
 8000da2:	b2ed      	uxtb	r5, r5
	  		  			  HAL_Delay(350);
 8000da4:	f000 fe3c 	bl	8001a20 <HAL_Delay>
 8000da8:	e7bb      	b.n	8000d22 <learningmode+0x72>
	  		  			WS2812_ChangeColor(ws28xx_Color_Red);
 8000daa:	0038      	movs	r0, r7
 8000dac:	f7ff fecc 	bl	8000b48 <WS2812_ChangeColor>
	  		  			  HAL_Delay(500);
 8000db0:	20fa      	movs	r0, #250	; 0xfa
 8000db2:	0040      	lsls	r0, r0, #1
 8000db4:	f000 fe34 	bl	8001a20 <HAL_Delay>
	  		  			WS2812_ChangeColor(ws28xx_Color_Black);
 8000db8:	0030      	movs	r0, r6
 8000dba:	f7ff fec5 	bl	8000b48 <WS2812_ChangeColor>
	  		  			  HAL_Delay(350);
 8000dbe:	20af      	movs	r0, #175	; 0xaf
 8000dc0:	0040      	lsls	r0, r0, #1
 8000dc2:	f000 fe2d 	bl	8001a20 <HAL_Delay>
	  		  			  learningMode_on = 0;
 8000dc6:	0035      	movs	r5, r6
 8000dc8:	e7ab      	b.n	8000d22 <learningmode+0x72>
	  		  	WS2812_ChangeColor(ws28xx_Color_Green);
 8000dca:	f7ff febd 	bl	8000b48 <WS2812_ChangeColor>
	  		  	HAL_Delay(500);
 8000dce:	20fa      	movs	r0, #250	; 0xfa
 8000dd0:	0040      	lsls	r0, r0, #1
 8000dd2:	f000 fe25 	bl	8001a20 <HAL_Delay>
	  		  	WS2812_ChangeColor(ws28xx_Color_Black);
 8000dd6:	2000      	movs	r0, #0
 8000dd8:	e7a8      	b.n	8000d2c <learningmode+0x7c>
 8000dda:	46c0      	nop			; (mov r8, r8)
 8000ddc:	200000fc 	.word	0x200000fc
 8000de0:	20000102 	.word	0x20000102
 8000de4:	200000f1 	.word	0x200000f1
 8000de8:	20000108 	.word	0x20000108

08000dec <main>:
{
 8000dec:	b5f0      	push	{r4, r5, r6, r7, lr}
 8000dee:	b08d      	sub	sp, #52	; 0x34
  HAL_Init();
 8000df0:	f000 fdf4 	bl	80019dc <HAL_Init>
  SystemClock_Config();
 8000df4:	f7ff febd 	bl	8000b72 <SystemClock_Config>
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8000df8:	2214      	movs	r2, #20
 8000dfa:	2100      	movs	r1, #0
 8000dfc:	a807      	add	r0, sp, #28
 8000dfe:	f002 fd1e 	bl	800383e <memset>
  __HAL_RCC_GPIOA_CLK_ENABLE();
 8000e02:	2180      	movs	r1, #128	; 0x80
 8000e04:	4dec      	ldr	r5, [pc, #944]	; (80011b8 <main+0x3cc>)
 8000e06:	0289      	lsls	r1, r1, #10
 8000e08:	696a      	ldr	r2, [r5, #20]
  HAL_GPIO_WritePin(GPIOA, CTRL_VUSB_Pin|RGB_MCU_EN_Pin|RGB_RPi_EN_Pin, GPIO_PIN_RESET);
 8000e0a:	2090      	movs	r0, #144	; 0x90
  __HAL_RCC_GPIOA_CLK_ENABLE();
 8000e0c:	430a      	orrs	r2, r1
 8000e0e:	616a      	str	r2, [r5, #20]
 8000e10:	696b      	ldr	r3, [r5, #20]
  HAL_GPIO_WritePin(GPIOA, CTRL_VUSB_Pin|RGB_MCU_EN_Pin|RGB_RPi_EN_Pin, GPIO_PIN_RESET);
 8000e12:	05c0      	lsls	r0, r0, #23
  __HAL_RCC_GPIOA_CLK_ENABLE();
 8000e14:	400b      	ands	r3, r1
  __HAL_RCC_GPIOB_CLK_ENABLE();
 8000e16:	2180      	movs	r1, #128	; 0x80
  __HAL_RCC_GPIOA_CLK_ENABLE();
 8000e18:	9303      	str	r3, [sp, #12]
 8000e1a:	9b03      	ldr	r3, [sp, #12]
  __HAL_RCC_GPIOB_CLK_ENABLE();
 8000e1c:	696a      	ldr	r2, [r5, #20]
 8000e1e:	02c9      	lsls	r1, r1, #11
 8000e20:	430a      	orrs	r2, r1
 8000e22:	616a      	str	r2, [r5, #20]
 8000e24:	696b      	ldr	r3, [r5, #20]
  HAL_GPIO_WritePin(GPIOA, CTRL_VUSB_Pin|RGB_MCU_EN_Pin|RGB_RPi_EN_Pin, GPIO_PIN_RESET);
 8000e26:	2200      	movs	r2, #0
  __HAL_RCC_GPIOB_CLK_ENABLE();
 8000e28:	400b      	ands	r3, r1
 8000e2a:	9304      	str	r3, [sp, #16]
  HAL_GPIO_WritePin(GPIOA, CTRL_VUSB_Pin|RGB_MCU_EN_Pin|RGB_RPi_EN_Pin, GPIO_PIN_RESET);
 8000e2c:	210d      	movs	r1, #13
  __HAL_RCC_GPIOB_CLK_ENABLE();
 8000e2e:	9b04      	ldr	r3, [sp, #16]
  HAL_GPIO_WritePin(GPIOA, CTRL_VUSB_Pin|RGB_MCU_EN_Pin|RGB_RPi_EN_Pin, GPIO_PIN_RESET);
 8000e30:	f001 fa40 	bl	80022b4 <HAL_GPIO_WritePin>
  HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8000e34:	2090      	movs	r0, #144	; 0x90
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 8000e36:	2400      	movs	r4, #0
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 8000e38:	2601      	movs	r6, #1
  GPIO_InitStruct.Pin = CTRL_VUSB_Pin|RGB_MCU_EN_Pin|RGB_RPi_EN_Pin;
 8000e3a:	230d      	movs	r3, #13
  HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8000e3c:	a907      	add	r1, sp, #28
 8000e3e:	05c0      	lsls	r0, r0, #23
  GPIO_InitStruct.Pin = CTRL_VUSB_Pin|RGB_MCU_EN_Pin|RGB_RPi_EN_Pin;
 8000e40:	9307      	str	r3, [sp, #28]
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 8000e42:	9608      	str	r6, [sp, #32]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 8000e44:	9409      	str	r4, [sp, #36]	; 0x24
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 8000e46:	940a      	str	r4, [sp, #40]	; 0x28
  HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8000e48:	f001 f97e 	bl	8002148 <HAL_GPIO_Init>
  GPIO_InitStruct.Pin = BUTTON_IN_Pin;
 8000e4c:	2302      	movs	r3, #2
  HAL_GPIO_Init(BUTTON_IN_GPIO_Port, &GPIO_InitStruct);
 8000e4e:	2090      	movs	r0, #144	; 0x90
  GPIO_InitStruct.Pin = BUTTON_IN_Pin;
 8000e50:	9307      	str	r3, [sp, #28]
  GPIO_InitStruct.Mode = GPIO_MODE_IT_FALLING;
 8000e52:	4bda      	ldr	r3, [pc, #872]	; (80011bc <main+0x3d0>)
  HAL_GPIO_Init(BUTTON_IN_GPIO_Port, &GPIO_InitStruct);
 8000e54:	a907      	add	r1, sp, #28
 8000e56:	05c0      	lsls	r0, r0, #23
  GPIO_InitStruct.Mode = GPIO_MODE_IT_FALLING;
 8000e58:	9308      	str	r3, [sp, #32]
  GPIO_InitStruct.Pull = GPIO_PULLUP;
 8000e5a:	9609      	str	r6, [sp, #36]	; 0x24
  HAL_GPIO_Init(BUTTON_IN_GPIO_Port, &GPIO_InitStruct);
 8000e5c:	f001 f974 	bl	8002148 <HAL_GPIO_Init>
  HAL_GPIO_Init(IRMP_Receive_GPIO_Port, &GPIO_InitStruct);
 8000e60:	2090      	movs	r0, #144	; 0x90
  GPIO_InitStruct.Pin = IRMP_Receive_Pin;
 8000e62:	2340      	movs	r3, #64	; 0x40
  HAL_GPIO_Init(IRMP_Receive_GPIO_Port, &GPIO_InitStruct);
 8000e64:	a907      	add	r1, sp, #28
 8000e66:	05c0      	lsls	r0, r0, #23
  GPIO_InitStruct.Pin = IRMP_Receive_Pin;
 8000e68:	9307      	str	r3, [sp, #28]
  GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
 8000e6a:	9408      	str	r4, [sp, #32]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 8000e6c:	9409      	str	r4, [sp, #36]	; 0x24
  HAL_GPIO_Init(IRMP_Receive_GPIO_Port, &GPIO_InitStruct);
 8000e6e:	f001 f96b 	bl	8002148 <HAL_GPIO_Init>
  __HAL_RCC_DMA1_CLK_ENABLE();
 8000e72:	696b      	ldr	r3, [r5, #20]
  HAL_NVIC_SetPriority(DMA1_Channel2_3_IRQn, 0, 0);
 8000e74:	0022      	movs	r2, r4
  __HAL_RCC_DMA1_CLK_ENABLE();
 8000e76:	4333      	orrs	r3, r6
 8000e78:	616b      	str	r3, [r5, #20]
 8000e7a:	696b      	ldr	r3, [r5, #20]
  HAL_NVIC_SetPriority(DMA1_Channel2_3_IRQn, 0, 0);
 8000e7c:	0021      	movs	r1, r4
  __HAL_RCC_DMA1_CLK_ENABLE();
 8000e7e:	4033      	ands	r3, r6
 8000e80:	9302      	str	r3, [sp, #8]
  HAL_NVIC_SetPriority(DMA1_Channel2_3_IRQn, 0, 0);
 8000e82:	200a      	movs	r0, #10
  __HAL_RCC_DMA1_CLK_ENABLE();
 8000e84:	9b02      	ldr	r3, [sp, #8]
  HAL_NVIC_SetPriority(DMA1_Channel2_3_IRQn, 0, 0);
 8000e86:	f000 ff01 	bl	8001c8c <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(DMA1_Channel2_3_IRQn);
 8000e8a:	200a      	movs	r0, #10
 8000e8c:	f000 ff28 	bl	8001ce0 <HAL_NVIC_EnableIRQ>
  ADC_ChannelConfTypeDef sConfig = {0};
 8000e90:	220c      	movs	r2, #12
 8000e92:	0021      	movs	r1, r4
 8000e94:	a807      	add	r0, sp, #28
 8000e96:	f002 fcd2 	bl	800383e <memset>
  hadc.Instance = ADC1;
 8000e9a:	4dc9      	ldr	r5, [pc, #804]	; (80011c0 <main+0x3d4>)
 8000e9c:	4bc9      	ldr	r3, [pc, #804]	; (80011c4 <main+0x3d8>)
  if (HAL_ADC_Init(&hadc) != HAL_OK)
 8000e9e:	0028      	movs	r0, r5
  hadc.Instance = ADC1;
 8000ea0:	602b      	str	r3, [r5, #0]
  hadc.Init.EOCSelection = ADC_EOC_SINGLE_CONV;
 8000ea2:	2304      	movs	r3, #4
 8000ea4:	616b      	str	r3, [r5, #20]
  hadc.Init.ExternalTrigConv = ADC_SOFTWARE_START;
 8000ea6:	23c2      	movs	r3, #194	; 0xc2
 8000ea8:	33ff      	adds	r3, #255	; 0xff
 8000eaa:	61eb      	str	r3, [r5, #28]
  hadc.Init.DMAContinuousRequests = DISABLE;
 8000eac:	1d6b      	adds	r3, r5, #5
  hadc.Init.ScanConvMode = ADC_SCAN_DIRECTION_FORWARD;
 8000eae:	612e      	str	r6, [r5, #16]
  hadc.Init.Overrun = ADC_OVR_DATA_PRESERVED;
 8000eb0:	62ae      	str	r6, [r5, #40]	; 0x28
  hadc.Init.ClockPrescaler = ADC_CLOCK_ASYNC_DIV1;
 8000eb2:	606c      	str	r4, [r5, #4]
  hadc.Init.Resolution = ADC_RESOLUTION_12B;
 8000eb4:	60ac      	str	r4, [r5, #8]
  hadc.Init.DataAlign = ADC_DATAALIGN_RIGHT;
 8000eb6:	60ec      	str	r4, [r5, #12]
  hadc.Init.LowPowerAutoWait = DISABLE;
 8000eb8:	762c      	strb	r4, [r5, #24]
  hadc.Init.LowPowerAutoPowerOff = DISABLE;
 8000eba:	766c      	strb	r4, [r5, #25]
  hadc.Init.ContinuousConvMode = DISABLE;
 8000ebc:	76ac      	strb	r4, [r5, #26]
  hadc.Init.DiscontinuousConvMode = DISABLE;
 8000ebe:	76ec      	strb	r4, [r5, #27]
  hadc.Init.ExternalTrigConvEdge = ADC_EXTERNALTRIGCONVEDGE_NONE;
 8000ec0:	622c      	str	r4, [r5, #32]
  hadc.Init.DMAContinuousRequests = DISABLE;
 8000ec2:	77dc      	strb	r4, [r3, #31]
  if (HAL_ADC_Init(&hadc) != HAL_OK)
 8000ec4:	f000 fdbe 	bl	8001a44 <HAL_ADC_Init>
  sConfig.Channel = ADC_CHANNEL_9;
 8000ec8:	2309      	movs	r3, #9
 8000eca:	9307      	str	r3, [sp, #28]
  sConfig.Rank = ADC_RANK_CHANNEL_NUMBER;
 8000ecc:	2380      	movs	r3, #128	; 0x80
 8000ece:	015b      	lsls	r3, r3, #5
 8000ed0:	9308      	str	r3, [sp, #32]
  sConfig.SamplingTime = ADC_SAMPLETIME_1CYCLE_5;
 8000ed2:	2380      	movs	r3, #128	; 0x80
  if (HAL_ADC_ConfigChannel(&hadc, &sConfig) != HAL_OK)
 8000ed4:	a907      	add	r1, sp, #28
  sConfig.SamplingTime = ADC_SAMPLETIME_1CYCLE_5;
 8000ed6:	055b      	lsls	r3, r3, #21
  if (HAL_ADC_ConfigChannel(&hadc, &sConfig) != HAL_OK)
 8000ed8:	0028      	movs	r0, r5
  sConfig.SamplingTime = ADC_SAMPLETIME_1CYCLE_5;
 8000eda:	9309      	str	r3, [sp, #36]	; 0x24
  if (HAL_ADC_ConfigChannel(&hadc, &sConfig) != HAL_OK)
 8000edc:	f000 fe58 	bl	8001b90 <HAL_ADC_ConfigChannel>
  hspi1.Instance = SPI1;
 8000ee0:	48b9      	ldr	r0, [pc, #740]	; (80011c8 <main+0x3dc>)
 8000ee2:	4bba      	ldr	r3, [pc, #744]	; (80011cc <main+0x3e0>)
  hspi1.Init.NSSPMode = SPI_NSS_PULSE_ENABLE;
 8000ee4:	2508      	movs	r5, #8
  hspi1.Instance = SPI1;
 8000ee6:	6003      	str	r3, [r0, #0]
  hspi1.Init.Mode = SPI_MODE_MASTER;
 8000ee8:	2382      	movs	r3, #130	; 0x82
 8000eea:	005b      	lsls	r3, r3, #1
 8000eec:	6043      	str	r3, [r0, #4]
  hspi1.Init.DataSize = SPI_DATASIZE_7BIT;
 8000eee:	23c0      	movs	r3, #192	; 0xc0
 8000ef0:	00db      	lsls	r3, r3, #3
 8000ef2:	60c3      	str	r3, [r0, #12]
  hspi1.Init.NSS = SPI_NSS_SOFT;
 8000ef4:	2380      	movs	r3, #128	; 0x80
 8000ef6:	009b      	lsls	r3, r3, #2
 8000ef8:	6183      	str	r3, [r0, #24]
  hspi1.Init.CRCPolynomial = 7;
 8000efa:	3bfa      	subs	r3, #250	; 0xfa
 8000efc:	3bff      	subs	r3, #255	; 0xff
 8000efe:	62c3      	str	r3, [r0, #44]	; 0x2c
  hspi1.Init.NSSPMode = SPI_NSS_PULSE_ENABLE;
 8000f00:	6345      	str	r5, [r0, #52]	; 0x34
  hspi1.Init.Direction = SPI_DIRECTION_2LINES;
 8000f02:	6084      	str	r4, [r0, #8]
  hspi1.Init.CLKPolarity = SPI_POLARITY_LOW;
 8000f04:	6104      	str	r4, [r0, #16]
  hspi1.Init.CLKPhase = SPI_PHASE_1EDGE;
 8000f06:	6144      	str	r4, [r0, #20]
  hspi1.Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_2;
 8000f08:	61c4      	str	r4, [r0, #28]
  hspi1.Init.FirstBit = SPI_FIRSTBIT_MSB;
 8000f0a:	6204      	str	r4, [r0, #32]
  hspi1.Init.TIMode = SPI_TIMODE_DISABLE;
 8000f0c:	6244      	str	r4, [r0, #36]	; 0x24
  hspi1.Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
 8000f0e:	6284      	str	r4, [r0, #40]	; 0x28
  hspi1.Init.CRCLength = SPI_CRC_LENGTH_DATASIZE;
 8000f10:	6304      	str	r4, [r0, #48]	; 0x30
  if (HAL_SPI_Init(&hspi1) != HAL_OK)
 8000f12:	f001 fdb1 	bl	8002a78 <HAL_SPI_Init>
  htim14.Instance = TIM14;
 8000f16:	4fae      	ldr	r7, [pc, #696]	; (80011d0 <main+0x3e4>)
 8000f18:	4bae      	ldr	r3, [pc, #696]	; (80011d4 <main+0x3e8>)
  if (HAL_TIM_Base_Init(&htim14) != HAL_OK)
 8000f1a:	0038      	movs	r0, r7
  htim14.Instance = TIM14;
 8000f1c:	603b      	str	r3, [r7, #0]
  htim14.Init.Period = 1599;
 8000f1e:	4bae      	ldr	r3, [pc, #696]	; (80011d8 <main+0x3ec>)
  htim14.Init.Prescaler = 0;
 8000f20:	607c      	str	r4, [r7, #4]
  htim14.Init.Period = 1599;
 8000f22:	60fb      	str	r3, [r7, #12]
  htim14.Init.ClockDivision = TIM_CLOCKDIVISION_DIV2;
 8000f24:	2380      	movs	r3, #128	; 0x80
 8000f26:	005b      	lsls	r3, r3, #1
 8000f28:	613b      	str	r3, [r7, #16]
  htim14.Init.CounterMode = TIM_COUNTERMODE_UP;
 8000f2a:	60bc      	str	r4, [r7, #8]
  htim14.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
 8000f2c:	61bc      	str	r4, [r7, #24]
  if (HAL_TIM_Base_Init(&htim14) != HAL_OK)
 8000f2e:	f001 ffe3 	bl	8002ef8 <HAL_TIM_Base_Init>
  HAL_TIM_Base_Start_IT(&htim14);
 8000f32:	0038      	movs	r0, r7
 8000f34:	f001 fed1 	bl	8002cda <HAL_TIM_Base_Start_IT>
  huart1.Instance = USART1;
 8000f38:	4ea8      	ldr	r6, [pc, #672]	; (80011dc <main+0x3f0>)
 8000f3a:	4ba9      	ldr	r3, [pc, #676]	; (80011e0 <main+0x3f4>)
  huart1.Init.Mode = UART_MODE_TX_RX;
 8000f3c:	220c      	movs	r2, #12
  huart1.Instance = USART1;
 8000f3e:	6033      	str	r3, [r6, #0]
  huart1.Init.BaudRate = 38400;
 8000f40:	2396      	movs	r3, #150	; 0x96
  if (HAL_UART_Init(&huart1) != HAL_OK)
 8000f42:	0030      	movs	r0, r6
  huart1.Init.BaudRate = 38400;
 8000f44:	021b      	lsls	r3, r3, #8
 8000f46:	6073      	str	r3, [r6, #4]
  huart1.Init.Mode = UART_MODE_TX_RX;
 8000f48:	6172      	str	r2, [r6, #20]
  huart1.Init.WordLength = UART_WORDLENGTH_8B;
 8000f4a:	60b4      	str	r4, [r6, #8]
  huart1.Init.StopBits = UART_STOPBITS_1;
 8000f4c:	60f4      	str	r4, [r6, #12]
  huart1.Init.Parity = UART_PARITY_NONE;
 8000f4e:	6134      	str	r4, [r6, #16]
  huart1.Init.HwFlowCtl = UART_HWCONTROL_NONE;
 8000f50:	61b4      	str	r4, [r6, #24]
  huart1.Init.OverSampling = UART_OVERSAMPLING_16;
 8000f52:	61f4      	str	r4, [r6, #28]
  huart1.Init.OneBitSampling = UART_ONE_BIT_SAMPLE_DISABLE;
 8000f54:	6234      	str	r4, [r6, #32]
  huart1.AdvancedInit.AdvFeatureInit = UART_ADVFEATURE_NO_INIT;
 8000f56:	6274      	str	r4, [r6, #36]	; 0x24
  if (HAL_UART_Init(&huart1) != HAL_OK)
 8000f58:	f002 fc12 	bl	8003780 <HAL_UART_Init>
  HAL_UART_Receive_IT(&huart1, &RxBuffer, 1);
 8000f5c:	2201      	movs	r2, #1
 8000f5e:	49a1      	ldr	r1, [pc, #644]	; (80011e4 <main+0x3f8>)
 8000f60:	0030      	movs	r0, r6
 8000f62:	f002 f8c5 	bl	80030f0 <HAL_UART_Receive_IT>
  TIM_ClockConfigTypeDef sClockSourceConfig = {0};
 8000f66:	2210      	movs	r2, #16
 8000f68:	0021      	movs	r1, r4
 8000f6a:	a807      	add	r0, sp, #28
 8000f6c:	f002 fc67 	bl	800383e <memset>
  TIM_MasterConfigTypeDef sMasterConfig = {0};
 8000f70:	002a      	movs	r2, r5
 8000f72:	0021      	movs	r1, r4
 8000f74:	a805      	add	r0, sp, #20
 8000f76:	f002 fc62 	bl	800383e <memset>
  htim1.Instance = TIM1;
 8000f7a:	4d9b      	ldr	r5, [pc, #620]	; (80011e8 <main+0x3fc>)
 8000f7c:	4b9b      	ldr	r3, [pc, #620]	; (80011ec <main+0x400>)
  if (HAL_TIM_Base_Init(&htim1) != HAL_OK)
 8000f7e:	0028      	movs	r0, r5
  htim1.Instance = TIM1;
 8000f80:	602b      	str	r3, [r5, #0]
  htim1.Init.Prescaler = 32000;
 8000f82:	23fa      	movs	r3, #250	; 0xfa
 8000f84:	01db      	lsls	r3, r3, #7
 8000f86:	606b      	str	r3, [r5, #4]
  htim1.Init.Period = 50;
 8000f88:	2332      	movs	r3, #50	; 0x32
  htim1.Init.CounterMode = TIM_COUNTERMODE_UP;
 8000f8a:	60ac      	str	r4, [r5, #8]
  htim1.Init.Period = 50;
 8000f8c:	60eb      	str	r3, [r5, #12]
  htim1.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
 8000f8e:	612c      	str	r4, [r5, #16]
  htim1.Init.RepetitionCounter = 0;
 8000f90:	616c      	str	r4, [r5, #20]
  htim1.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
 8000f92:	61ac      	str	r4, [r5, #24]
  if (HAL_TIM_Base_Init(&htim1) != HAL_OK)
 8000f94:	f001 ffb0 	bl	8002ef8 <HAL_TIM_Base_Init>
  sClockSourceConfig.ClockSource = TIM_CLOCKSOURCE_INTERNAL;
 8000f98:	2380      	movs	r3, #128	; 0x80
  if (HAL_TIM_ConfigClockSource(&htim1, &sClockSourceConfig) != HAL_OK)
 8000f9a:	a907      	add	r1, sp, #28
  sClockSourceConfig.ClockSource = TIM_CLOCKSOURCE_INTERNAL;
 8000f9c:	015b      	lsls	r3, r3, #5
  if (HAL_TIM_ConfigClockSource(&htim1, &sClockSourceConfig) != HAL_OK)
 8000f9e:	0028      	movs	r0, r5
  sClockSourceConfig.ClockSource = TIM_CLOCKSOURCE_INTERNAL;
 8000fa0:	9307      	str	r3, [sp, #28]
  if (HAL_TIM_ConfigClockSource(&htim1, &sClockSourceConfig) != HAL_OK)
 8000fa2:	f001 ffd1 	bl	8002f48 <HAL_TIM_ConfigClockSource>
  if (HAL_TIMEx_MasterConfigSynchronization(&htim1, &sMasterConfig) != HAL_OK)
 8000fa6:	a905      	add	r1, sp, #20
 8000fa8:	0028      	movs	r0, r5
  sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
 8000faa:	9405      	str	r4, [sp, #20]
  sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
 8000fac:	9406      	str	r4, [sp, #24]
  if (HAL_TIMEx_MasterConfigSynchronization(&htim1, &sMasterConfig) != HAL_OK)
 8000fae:	f002 f861 	bl	8003074 <HAL_TIMEx_MasterConfigSynchronization>
  htim16.Instance = TIM16;
 8000fb2:	4d8f      	ldr	r5, [pc, #572]	; (80011f0 <main+0x404>)
 8000fb4:	4b8f      	ldr	r3, [pc, #572]	; (80011f4 <main+0x408>)
  if (HAL_TIM_Base_Init(&htim16) != HAL_OK)
 8000fb6:	0028      	movs	r0, r5
  htim16.Instance = TIM16;
 8000fb8:	602b      	str	r3, [r5, #0]
  htim16.Init.Prescaler = 3124;
 8000fba:	4b8f      	ldr	r3, [pc, #572]	; (80011f8 <main+0x40c>)
  htim16.Init.CounterMode = TIM_COUNTERMODE_UP;
 8000fbc:	60ac      	str	r4, [r5, #8]
  htim16.Init.Prescaler = 3124;
 8000fbe:	606b      	str	r3, [r5, #4]
  htim16.Init.Period = 63999;
 8000fc0:	4b8e      	ldr	r3, [pc, #568]	; (80011fc <main+0x410>)
  htim16.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
 8000fc2:	612c      	str	r4, [r5, #16]
  htim16.Init.Period = 63999;
 8000fc4:	60eb      	str	r3, [r5, #12]
  htim16.Init.RepetitionCounter = 0;
 8000fc6:	616c      	str	r4, [r5, #20]
  htim16.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
 8000fc8:	61ac      	str	r4, [r5, #24]
  if (HAL_TIM_Base_Init(&htim16) != HAL_OK)
 8000fca:	f001 ff95 	bl	8002ef8 <HAL_TIM_Base_Init>
  HAL_NVIC_SetPriority(TIM14_IRQn, 0, 0);
 8000fce:	0022      	movs	r2, r4
 8000fd0:	0021      	movs	r1, r4
 8000fd2:	2013      	movs	r0, #19
 8000fd4:	f000 fe5a 	bl	8001c8c <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(TIM14_IRQn);
 8000fd8:	2013      	movs	r0, #19
 8000fda:	f000 fe81 	bl	8001ce0 <HAL_NVIC_EnableIRQ>
  HAL_NVIC_SetPriority(USART1_IRQn, 0, 0);
 8000fde:	0022      	movs	r2, r4
 8000fe0:	0021      	movs	r1, r4
 8000fe2:	201b      	movs	r0, #27
 8000fe4:	f000 fe52 	bl	8001c8c <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(USART1_IRQn);
 8000fe8:	201b      	movs	r0, #27
 8000fea:	f000 fe79 	bl	8001ce0 <HAL_NVIC_EnableIRQ>
  HAL_NVIC_SetPriority(EXTI0_1_IRQn, 0, 0);
 8000fee:	0022      	movs	r2, r4
 8000ff0:	0021      	movs	r1, r4
 8000ff2:	2005      	movs	r0, #5
 8000ff4:	f000 fe4a 	bl	8001c8c <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(EXTI0_1_IRQn);
 8000ff8:	2005      	movs	r0, #5
 8000ffa:	f000 fe71 	bl	8001ce0 <HAL_NVIC_EnableIRQ>
  HAL_NVIC_SetPriority(TIM1_CC_IRQn, 0, 0);
 8000ffe:	0021      	movs	r1, r4
 8001000:	0022      	movs	r2, r4
 8001002:	200e      	movs	r0, #14
 8001004:	f000 fe42 	bl	8001c8c <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(TIM1_CC_IRQn);
 8001008:	200e      	movs	r0, #14
 800100a:	f000 fe69 	bl	8001ce0 <HAL_NVIC_EnableIRQ>
  irmp_data.protocol = *(uint8_t *)irmp_protocol_FlashAdress;
 800100e:	4b7c      	ldr	r3, [pc, #496]	; (8001200 <main+0x414>)
 8001010:	4a7c      	ldr	r2, [pc, #496]	; (8001204 <main+0x418>)
 8001012:	781b      	ldrb	r3, [r3, #0]
 8001014:	7013      	strb	r3, [r2, #0]
  irmp_data.address = *(uint16_t *)irmp_address_FlashAdress;
 8001016:	4b7c      	ldr	r3, [pc, #496]	; (8001208 <main+0x41c>)
 8001018:	881b      	ldrh	r3, [r3, #0]
 800101a:	7053      	strb	r3, [r2, #1]
 800101c:	0a1b      	lsrs	r3, r3, #8
 800101e:	7093      	strb	r3, [r2, #2]
  irmp_data.command = *(uint16_t *)irmp_command_FlashAdress;
 8001020:	4b7a      	ldr	r3, [pc, #488]	; (800120c <main+0x420>)
 8001022:	881b      	ldrh	r3, [r3, #0]
 8001024:	70d3      	strb	r3, [r2, #3]
 8001026:	0a1b      	lsrs	r3, r3, #8
 8001028:	7113      	strb	r3, [r2, #4]
  ledMode = *(uint8_t *)led_mode_FlashAdress;
 800102a:	4b79      	ldr	r3, [pc, #484]	; (8001210 <main+0x424>)
 800102c:	4a79      	ldr	r2, [pc, #484]	; (8001214 <main+0x428>)
 800102e:	781b      	ldrb	r3, [r3, #0]
 8001030:	7013      	strb	r3, [r2, #0]
  irmp_init();
 8001032:	f7ff f977 	bl	8000324 <irmp_init>
  RGB_MCU();
 8001036:	f7ff fdec 	bl	8000c12 <RGB_MCU>
	  WS2812_ChangeColor(ws28xx_Color_Red);
 800103a:	2001      	movs	r0, #1
 800103c:	f7ff fd84 	bl	8000b48 <WS2812_ChangeColor>
	  if (!(ledMode == 0))
 8001040:	4b74      	ldr	r3, [pc, #464]	; (8001214 <main+0x428>)
 8001042:	781b      	ldrb	r3, [r3, #0]
 8001044:	42a3      	cmp	r3, r4
 8001046:	d005      	beq.n	8001054 <main+0x268>
		  HAL_Delay(100);
 8001048:	2064      	movs	r0, #100	; 0x64
 800104a:	f000 fce9 	bl	8001a20 <HAL_Delay>
		  WS2812_ChangeColor(ws28xx_Color_Black);
 800104e:	0020      	movs	r0, r4
 8001050:	f7ff fd7a 	bl	8000b48 <WS2812_ChangeColor>
  RPi_Power_Down();
 8001054:	f7ff fdc7 	bl	8000be6 <RPi_Power_Down>
	  if(!strcmp(Rx_data,"X04\r"))
 8001058:	4c6f      	ldr	r4, [pc, #444]	; (8001218 <main+0x42c>)
 800105a:	4970      	ldr	r1, [pc, #448]	; (800121c <main+0x430>)
 800105c:	0020      	movs	r0, r4
 800105e:	f7ff f853 	bl	8000108 <strcmp>
 8001062:	2800      	cmp	r0, #0
 8001064:	d105      	bne.n	8001072 <main+0x286>
		  	  strcpy(Rx_data, "     ");
 8001066:	496e      	ldr	r1, [pc, #440]	; (8001220 <main+0x434>)
 8001068:	0020      	movs	r0, r4
 800106a:	f002 fbf0 	bl	800384e <strcpy>
		  	  learningmode();
 800106e:	f7ff fe1f 	bl	8000cb0 <learningmode>
	  if(!strncmp(Rx_data, "LM", 2) && Rx_data[2] >= '0' && Rx_data[2] <= '2' && Rx_data[3] == 13)
 8001072:	2202      	movs	r2, #2
 8001074:	496b      	ldr	r1, [pc, #428]	; (8001224 <main+0x438>)
 8001076:	0020      	movs	r0, r4
 8001078:	f002 fbf1 	bl	800385e <strncmp>
 800107c:	2800      	cmp	r0, #0
 800107e:	d112      	bne.n	80010a6 <main+0x2ba>
 8001080:	78a2      	ldrb	r2, [r4, #2]
 8001082:	0013      	movs	r3, r2
 8001084:	3b30      	subs	r3, #48	; 0x30
 8001086:	2b02      	cmp	r3, #2
 8001088:	d80d      	bhi.n	80010a6 <main+0x2ba>
 800108a:	78e3      	ldrb	r3, [r4, #3]
 800108c:	2b0d      	cmp	r3, #13
 800108e:	d10a      	bne.n	80010a6 <main+0x2ba>
 8001090:	4b60      	ldr	r3, [pc, #384]	; (8001214 <main+0x428>)
		  if(Rx_data[2] == '0')
 8001092:	2a30      	cmp	r2, #48	; 0x30
 8001094:	d000      	beq.n	8001098 <main+0x2ac>
 8001096:	e0d5      	b.n	8001244 <main+0x458>
			  ledMode = 0;
 8001098:	7018      	strb	r0, [r3, #0]
		  flashConfig();
 800109a:	f7ff fdd1 	bl	8000c40 <flashConfig>
		  strcpy(Rx_data, "    ");
 800109e:	4962      	ldr	r1, [pc, #392]	; (8001228 <main+0x43c>)
 80010a0:	0020      	movs	r0, r4
 80010a2:	f002 fbd4 	bl	800384e <strcpy>
	  	  if (irmp_get_data (&irmp_temp_data) || button > 0)
 80010a6:	4c61      	ldr	r4, [pc, #388]	; (800122c <main+0x440>)
 80010a8:	0020      	movs	r0, r4
 80010aa:	f7ff f93d 	bl	8000328 <irmp_get_data>
 80010ae:	2800      	cmp	r0, #0
 80010b0:	d103      	bne.n	80010ba <main+0x2ce>
 80010b2:	4b5f      	ldr	r3, [pc, #380]	; (8001230 <main+0x444>)
 80010b4:	781b      	ldrb	r3, [r3, #0]
 80010b6:	2b00      	cmp	r3, #0
 80010b8:	d0ce      	beq.n	8001058 <main+0x26c>
	  		  	  __HAL_TIM_DISABLE_IT(&htim14, TIM_IT_UPDATE);
 80010ba:	2101      	movs	r1, #1
 80010bc:	683a      	ldr	r2, [r7, #0]
	  		  	  HAL_NVIC_DisableIRQ(EXTI0_1_IRQn);
 80010be:	2005      	movs	r0, #5
	  		  	  __HAL_TIM_DISABLE_IT(&htim14, TIM_IT_UPDATE);
 80010c0:	68d3      	ldr	r3, [r2, #12]
 80010c2:	438b      	bics	r3, r1
 80010c4:	60d3      	str	r3, [r2, #12]
	  		  	  HAL_NVIC_DisableIRQ(EXTI0_1_IRQn);
 80010c6:	f000 fe17 	bl	8001cf8 <HAL_NVIC_DisableIRQ>
	  		  	  HAL_Delay(50);
 80010ca:	2032      	movs	r0, #50	; 0x32
 80010cc:	f000 fca8 	bl	8001a20 <HAL_Delay>
	  		  	  if (powerUP == 1)
 80010d0:	4b58      	ldr	r3, [pc, #352]	; (8001234 <main+0x448>)
 80010d2:	781b      	ldrb	r3, [r3, #0]
 80010d4:	2b01      	cmp	r3, #1
 80010d6:	d000      	beq.n	80010da <main+0x2ee>
 80010d8:	e0c3      	b.n	8001262 <main+0x476>
		  		  	  if ((((irmp_temp_data.command == irmp_data.command) && (irmp_temp_data.address == irmp_data.address) && (irmp_temp_data.protocol == irmp_data.protocol) )|| (((button > 0)))))
 80010da:	4b4a      	ldr	r3, [pc, #296]	; (8001204 <main+0x418>)
 80010dc:	7922      	ldrb	r2, [r4, #4]
 80010de:	78d9      	ldrb	r1, [r3, #3]
 80010e0:	791b      	ldrb	r3, [r3, #4]
 80010e2:	78e0      	ldrb	r0, [r4, #3]
 80010e4:	0212      	lsls	r2, r2, #8
 80010e6:	021b      	lsls	r3, r3, #8
 80010e8:	4302      	orrs	r2, r0
 80010ea:	430b      	orrs	r3, r1
 80010ec:	429a      	cmp	r2, r3
 80010ee:	d10f      	bne.n	8001110 <main+0x324>
 80010f0:	4b44      	ldr	r3, [pc, #272]	; (8001204 <main+0x418>)
 80010f2:	78a2      	ldrb	r2, [r4, #2]
 80010f4:	7859      	ldrb	r1, [r3, #1]
 80010f6:	789b      	ldrb	r3, [r3, #2]
 80010f8:	7860      	ldrb	r0, [r4, #1]
 80010fa:	0212      	lsls	r2, r2, #8
 80010fc:	021b      	lsls	r3, r3, #8
 80010fe:	4302      	orrs	r2, r0
 8001100:	430b      	orrs	r3, r1
 8001102:	429a      	cmp	r2, r3
 8001104:	d104      	bne.n	8001110 <main+0x324>
 8001106:	4b3f      	ldr	r3, [pc, #252]	; (8001204 <main+0x418>)
 8001108:	7822      	ldrb	r2, [r4, #0]
 800110a:	781b      	ldrb	r3, [r3, #0]
 800110c:	429a      	cmp	r2, r3
 800110e:	d003      	beq.n	8001118 <main+0x32c>
 8001110:	4b47      	ldr	r3, [pc, #284]	; (8001230 <main+0x444>)
 8001112:	781b      	ldrb	r3, [r3, #0]
 8001114:	2b00      	cmp	r3, #0
 8001116:	d03c      	beq.n	8001192 <main+0x3a6>
		  		  		  memset(&irmp_temp_data, 0, sizeof(IRMP_DATA));
 8001118:	2206      	movs	r2, #6
 800111a:	2100      	movs	r1, #0
 800111c:	4843      	ldr	r0, [pc, #268]	; (800122c <main+0x440>)
 800111e:	f002 fb8e 	bl	800383e <memset>
		  		  		  RGB_MCU();
 8001122:	f7ff fd76 	bl	8000c12 <RGB_MCU>
		  		  		  HAL_UART_Transmit(&huart1, (uint8_t *)shutdownMessage, sizeof(shutdownMessage), sizeof(shutdownMessage));
 8001126:	231c      	movs	r3, #28
 8001128:	4943      	ldr	r1, [pc, #268]	; (8001238 <main+0x44c>)
 800112a:	001a      	movs	r2, r3
 800112c:	0030      	movs	r0, r6
 800112e:	f002 fa8d 	bl	800364c <HAL_UART_Transmit>
		  		    	  if (ledMode == 2)
 8001132:	4b38      	ldr	r3, [pc, #224]	; (8001214 <main+0x428>)
 8001134:	781b      	ldrb	r3, [r3, #0]
 8001136:	2b02      	cmp	r3, #2
 8001138:	d105      	bne.n	8001146 <main+0x35a>
		  		    		  WS2812_ChangeColor(ws28xx_Color_Red);
 800113a:	2001      	movs	r0, #1
 800113c:	f7ff fd04 	bl	8000b48 <WS2812_ChangeColor>
		  		    		  HAL_Delay(100);
 8001140:	2064      	movs	r0, #100	; 0x64
 8001142:	f000 fc6d 	bl	8001a20 <HAL_Delay>
		  		  		  WS2812_ChangeColor(ws28xx_Color_Black);
 8001146:	2000      	movs	r0, #0
 8001148:	f7ff fcfe 	bl	8000b48 <WS2812_ChangeColor>
		  		    	  HAL_Delay(100);
 800114c:	2064      	movs	r0, #100	; 0x64
 800114e:	f000 fc67 	bl	8001a20 <HAL_Delay>
		  		    	  __HAL_TIM_CLEAR_IT(&htim16 ,TIM_IT_UPDATE);
 8001152:	2202      	movs	r2, #2
 8001154:	682b      	ldr	r3, [r5, #0]
 8001156:	4252      	negs	r2, r2
 8001158:	611a      	str	r2, [r3, #16]
		  		    	  __HAL_TIM_SET_COUNTER(&htim16, 0);
 800115a:	2200      	movs	r2, #0
		  		    	  HAL_TIM_Base_Start_IT(&htim16);
 800115c:	0028      	movs	r0, r5
		  		    	  __HAL_TIM_SET_COUNTER(&htim16, 0);
 800115e:	625a      	str	r2, [r3, #36]	; 0x24
		  		    	  HAL_TIM_Base_Start_IT(&htim16);
 8001160:	f001 fdbb 	bl	8002cda <HAL_TIM_Base_Start_IT>
		  		    	  timer = shutDownTime;
 8001164:	2301      	movs	r3, #1
 8001166:	4c35      	ldr	r4, [pc, #212]	; (800123c <main+0x450>)
 8001168:	7023      	strb	r3, [r4, #0]
							  	  if (!(ledMode == 2))
 800116a:	4b2a      	ldr	r3, [pc, #168]	; (8001214 <main+0x428>)
 800116c:	781b      	ldrb	r3, [r3, #0]
		  		    	  while(timer > 0)
 800116e:	7822      	ldrb	r2, [r4, #0]
 8001170:	2a00      	cmp	r2, #0
 8001172:	d16e      	bne.n	8001252 <main+0x466>
		  		    	  if (ledMode == 0)
 8001174:	2b00      	cmp	r3, #0
 8001176:	d171      	bne.n	800125c <main+0x470>
			  		    	  WS2812_ChangeColor(ws28xx_Color_Red);
 8001178:	2001      	movs	r0, #1
 800117a:	f7ff fce5 	bl	8000b48 <WS2812_ChangeColor>
		  		  		  HAL_Delay(50);
 800117e:	2032      	movs	r0, #50	; 0x32
 8001180:	f000 fc4e 	bl	8001a20 <HAL_Delay>
		  		  		  RPi_Power_Down();
 8001184:	f7ff fd2f 	bl	8000be6 <RPi_Power_Down>
		  		  		  powerUP = 0;
 8001188:	2300      	movs	r3, #0
 800118a:	4a2a      	ldr	r2, [pc, #168]	; (8001234 <main+0x448>)
 800118c:	7013      	strb	r3, [r2, #0]
		  		  		  button = 0;
 800118e:	4a28      	ldr	r2, [pc, #160]	; (8001230 <main+0x444>)
 8001190:	7013      	strb	r3, [r2, #0]
	  		  	__HAL_TIM_ENABLE_IT(&htim14, TIM_IT_UPDATE);
 8001192:	2101      	movs	r1, #1
 8001194:	683a      	ldr	r2, [r7, #0]
	  		  	  HAL_NVIC_ClearPendingIRQ(EXTI0_1_IRQn);
 8001196:	2005      	movs	r0, #5
	  		  	__HAL_TIM_ENABLE_IT(&htim14, TIM_IT_UPDATE);
 8001198:	68d3      	ldr	r3, [r2, #12]
 800119a:	430b      	orrs	r3, r1
 800119c:	60d3      	str	r3, [r2, #12]
	  		  	__HAL_GPIO_EXTI_CLEAR_FLAG(BUTTON_IN_Pin);
 800119e:	2202      	movs	r2, #2
 80011a0:	4b27      	ldr	r3, [pc, #156]	; (8001240 <main+0x454>)
 80011a2:	615a      	str	r2, [r3, #20]
	  		  	__HAL_GPIO_EXTI_CLEAR_IT(BUTTON_IN_Pin);
 80011a4:	615a      	str	r2, [r3, #20]
	  		  	  HAL_NVIC_ClearPendingIRQ(EXTI0_1_IRQn);
 80011a6:	f000 fdd1 	bl	8001d4c <HAL_NVIC_ClearPendingIRQ>
	  		  	  HAL_NVIC_EnableIRQ(EXTI0_1_IRQn);
 80011aa:	2005      	movs	r0, #5
 80011ac:	f000 fd98 	bl	8001ce0 <HAL_NVIC_EnableIRQ>
	  		  	  HAL_Delay(50);
 80011b0:	2032      	movs	r0, #50	; 0x32
 80011b2:	f000 fc35 	bl	8001a20 <HAL_Delay>
 80011b6:	e74f      	b.n	8001058 <main+0x26c>
 80011b8:	40021000 	.word	0x40021000
 80011bc:	10210000 	.word	0x10210000
 80011c0:	20000274 	.word	0x20000274
 80011c4:	40012400 	.word	0x40012400
 80011c8:	200001d0 	.word	0x200001d0
 80011cc:	40013000 	.word	0x40013000
 80011d0:	20000234 	.word	0x20000234
 80011d4:	40002000 	.word	0x40002000
 80011d8:	0000063f 	.word	0x0000063f
 80011dc:	20000110 	.word	0x20000110
 80011e0:	40013800 	.word	0x40013800
 80011e4:	200000f9 	.word	0x200000f9
 80011e8:	20000190 	.word	0x20000190
 80011ec:	40012c00 	.word	0x40012c00
 80011f0:	200002b4 	.word	0x200002b4
 80011f4:	40014400 	.word	0x40014400
 80011f8:	00000c34 	.word	0x00000c34
 80011fc:	0000f9ff 	.word	0x0000f9ff
 8001200:	08007c00 	.word	0x08007c00
 8001204:	20000108 	.word	0x20000108
 8001208:	08007c10 	.word	0x08007c10
 800120c:	08007c20 	.word	0x08007c20
 8001210:	08007c30 	.word	0x08007c30
 8001214:	200000f1 	.word	0x200000f1
 8001218:	200000f3 	.word	0x200000f3
 800121c:	08003a94 	.word	0x08003a94
 8001220:	08003a99 	.word	0x08003a99
 8001224:	08003a9f 	.word	0x08003a9f
 8001228:	08003a9a 	.word	0x08003a9a
 800122c:	200000fc 	.word	0x200000fc
 8001230:	200000f8 	.word	0x200000f8
 8001234:	200000fa 	.word	0x200000fa
 8001238:	20000008 	.word	0x20000008
 800123c:	200000f2 	.word	0x200000f2
 8001240:	40010400 	.word	0x40010400
		  else if(Rx_data[2] == '1')
 8001244:	2a31      	cmp	r2, #49	; 0x31
 8001246:	d102      	bne.n	800124e <main+0x462>
			  ledMode = 1;
 8001248:	3a30      	subs	r2, #48	; 0x30
			  ledMode = 2;
 800124a:	701a      	strb	r2, [r3, #0]
 800124c:	e725      	b.n	800109a <main+0x2ae>
 800124e:	2202      	movs	r2, #2
 8001250:	e7fb      	b.n	800124a <main+0x45e>
							  	  if (!(ledMode == 2))
 8001252:	2b02      	cmp	r3, #2
 8001254:	d08b      	beq.n	800116e <main+0x382>
							  		  ws28xx_fadeRed();
 8001256:	f000 fb67 	bl	8001928 <ws28xx_fadeRed>
 800125a:	e786      	b.n	800116a <main+0x37e>
		  		    		  ws28xx_fadeRed();
 800125c:	f000 fb64 	bl	8001928 <ws28xx_fadeRed>
 8001260:	e78d      	b.n	800117e <main+0x392>
					else if (powerUP == 0)
 8001262:	2b00      	cmp	r3, #0
 8001264:	d195      	bne.n	8001192 <main+0x3a6>
						if ((((irmp_temp_data.command == irmp_data.command) && (irmp_temp_data.address == irmp_data.address) && (irmp_temp_data.protocol == irmp_data.protocol) )||(( (button > 0)))))
 8001266:	4b36      	ldr	r3, [pc, #216]	; (8001340 <main+0x554>)
 8001268:	7922      	ldrb	r2, [r4, #4]
 800126a:	78d9      	ldrb	r1, [r3, #3]
 800126c:	791b      	ldrb	r3, [r3, #4]
 800126e:	78e0      	ldrb	r0, [r4, #3]
 8001270:	0212      	lsls	r2, r2, #8
 8001272:	021b      	lsls	r3, r3, #8
 8001274:	4302      	orrs	r2, r0
 8001276:	430b      	orrs	r3, r1
 8001278:	429a      	cmp	r2, r3
 800127a:	d10f      	bne.n	800129c <main+0x4b0>
 800127c:	4b30      	ldr	r3, [pc, #192]	; (8001340 <main+0x554>)
 800127e:	78a2      	ldrb	r2, [r4, #2]
 8001280:	7859      	ldrb	r1, [r3, #1]
 8001282:	789b      	ldrb	r3, [r3, #2]
 8001284:	7860      	ldrb	r0, [r4, #1]
 8001286:	0212      	lsls	r2, r2, #8
 8001288:	021b      	lsls	r3, r3, #8
 800128a:	4302      	orrs	r2, r0
 800128c:	430b      	orrs	r3, r1
 800128e:	429a      	cmp	r2, r3
 8001290:	d104      	bne.n	800129c <main+0x4b0>
 8001292:	4b2b      	ldr	r3, [pc, #172]	; (8001340 <main+0x554>)
 8001294:	7822      	ldrb	r2, [r4, #0]
 8001296:	781b      	ldrb	r3, [r3, #0]
 8001298:	429a      	cmp	r2, r3
 800129a:	d004      	beq.n	80012a6 <main+0x4ba>
 800129c:	4b29      	ldr	r3, [pc, #164]	; (8001344 <main+0x558>)
 800129e:	781b      	ldrb	r3, [r3, #0]
 80012a0:	2b00      	cmp	r3, #0
 80012a2:	d100      	bne.n	80012a6 <main+0x4ba>
 80012a4:	e775      	b.n	8001192 <main+0x3a6>
							  memset(&irmp_temp_data, 0, sizeof(IRMP_DATA));
 80012a6:	2206      	movs	r2, #6
 80012a8:	2100      	movs	r1, #0
 80012aa:	4827      	ldr	r0, [pc, #156]	; (8001348 <main+0x55c>)
 80012ac:	f002 fac7 	bl	800383e <memset>
							  RPi_Power_Up();
 80012b0:	f7ff fc91 	bl	8000bd6 <RPi_Power_Up>
			  		    	  if (ledMode == 2)
 80012b4:	4b25      	ldr	r3, [pc, #148]	; (800134c <main+0x560>)
 80012b6:	7818      	ldrb	r0, [r3, #0]
 80012b8:	2802      	cmp	r0, #2
 80012ba:	d104      	bne.n	80012c6 <main+0x4da>
			  		    		  WS2812_ChangeColor(ws28xx_Color_Green);
 80012bc:	f7ff fc44 	bl	8000b48 <WS2812_ChangeColor>
			  		    		  HAL_Delay(100);
 80012c0:	2064      	movs	r0, #100	; 0x64
 80012c2:	f000 fbad 	bl	8001a20 <HAL_Delay>
							  WS2812_ChangeColor(ws28xx_Color_Black);
 80012c6:	2000      	movs	r0, #0
 80012c8:	f7ff fc3e 	bl	8000b48 <WS2812_ChangeColor>
							  HAL_Delay(100);
 80012cc:	2064      	movs	r0, #100	; 0x64
 80012ce:	f000 fba7 	bl	8001a20 <HAL_Delay>
							  __HAL_TIM_CLEAR_IT(&htim16 ,TIM_IT_UPDATE);
 80012d2:	2202      	movs	r2, #2
 80012d4:	682b      	ldr	r3, [r5, #0]
 80012d6:	4252      	negs	r2, r2
 80012d8:	611a      	str	r2, [r3, #16]
							  __HAL_TIM_SET_COUNTER(&htim16, 0);
 80012da:	2200      	movs	r2, #0
							  HAL_TIM_Base_Start_IT(&htim16);
 80012dc:	0028      	movs	r0, r5
							  __HAL_TIM_SET_COUNTER(&htim16, 0);
 80012de:	625a      	str	r2, [r3, #36]	; 0x24
							  HAL_TIM_Base_Start_IT(&htim16);
 80012e0:	f001 fcfb 	bl	8002cda <HAL_TIM_Base_Start_IT>
							  timer = bootUpTime;
 80012e4:	2305      	movs	r3, #5
 80012e6:	4c1a      	ldr	r4, [pc, #104]	; (8001350 <main+0x564>)
											  timer = 0;
 80012e8:	7023      	strb	r3, [r4, #0]
 80012ea:	4b18      	ldr	r3, [pc, #96]	; (800134c <main+0x560>)
							  while(timer > 0)
 80012ec:	7822      	ldrb	r2, [r4, #0]
 80012ee:	781b      	ldrb	r3, [r3, #0]
 80012f0:	2a00      	cmp	r2, #0
 80012f2:	d110      	bne.n	8001316 <main+0x52a>
							  if (ledMode == 0)
 80012f4:	2b00      	cmp	r3, #0
 80012f6:	d11f      	bne.n	8001338 <main+0x54c>
								  WS2812_ChangeColor(ws28xx_Color_Green);
 80012f8:	2002      	movs	r0, #2
 80012fa:	f7ff fc25 	bl	8000b48 <WS2812_ChangeColor>
							  HAL_Delay(50);
 80012fe:	2032      	movs	r0, #50	; 0x32
 8001300:	f000 fb8e 	bl	8001a20 <HAL_Delay>
							  RGB_RPi();
 8001304:	f7ff fc77 	bl	8000bf6 <RGB_RPi>
							  powerUP = 1;
 8001308:	2201      	movs	r2, #1
 800130a:	4b12      	ldr	r3, [pc, #72]	; (8001354 <main+0x568>)
 800130c:	701a      	strb	r2, [r3, #0]
							  button = 0;
 800130e:	2200      	movs	r2, #0
 8001310:	4b0c      	ldr	r3, [pc, #48]	; (8001344 <main+0x558>)
 8001312:	701a      	strb	r2, [r3, #0]
 8001314:	e73d      	b.n	8001192 <main+0x3a6>
									  if (!(ledMode == 2))
 8001316:	2b02      	cmp	r3, #2
 8001318:	d001      	beq.n	800131e <main+0x532>
										  	  ws28xx_fadeGreen();
 800131a:	f000 facf 	bl	80018bc <ws28xx_fadeGreen>
									  if(!strcmp(Rx_data,"X05\r"))
 800131e:	490e      	ldr	r1, [pc, #56]	; (8001358 <main+0x56c>)
 8001320:	480e      	ldr	r0, [pc, #56]	; (800135c <main+0x570>)
 8001322:	f7fe fef1 	bl	8000108 <strcmp>
 8001326:	9001      	str	r0, [sp, #4]
 8001328:	2800      	cmp	r0, #0
 800132a:	d1de      	bne.n	80012ea <main+0x4fe>
										  	  strcpy(Rx_data, "    ");
 800132c:	490c      	ldr	r1, [pc, #48]	; (8001360 <main+0x574>)
 800132e:	480b      	ldr	r0, [pc, #44]	; (800135c <main+0x570>)
 8001330:	f002 fa8d 	bl	800384e <strcpy>
											  timer = 0;
 8001334:	9b01      	ldr	r3, [sp, #4]
 8001336:	e7d7      	b.n	80012e8 <main+0x4fc>
								  ws28xx_fadeGreen();
 8001338:	f000 fac0 	bl	80018bc <ws28xx_fadeGreen>
 800133c:	e7df      	b.n	80012fe <main+0x512>
 800133e:	46c0      	nop			; (mov r8, r8)
 8001340:	20000108 	.word	0x20000108
 8001344:	200000f8 	.word	0x200000f8
 8001348:	200000fc 	.word	0x200000fc
 800134c:	200000f1 	.word	0x200000f1
 8001350:	200000f2 	.word	0x200000f2
 8001354:	200000fa 	.word	0x200000fa
 8001358:	08003aa2 	.word	0x08003aa2
 800135c:	200000f3 	.word	0x200000f3
 8001360:	08003a9a 	.word	0x08003a9a

08001364 <setButtonPressed>:



void setButtonPressed()
{
	button = 1;
 8001364:	2201      	movs	r2, #1
 8001366:	4b01      	ldr	r3, [pc, #4]	; (800136c <setButtonPressed+0x8>)
 8001368:	701a      	strb	r2, [r3, #0]
}
 800136a:	4770      	bx	lr
 800136c:	200000f8 	.word	0x200000f8

08001370 <setTimerReset>:

void setTimerReset()
{
 8001370:	b510      	push	{r4, lr}
	if (timer > 0)
 8001372:	4a06      	ldr	r2, [pc, #24]	; (800138c <setTimerReset+0x1c>)
 8001374:	7813      	ldrb	r3, [r2, #0]
 8001376:	2b00      	cmp	r3, #0
 8001378:	d004      	beq.n	8001384 <setTimerReset+0x14>
	{
		timer--;
 800137a:	7813      	ldrb	r3, [r2, #0]
 800137c:	3b01      	subs	r3, #1
 800137e:	b2db      	uxtb	r3, r3
 8001380:	7013      	strb	r3, [r2, #0]
	}
	else
	{
		HAL_TIM_Base_Stop_IT(&htim16);
	}
}
 8001382:	bd10      	pop	{r4, pc}
		HAL_TIM_Base_Stop_IT(&htim16);
 8001384:	4802      	ldr	r0, [pc, #8]	; (8001390 <setTimerReset+0x20>)
 8001386:	f001 fcb7 	bl	8002cf8 <HAL_TIM_Base_Stop_IT>
}
 800138a:	e7fa      	b.n	8001382 <setTimerReset+0x12>
 800138c:	200000f2 	.word	0x200000f2
 8001390:	200002b4 	.word	0x200002b4

08001394 <Error_Handler>:
{
  /* USER CODE BEGIN Error_Handler_Debug */
  /* User can add his own implementation to report the HAL error return state */

  /* USER CODE END Error_Handler_Debug */
}
 8001394:	4770      	bx	lr
	...

08001398 <HAL_MspInit>:
{
  /* USER CODE BEGIN MspInit 0 */

  /* USER CODE END MspInit 0 */

  __HAL_RCC_SYSCFG_CLK_ENABLE();
 8001398:	2001      	movs	r0, #1
 800139a:	4b0a      	ldr	r3, [pc, #40]	; (80013c4 <HAL_MspInit+0x2c>)
{
 800139c:	b082      	sub	sp, #8
  __HAL_RCC_SYSCFG_CLK_ENABLE();
 800139e:	6999      	ldr	r1, [r3, #24]
 80013a0:	4301      	orrs	r1, r0
 80013a2:	6199      	str	r1, [r3, #24]
  __HAL_RCC_PWR_CLK_ENABLE();
 80013a4:	2180      	movs	r1, #128	; 0x80
  __HAL_RCC_SYSCFG_CLK_ENABLE();
 80013a6:	699a      	ldr	r2, [r3, #24]
  __HAL_RCC_PWR_CLK_ENABLE();
 80013a8:	0549      	lsls	r1, r1, #21
  __HAL_RCC_SYSCFG_CLK_ENABLE();
 80013aa:	4002      	ands	r2, r0
 80013ac:	9200      	str	r2, [sp, #0]
 80013ae:	9a00      	ldr	r2, [sp, #0]
  __HAL_RCC_PWR_CLK_ENABLE();
 80013b0:	69da      	ldr	r2, [r3, #28]
 80013b2:	430a      	orrs	r2, r1
 80013b4:	61da      	str	r2, [r3, #28]
 80013b6:	69db      	ldr	r3, [r3, #28]
 80013b8:	400b      	ands	r3, r1
 80013ba:	9301      	str	r3, [sp, #4]
 80013bc:	9b01      	ldr	r3, [sp, #4]
  /* System interrupt init*/

  /* USER CODE BEGIN MspInit 1 */

  /* USER CODE END MspInit 1 */
}
 80013be:	b002      	add	sp, #8
 80013c0:	4770      	bx	lr
 80013c2:	46c0      	nop			; (mov r8, r8)
 80013c4:	40021000 	.word	0x40021000

080013c8 <HAL_ADC_MspInit>:
* This function configures the hardware resources used in this example
* @param hadc: ADC handle pointer
* @retval None
*/
void HAL_ADC_MspInit(ADC_HandleTypeDef* hadc)
{
 80013c8:	b510      	push	{r4, lr}
 80013ca:	0004      	movs	r4, r0
 80013cc:	b088      	sub	sp, #32
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 80013ce:	2214      	movs	r2, #20
 80013d0:	2100      	movs	r1, #0
 80013d2:	a803      	add	r0, sp, #12
 80013d4:	f002 fa33 	bl	800383e <memset>
  if(hadc->Instance==ADC1)
 80013d8:	4b10      	ldr	r3, [pc, #64]	; (800141c <HAL_ADC_MspInit+0x54>)
 80013da:	6822      	ldr	r2, [r4, #0]
 80013dc:	429a      	cmp	r2, r3
 80013de:	d11a      	bne.n	8001416 <HAL_ADC_MspInit+0x4e>
  {
  /* USER CODE BEGIN ADC1_MspInit 0 */

  /* USER CODE END ADC1_MspInit 0 */
    /* Peripheral clock enable */
    __HAL_RCC_ADC1_CLK_ENABLE();
 80013e0:	2080      	movs	r0, #128	; 0x80
 80013e2:	4b0f      	ldr	r3, [pc, #60]	; (8001420 <HAL_ADC_MspInit+0x58>)
 80013e4:	0080      	lsls	r0, r0, #2
 80013e6:	6999      	ldr	r1, [r3, #24]
 80013e8:	4301      	orrs	r1, r0
 80013ea:	6199      	str	r1, [r3, #24]
  
    __HAL_RCC_GPIOB_CLK_ENABLE();
 80013ec:	2180      	movs	r1, #128	; 0x80
    __HAL_RCC_ADC1_CLK_ENABLE();
 80013ee:	699a      	ldr	r2, [r3, #24]
    __HAL_RCC_GPIOB_CLK_ENABLE();
 80013f0:	02c9      	lsls	r1, r1, #11
    __HAL_RCC_ADC1_CLK_ENABLE();
 80013f2:	4002      	ands	r2, r0
 80013f4:	9201      	str	r2, [sp, #4]
 80013f6:	9a01      	ldr	r2, [sp, #4]
    __HAL_RCC_GPIOB_CLK_ENABLE();
 80013f8:	695a      	ldr	r2, [r3, #20]
    PB1     ------> ADC_IN9 
    */
    GPIO_InitStruct.Pin = ADC_IN_Pin;
    GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    HAL_GPIO_Init(ADC_IN_GPIO_Port, &GPIO_InitStruct);
 80013fa:	480a      	ldr	r0, [pc, #40]	; (8001424 <HAL_ADC_MspInit+0x5c>)
    __HAL_RCC_GPIOB_CLK_ENABLE();
 80013fc:	430a      	orrs	r2, r1
 80013fe:	615a      	str	r2, [r3, #20]
 8001400:	695b      	ldr	r3, [r3, #20]
 8001402:	400b      	ands	r3, r1
 8001404:	9302      	str	r3, [sp, #8]
 8001406:	9b02      	ldr	r3, [sp, #8]
    GPIO_InitStruct.Pin = ADC_IN_Pin;
 8001408:	2302      	movs	r3, #2
    HAL_GPIO_Init(ADC_IN_GPIO_Port, &GPIO_InitStruct);
 800140a:	a903      	add	r1, sp, #12
    GPIO_InitStruct.Pin = ADC_IN_Pin;
 800140c:	9303      	str	r3, [sp, #12]
    GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
 800140e:	3301      	adds	r3, #1
 8001410:	9304      	str	r3, [sp, #16]
    HAL_GPIO_Init(ADC_IN_GPIO_Port, &GPIO_InitStruct);
 8001412:	f000 fe99 	bl	8002148 <HAL_GPIO_Init>
  /* USER CODE BEGIN ADC1_MspInit 1 */

  /* USER CODE END ADC1_MspInit 1 */
  }

}
 8001416:	b008      	add	sp, #32
 8001418:	bd10      	pop	{r4, pc}
 800141a:	46c0      	nop			; (mov r8, r8)
 800141c:	40012400 	.word	0x40012400
 8001420:	40021000 	.word	0x40021000
 8001424:	48000400 	.word	0x48000400

08001428 <HAL_SPI_MspInit>:
* This function configures the hardware resources used in this example
* @param hspi: SPI handle pointer
* @retval None
*/
void HAL_SPI_MspInit(SPI_HandleTypeDef* hspi)
{
 8001428:	b530      	push	{r4, r5, lr}
 800142a:	0005      	movs	r5, r0
 800142c:	b089      	sub	sp, #36	; 0x24
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 800142e:	2214      	movs	r2, #20
 8001430:	2100      	movs	r1, #0
 8001432:	a803      	add	r0, sp, #12
 8001434:	f002 fa03 	bl	800383e <memset>
  if(hspi->Instance==SPI1)
 8001438:	4b1c      	ldr	r3, [pc, #112]	; (80014ac <HAL_SPI_MspInit+0x84>)
 800143a:	682a      	ldr	r2, [r5, #0]
 800143c:	429a      	cmp	r2, r3
 800143e:	d133      	bne.n	80014a8 <HAL_SPI_MspInit+0x80>
  {
  /* USER CODE BEGIN SPI1_MspInit 0 */

  /* USER CODE END SPI1_MspInit 0 */
    /* Peripheral clock enable */
    __HAL_RCC_SPI1_CLK_ENABLE();
 8001440:	2080      	movs	r0, #128	; 0x80
 8001442:	4b1b      	ldr	r3, [pc, #108]	; (80014b0 <HAL_SPI_MspInit+0x88>)
 8001444:	0140      	lsls	r0, r0, #5
 8001446:	6999      	ldr	r1, [r3, #24]
 8001448:	4301      	orrs	r1, r0
 800144a:	6199      	str	r1, [r3, #24]
  
    __HAL_RCC_GPIOA_CLK_ENABLE();
 800144c:	2180      	movs	r1, #128	; 0x80
    __HAL_RCC_SPI1_CLK_ENABLE();
 800144e:	699a      	ldr	r2, [r3, #24]
    __HAL_RCC_GPIOA_CLK_ENABLE();
 8001450:	0289      	lsls	r1, r1, #10
    __HAL_RCC_SPI1_CLK_ENABLE();
 8001452:	4002      	ands	r2, r0
 8001454:	9201      	str	r2, [sp, #4]
 8001456:	9a01      	ldr	r2, [sp, #4]
    __HAL_RCC_GPIOA_CLK_ENABLE();
 8001458:	695a      	ldr	r2, [r3, #20]
    GPIO_InitStruct.Pin = GPIO_PIN_5|RGB_MCU_OUT_Pin;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
    GPIO_InitStruct.Alternate = GPIO_AF0_SPI1;
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 800145a:	2090      	movs	r0, #144	; 0x90
    __HAL_RCC_GPIOA_CLK_ENABLE();
 800145c:	430a      	orrs	r2, r1
 800145e:	615a      	str	r2, [r3, #20]
 8001460:	695b      	ldr	r3, [r3, #20]
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8001462:	05c0      	lsls	r0, r0, #23
    __HAL_RCC_GPIOA_CLK_ENABLE();
 8001464:	400b      	ands	r3, r1
 8001466:	9302      	str	r3, [sp, #8]
 8001468:	9b02      	ldr	r3, [sp, #8]
    GPIO_InitStruct.Pin = GPIO_PIN_5|RGB_MCU_OUT_Pin;
 800146a:	23a0      	movs	r3, #160	; 0xa0
 800146c:	9303      	str	r3, [sp, #12]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 800146e:	3b9e      	subs	r3, #158	; 0x9e
 8001470:	9304      	str	r3, [sp, #16]
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8001472:	a903      	add	r1, sp, #12
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
 8001474:	3301      	adds	r3, #1
 8001476:	9306      	str	r3, [sp, #24]
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8001478:	f000 fe66 	bl	8002148 <HAL_GPIO_Init>

    /* SPI1 DMA Init */
    /* SPI1_TX Init */
    hdma_spi1_tx.Instance = DMA1_Channel3;
 800147c:	4c0d      	ldr	r4, [pc, #52]	; (80014b4 <HAL_SPI_MspInit+0x8c>)
 800147e:	4b0e      	ldr	r3, [pc, #56]	; (80014b8 <HAL_SPI_MspInit+0x90>)
    hdma_spi1_tx.Init.Direction = DMA_MEMORY_TO_PERIPH;
    hdma_spi1_tx.Init.PeriphInc = DMA_PINC_DISABLE;
    hdma_spi1_tx.Init.MemInc = DMA_MINC_ENABLE;
 8001480:	2280      	movs	r2, #128	; 0x80
    hdma_spi1_tx.Instance = DMA1_Channel3;
 8001482:	6023      	str	r3, [r4, #0]
    hdma_spi1_tx.Init.Direction = DMA_MEMORY_TO_PERIPH;
 8001484:	2310      	movs	r3, #16
 8001486:	6063      	str	r3, [r4, #4]
    hdma_spi1_tx.Init.PeriphInc = DMA_PINC_DISABLE;
 8001488:	2300      	movs	r3, #0
    hdma_spi1_tx.Init.PeriphDataAlignment = DMA_PDATAALIGN_BYTE;
    hdma_spi1_tx.Init.MemDataAlignment = DMA_MDATAALIGN_BYTE;
    hdma_spi1_tx.Init.Mode = DMA_NORMAL;
    hdma_spi1_tx.Init.Priority = DMA_PRIORITY_LOW;
    if (HAL_DMA_Init(&hdma_spi1_tx) != HAL_OK)
 800148a:	0020      	movs	r0, r4
    hdma_spi1_tx.Init.PeriphInc = DMA_PINC_DISABLE;
 800148c:	60a3      	str	r3, [r4, #8]
    hdma_spi1_tx.Init.MemInc = DMA_MINC_ENABLE;
 800148e:	60e2      	str	r2, [r4, #12]
    hdma_spi1_tx.Init.PeriphDataAlignment = DMA_PDATAALIGN_BYTE;
 8001490:	6123      	str	r3, [r4, #16]
    hdma_spi1_tx.Init.MemDataAlignment = DMA_MDATAALIGN_BYTE;
 8001492:	6163      	str	r3, [r4, #20]
    hdma_spi1_tx.Init.Mode = DMA_NORMAL;
 8001494:	61a3      	str	r3, [r4, #24]
    hdma_spi1_tx.Init.Priority = DMA_PRIORITY_LOW;
 8001496:	61e3      	str	r3, [r4, #28]
    if (HAL_DMA_Init(&hdma_spi1_tx) != HAL_OK)
 8001498:	f000 fc66 	bl	8001d68 <HAL_DMA_Init>
 800149c:	2800      	cmp	r0, #0
 800149e:	d001      	beq.n	80014a4 <HAL_SPI_MspInit+0x7c>
    {
      Error_Handler();
 80014a0:	f7ff ff78 	bl	8001394 <Error_Handler>
    }

    __HAL_LINKDMA(hspi,hdmatx,hdma_spi1_tx);
 80014a4:	656c      	str	r4, [r5, #84]	; 0x54
 80014a6:	6265      	str	r5, [r4, #36]	; 0x24
  /* USER CODE BEGIN SPI1_MspInit 1 */

  /* USER CODE END SPI1_MspInit 1 */
  }

}
 80014a8:	b009      	add	sp, #36	; 0x24
 80014aa:	bd30      	pop	{r4, r5, pc}
 80014ac:	40013000 	.word	0x40013000
 80014b0:	40021000 	.word	0x40021000
 80014b4:	200002f4 	.word	0x200002f4
 80014b8:	40020030 	.word	0x40020030

080014bc <HAL_TIM_Base_MspInit>:
* This function configures the hardware resources used in this example
* @param htim_base: TIM_Base handle pointer
* @retval None
*/
void HAL_TIM_Base_MspInit(TIM_HandleTypeDef* htim_base)
{
 80014bc:	b51f      	push	{r0, r1, r2, r3, r4, lr}
  if(htim_base->Instance==TIM1)
 80014be:	6803      	ldr	r3, [r0, #0]
 80014c0:	4a1c      	ldr	r2, [pc, #112]	; (8001534 <HAL_TIM_Base_MspInit+0x78>)
 80014c2:	4293      	cmp	r3, r2
 80014c4:	d112      	bne.n	80014ec <HAL_TIM_Base_MspInit+0x30>
  {
  /* USER CODE BEGIN TIM1_MspInit 0 */

  /* USER CODE END TIM1_MspInit 0 */
    /* Peripheral clock enable */
    __HAL_RCC_TIM1_CLK_ENABLE();
 80014c6:	2080      	movs	r0, #128	; 0x80
 80014c8:	4a1b      	ldr	r2, [pc, #108]	; (8001538 <HAL_TIM_Base_MspInit+0x7c>)
 80014ca:	0100      	lsls	r0, r0, #4
 80014cc:	6991      	ldr	r1, [r2, #24]
 80014ce:	4301      	orrs	r1, r0
 80014d0:	6191      	str	r1, [r2, #24]
 80014d2:	6993      	ldr	r3, [r2, #24]
    /* TIM1 interrupt Init */
    HAL_NVIC_SetPriority(TIM1_BRK_UP_TRG_COM_IRQn, 0, 0);
 80014d4:	2200      	movs	r2, #0
    __HAL_RCC_TIM1_CLK_ENABLE();
 80014d6:	4003      	ands	r3, r0
 80014d8:	9301      	str	r3, [sp, #4]
    HAL_NVIC_SetPriority(TIM1_BRK_UP_TRG_COM_IRQn, 0, 0);
 80014da:	200d      	movs	r0, #13
 80014dc:	0011      	movs	r1, r2
    __HAL_RCC_TIM1_CLK_ENABLE();
 80014de:	9b01      	ldr	r3, [sp, #4]
    HAL_NVIC_SetPriority(TIM1_BRK_UP_TRG_COM_IRQn, 0, 0);
 80014e0:	f000 fbd4 	bl	8001c8c <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(TIM1_BRK_UP_TRG_COM_IRQn);
 80014e4:	200d      	movs	r0, #13
  /* USER CODE END TIM16_MspInit 0 */
    /* Peripheral clock enable */
    __HAL_RCC_TIM16_CLK_ENABLE();
    /* TIM16 interrupt Init */
    HAL_NVIC_SetPriority(TIM16_IRQn, 0, 0);
    HAL_NVIC_EnableIRQ(TIM16_IRQn);
 80014e6:	f000 fbfb 	bl	8001ce0 <HAL_NVIC_EnableIRQ>
  /* USER CODE BEGIN TIM16_MspInit 1 */

  /* USER CODE END TIM16_MspInit 1 */
  }

}
 80014ea:	e00c      	b.n	8001506 <HAL_TIM_Base_MspInit+0x4a>
  else if(htim_base->Instance==TIM14)
 80014ec:	4a13      	ldr	r2, [pc, #76]	; (800153c <HAL_TIM_Base_MspInit+0x80>)
 80014ee:	4293      	cmp	r3, r2
 80014f0:	d10b      	bne.n	800150a <HAL_TIM_Base_MspInit+0x4e>
    __HAL_RCC_TIM14_CLK_ENABLE();
 80014f2:	2080      	movs	r0, #128	; 0x80
 80014f4:	4a10      	ldr	r2, [pc, #64]	; (8001538 <HAL_TIM_Base_MspInit+0x7c>)
 80014f6:	0040      	lsls	r0, r0, #1
 80014f8:	69d1      	ldr	r1, [r2, #28]
 80014fa:	4301      	orrs	r1, r0
 80014fc:	61d1      	str	r1, [r2, #28]
 80014fe:	69d3      	ldr	r3, [r2, #28]
 8001500:	4003      	ands	r3, r0
 8001502:	9302      	str	r3, [sp, #8]
 8001504:	9b02      	ldr	r3, [sp, #8]
}
 8001506:	b005      	add	sp, #20
 8001508:	bd00      	pop	{pc}
  else if(htim_base->Instance==TIM16)
 800150a:	4a0d      	ldr	r2, [pc, #52]	; (8001540 <HAL_TIM_Base_MspInit+0x84>)
 800150c:	4293      	cmp	r3, r2
 800150e:	d1fa      	bne.n	8001506 <HAL_TIM_Base_MspInit+0x4a>
    __HAL_RCC_TIM16_CLK_ENABLE();
 8001510:	2080      	movs	r0, #128	; 0x80
 8001512:	4a09      	ldr	r2, [pc, #36]	; (8001538 <HAL_TIM_Base_MspInit+0x7c>)
 8001514:	0280      	lsls	r0, r0, #10
 8001516:	6991      	ldr	r1, [r2, #24]
 8001518:	4301      	orrs	r1, r0
 800151a:	6191      	str	r1, [r2, #24]
 800151c:	6993      	ldr	r3, [r2, #24]
    HAL_NVIC_SetPriority(TIM16_IRQn, 0, 0);
 800151e:	2200      	movs	r2, #0
    __HAL_RCC_TIM16_CLK_ENABLE();
 8001520:	4003      	ands	r3, r0
 8001522:	9303      	str	r3, [sp, #12]
    HAL_NVIC_SetPriority(TIM16_IRQn, 0, 0);
 8001524:	2015      	movs	r0, #21
 8001526:	0011      	movs	r1, r2
    __HAL_RCC_TIM16_CLK_ENABLE();
 8001528:	9b03      	ldr	r3, [sp, #12]
    HAL_NVIC_SetPriority(TIM16_IRQn, 0, 0);
 800152a:	f000 fbaf 	bl	8001c8c <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(TIM16_IRQn);
 800152e:	2015      	movs	r0, #21
 8001530:	e7d9      	b.n	80014e6 <HAL_TIM_Base_MspInit+0x2a>
 8001532:	46c0      	nop			; (mov r8, r8)
 8001534:	40012c00 	.word	0x40012c00
 8001538:	40021000 	.word	0x40021000
 800153c:	40002000 	.word	0x40002000
 8001540:	40014400 	.word	0x40014400

08001544 <HAL_UART_MspInit>:
* This function configures the hardware resources used in this example
* @param huart: UART handle pointer
* @retval None
*/
void HAL_UART_MspInit(UART_HandleTypeDef* huart)
{
 8001544:	b510      	push	{r4, lr}
 8001546:	0004      	movs	r4, r0
 8001548:	b088      	sub	sp, #32
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 800154a:	2214      	movs	r2, #20
 800154c:	2100      	movs	r1, #0
 800154e:	a803      	add	r0, sp, #12
 8001550:	f002 f975 	bl	800383e <memset>
  if(huart->Instance==USART1)
 8001554:	4b13      	ldr	r3, [pc, #76]	; (80015a4 <HAL_UART_MspInit+0x60>)
 8001556:	6822      	ldr	r2, [r4, #0]
 8001558:	429a      	cmp	r2, r3
 800155a:	d120      	bne.n	800159e <HAL_UART_MspInit+0x5a>
  {
  /* USER CODE BEGIN USART1_MspInit 0 */

  /* USER CODE END USART1_MspInit 0 */
    /* Peripheral clock enable */
    __HAL_RCC_USART1_CLK_ENABLE();
 800155c:	2080      	movs	r0, #128	; 0x80
 800155e:	4b12      	ldr	r3, [pc, #72]	; (80015a8 <HAL_UART_MspInit+0x64>)
 8001560:	01c0      	lsls	r0, r0, #7
 8001562:	6999      	ldr	r1, [r3, #24]
 8001564:	4301      	orrs	r1, r0
 8001566:	6199      	str	r1, [r3, #24]
  
    __HAL_RCC_GPIOA_CLK_ENABLE();
 8001568:	2180      	movs	r1, #128	; 0x80
    __HAL_RCC_USART1_CLK_ENABLE();
 800156a:	699a      	ldr	r2, [r3, #24]
    __HAL_RCC_GPIOA_CLK_ENABLE();
 800156c:	0289      	lsls	r1, r1, #10
    __HAL_RCC_USART1_CLK_ENABLE();
 800156e:	4002      	ands	r2, r0
 8001570:	9201      	str	r2, [sp, #4]
 8001572:	9a01      	ldr	r2, [sp, #4]
    __HAL_RCC_GPIOA_CLK_ENABLE();
 8001574:	695a      	ldr	r2, [r3, #20]
    GPIO_InitStruct.Pin = GPIO_PIN_9|GPIO_PIN_10;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
    GPIO_InitStruct.Alternate = GPIO_AF1_USART1;
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8001576:	2090      	movs	r0, #144	; 0x90
    __HAL_RCC_GPIOA_CLK_ENABLE();
 8001578:	430a      	orrs	r2, r1
 800157a:	615a      	str	r2, [r3, #20]
 800157c:	695b      	ldr	r3, [r3, #20]
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 800157e:	05c0      	lsls	r0, r0, #23
    __HAL_RCC_GPIOA_CLK_ENABLE();
 8001580:	400b      	ands	r3, r1
 8001582:	9302      	str	r3, [sp, #8]
 8001584:	9b02      	ldr	r3, [sp, #8]
    GPIO_InitStruct.Pin = GPIO_PIN_9|GPIO_PIN_10;
 8001586:	23c0      	movs	r3, #192	; 0xc0
 8001588:	00db      	lsls	r3, r3, #3
 800158a:	9303      	str	r3, [sp, #12]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 800158c:	2302      	movs	r3, #2
 800158e:	9304      	str	r3, [sp, #16]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
 8001590:	3301      	adds	r3, #1
 8001592:	9306      	str	r3, [sp, #24]
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8001594:	a903      	add	r1, sp, #12
    GPIO_InitStruct.Alternate = GPIO_AF1_USART1;
 8001596:	3b02      	subs	r3, #2
 8001598:	9307      	str	r3, [sp, #28]
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 800159a:	f000 fdd5 	bl	8002148 <HAL_GPIO_Init>
  /* USER CODE BEGIN USART1_MspInit 1 */

  /* USER CODE END USART1_MspInit 1 */
  }

}
 800159e:	b008      	add	sp, #32
 80015a0:	bd10      	pop	{r4, pc}
 80015a2:	46c0      	nop			; (mov r8, r8)
 80015a4:	40013800 	.word	0x40013800
 80015a8:	40021000 	.word	0x40021000

080015ac <NMI_Handler>:

  /* USER CODE END NonMaskableInt_IRQn 0 */
  /* USER CODE BEGIN NonMaskableInt_IRQn 1 */

  /* USER CODE END NonMaskableInt_IRQn 1 */
}
 80015ac:	4770      	bx	lr

080015ae <HardFault_Handler>:

/**
  * @brief This function handles Hard fault interrupt.
  */
void HardFault_Handler(void)
{
 80015ae:	e7fe      	b.n	80015ae <HardFault_Handler>

080015b0 <SVC_Handler>:
 80015b0:	4770      	bx	lr

080015b2 <PendSV_Handler>:
 80015b2:	4770      	bx	lr

080015b4 <SysTick_Handler>:

/**
  * @brief This function handles System tick timer.
  */
void SysTick_Handler(void)
{
 80015b4:	b510      	push	{r4, lr}
  /* USER CODE BEGIN SysTick_IRQn 0 */

  /* USER CODE END SysTick_IRQn 0 */
  HAL_IncTick();
 80015b6:	f000 fa21 	bl	80019fc <HAL_IncTick>
  /* USER CODE BEGIN SysTick_IRQn 1 */

  /* USER CODE END SysTick_IRQn 1 */
}
 80015ba:	bd10      	pop	{r4, pc}

080015bc <EXTI0_1_IRQHandler>:

/**
  * @brief This function handles EXTI line 0 and 1 interrupts.
  */
void EXTI0_1_IRQHandler(void)
{
 80015bc:	b510      	push	{r4, lr}
  /* USER CODE BEGIN EXTI0_1_IRQn 0 */

  /* USER CODE END EXTI0_1_IRQn 0 */
  HAL_GPIO_EXTI_IRQHandler(GPIO_PIN_1);
 80015be:	2002      	movs	r0, #2
 80015c0:	f000 fe80 	bl	80022c4 <HAL_GPIO_EXTI_IRQHandler>
  /* USER CODE BEGIN EXTI0_1_IRQn 1 */
  setButtonPressed();
 80015c4:	f7ff fece 	bl	8001364 <setButtonPressed>
  /* USER CODE END EXTI0_1_IRQn 1 */
}
 80015c8:	bd10      	pop	{r4, pc}
	...

080015cc <DMA1_Channel2_3_IRQHandler>:

/**
  * @brief This function handles DMA1 channel 2 and 3 interrupts.
  */
void DMA1_Channel2_3_IRQHandler(void)
{
 80015cc:	b510      	push	{r4, lr}
  /* USER CODE BEGIN DMA1_Channel2_3_IRQn 0 */

  /* USER CODE END DMA1_Channel2_3_IRQn 0 */
  HAL_DMA_IRQHandler(&hdma_spi1_tx);
 80015ce:	4802      	ldr	r0, [pc, #8]	; (80015d8 <DMA1_Channel2_3_IRQHandler+0xc>)
 80015d0:	f000 fc5b 	bl	8001e8a <HAL_DMA_IRQHandler>
  /* USER CODE BEGIN DMA1_Channel2_3_IRQn 1 */

  /* USER CODE END DMA1_Channel2_3_IRQn 1 */
}
 80015d4:	bd10      	pop	{r4, pc}
 80015d6:	46c0      	nop			; (mov r8, r8)
 80015d8:	200002f4 	.word	0x200002f4

080015dc <TIM1_BRK_UP_TRG_COM_IRQHandler>:

/**
  * @brief This function handles TIM1 break, update, trigger and commutation interrupts.
  */
void TIM1_BRK_UP_TRG_COM_IRQHandler(void)
{
 80015dc:	b510      	push	{r4, lr}
  /* USER CODE BEGIN TIM1_BRK_UP_TRG_COM_IRQn 0 */

  /* USER CODE END TIM1_BRK_UP_TRG_COM_IRQn 0 */
  HAL_TIM_IRQHandler(&htim1);
 80015de:	4802      	ldr	r0, [pc, #8]	; (80015e8 <TIM1_BRK_UP_TRG_COM_IRQHandler+0xc>)
 80015e0:	f001 fba5 	bl	8002d2e <HAL_TIM_IRQHandler>
  /* USER CODE BEGIN TIM1_BRK_UP_TRG_COM_IRQn 1 */

  /* USER CODE END TIM1_BRK_UP_TRG_COM_IRQn 1 */
}
 80015e4:	bd10      	pop	{r4, pc}
 80015e6:	46c0      	nop			; (mov r8, r8)
 80015e8:	20000190 	.word	0x20000190

080015ec <TIM1_CC_IRQHandler>:
 80015ec:	b510      	push	{r4, lr}
 80015ee:	f7ff fff5 	bl	80015dc <TIM1_BRK_UP_TRG_COM_IRQHandler>
 80015f2:	bd10      	pop	{r4, pc}

080015f4 <TIM14_IRQHandler>:

/**
  * @brief This function handles TIM14 global interrupt.
  */
void TIM14_IRQHandler(void)
{
 80015f4:	b510      	push	{r4, lr}
  /* USER CODE BEGIN TIM14_IRQn 0 */
		irmp_ISR();
 80015f6:	f7fe ff11 	bl	800041c <irmp_ISR>
  /* USER CODE END TIM14_IRQn 0 */
  HAL_TIM_IRQHandler(&htim14);
 80015fa:	4802      	ldr	r0, [pc, #8]	; (8001604 <TIM14_IRQHandler+0x10>)
 80015fc:	f001 fb97 	bl	8002d2e <HAL_TIM_IRQHandler>
  /* USER CODE BEGIN TIM14_IRQn 1 */

  /* USER CODE END TIM14_IRQn 1 */
}
 8001600:	bd10      	pop	{r4, pc}
 8001602:	46c0      	nop			; (mov r8, r8)
 8001604:	20000234 	.word	0x20000234

08001608 <TIM16_IRQHandler>:

/**
  * @brief This function handles TIM16 global interrupt.
  */
void TIM16_IRQHandler(void)
{
 8001608:	b510      	push	{r4, lr}
  /* USER CODE BEGIN TIM16_IRQn 0 */

  /* USER CODE END TIM16_IRQn 0 */
  HAL_TIM_IRQHandler(&htim16);
 800160a:	4803      	ldr	r0, [pc, #12]	; (8001618 <TIM16_IRQHandler+0x10>)
 800160c:	f001 fb8f 	bl	8002d2e <HAL_TIM_IRQHandler>
  /* USER CODE BEGIN TIM16_IRQn 1 */
  setTimerReset();
 8001610:	f7ff feae 	bl	8001370 <setTimerReset>
  /* USER CODE END TIM16_IRQn 1 */
}
 8001614:	bd10      	pop	{r4, pc}
 8001616:	46c0      	nop			; (mov r8, r8)
 8001618:	200002b4 	.word	0x200002b4

0800161c <USART1_IRQHandler>:

/**
  * @brief This function handles USART1 global interrupt.
  */
void USART1_IRQHandler(void)
{
 800161c:	b570      	push	{r4, r5, r6, lr}
  /* USER CODE BEGIN USART1_IRQn 0 */

  /* USER CODE END USART1_IRQn 0 */
  HAL_UART_IRQHandler(&huart1);
 800161e:	4c0a      	ldr	r4, [pc, #40]	; (8001648 <USART1_IRQHandler+0x2c>)
 8001620:	0020      	movs	r0, r4
 8001622:	f001 fe21 	bl	8003268 <HAL_UART_IRQHandler>
  /* USER CODE BEGIN USART1_IRQn 1 */


  Rx_data[RxCounter] = RxBuffer;
 8001626:	4a09      	ldr	r2, [pc, #36]	; (800164c <USART1_IRQHandler+0x30>)
 8001628:	4909      	ldr	r1, [pc, #36]	; (8001650 <USART1_IRQHandler+0x34>)
 800162a:	7813      	ldrb	r3, [r2, #0]
 800162c:	7808      	ldrb	r0, [r1, #0]
 800162e:	4d09      	ldr	r5, [pc, #36]	; (8001654 <USART1_IRQHandler+0x38>)
 8001630:	54e8      	strb	r0, [r5, r3]
  RxCounter++;
 8001632:	3301      	adds	r3, #1
  if (RxBuffer == '\r')
 8001634:	280d      	cmp	r0, #13
 8001636:	d100      	bne.n	800163a <USART1_IRQHandler+0x1e>
  {
	  RxCounter = 0;
 8001638:	2300      	movs	r3, #0
 800163a:	7013      	strb	r3, [r2, #0]
  }
  HAL_UART_Receive_IT(&huart1, &RxBuffer, 1);
 800163c:	0020      	movs	r0, r4
 800163e:	2201      	movs	r2, #1
 8001640:	f001 fd56 	bl	80030f0 <HAL_UART_Receive_IT>
  /* USER CODE END USART1_IRQn 1 */
}
 8001644:	bd70      	pop	{r4, r5, r6, pc}
 8001646:	46c0      	nop			; (mov r8, r8)
 8001648:	20000110 	.word	0x20000110
 800164c:	200000f7 	.word	0x200000f7
 8001650:	200000f9 	.word	0x200000f9
 8001654:	200000f3 	.word	0x200000f3

08001658 <SystemInit>:
                         before branch to main program. This call is made inside
                         the "startup_stm32f0xx.s" file.
                         User can setups the default system clock (System clock source, PLL Multiplier
                         and Divider factors, AHB/APBx prescalers and Flash settings).
   */
}
 8001658:	4770      	bx	lr
	...

0800165c <Reset_Handler>:

  .section .text.Reset_Handler
  .weak Reset_Handler
  .type Reset_Handler, %function
Reset_Handler:
  ldr   r0, =_estack
 800165c:	480d      	ldr	r0, [pc, #52]	; (8001694 <LoopForever+0x2>)
  mov   sp, r0          /* set stack pointer */
 800165e:	4685      	mov	sp, r0

/* Copy the data segment initializers from flash to SRAM */
  ldr r0, =_sdata
 8001660:	480d      	ldr	r0, [pc, #52]	; (8001698 <LoopForever+0x6>)
  ldr r1, =_edata
 8001662:	490e      	ldr	r1, [pc, #56]	; (800169c <LoopForever+0xa>)
  ldr r2, =_sidata
 8001664:	4a0e      	ldr	r2, [pc, #56]	; (80016a0 <LoopForever+0xe>)
  movs r3, #0
 8001666:	2300      	movs	r3, #0
  b LoopCopyDataInit
 8001668:	e002      	b.n	8001670 <LoopCopyDataInit>

0800166a <CopyDataInit>:

CopyDataInit:
  ldr r4, [r2, r3]
 800166a:	58d4      	ldr	r4, [r2, r3]
  str r4, [r0, r3]
 800166c:	50c4      	str	r4, [r0, r3]
  adds r3, r3, #4
 800166e:	3304      	adds	r3, #4

08001670 <LoopCopyDataInit>:

LoopCopyDataInit:
  adds r4, r0, r3
 8001670:	18c4      	adds	r4, r0, r3
  cmp r4, r1
 8001672:	428c      	cmp	r4, r1
  bcc CopyDataInit
 8001674:	d3f9      	bcc.n	800166a <CopyDataInit>
  
/* Zero fill the bss segment. */
  ldr r2, =_sbss
 8001676:	4a0b      	ldr	r2, [pc, #44]	; (80016a4 <LoopForever+0x12>)
  ldr r4, =_ebss
 8001678:	4c0b      	ldr	r4, [pc, #44]	; (80016a8 <LoopForever+0x16>)
  movs r3, #0
 800167a:	2300      	movs	r3, #0
  b LoopFillZerobss
 800167c:	e001      	b.n	8001682 <LoopFillZerobss>

0800167e <FillZerobss>:

FillZerobss:
  str  r3, [r2]
 800167e:	6013      	str	r3, [r2, #0]
  adds r2, r2, #4
 8001680:	3204      	adds	r2, #4

08001682 <LoopFillZerobss>:

LoopFillZerobss:
  cmp r2, r4
 8001682:	42a2      	cmp	r2, r4
  bcc FillZerobss
 8001684:	d3fb      	bcc.n	800167e <FillZerobss>

/* Call the clock system intitialization function.*/
  bl  SystemInit
 8001686:	f7ff ffe7 	bl	8001658 <SystemInit>
/* Call static constructors */
  bl __libc_init_array
 800168a:	f002 f8ab 	bl	80037e4 <__libc_init_array>
/* Call the application's entry point.*/
  bl main
 800168e:	f7ff fbad 	bl	8000dec <main>

08001692 <LoopForever>:

LoopForever:
    b LoopForever
 8001692:	e7fe      	b.n	8001692 <LoopForever>
  ldr   r0, =_estack
 8001694:	20001000 	.word	0x20001000
  ldr r0, =_sdata
 8001698:	20000000 	.word	0x20000000
  ldr r1, =_edata
 800169c:	20000030 	.word	0x20000030
  ldr r2, =_sidata
 80016a0:	08003acc 	.word	0x08003acc
  ldr r2, =_sbss
 80016a4:	20000030 	.word	0x20000030
  ldr r4, =_ebss
 80016a8:	20000488 	.word	0x20000488

080016ac <ADC1_IRQHandler>:
 * @retval : None
*/
    .section .text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
  b Infinite_Loop
 80016ac:	e7fe      	b.n	80016ac <ADC1_IRQHandler>
	...

080016b0 <ws28xx_fill_a_bit>:

ws28xx_Data_TypeDef	ws28xxLEDs[WS28XX_MAX_PIXEL];

///////////////////////////////////////////////////////////////////////////////////////////////////////
void	ws28xx_fill_a_bit(uint16_t bit_number,uint8_t bit_value,uint16_t buffer_nember)
{
 80016b0:	b530      	push	{r4, r5, lr}
 80016b2:	2507      	movs	r5, #7
 80016b4:	08c4      	lsrs	r4, r0, #3
 80016b6:	4385      	bics	r5, r0
 80016b8:	2001      	movs	r0, #1
 80016ba:	2348      	movs	r3, #72	; 0x48
 80016bc:	40a8      	lsls	r0, r5
 80016be:	435a      	muls	r2, r3
 80016c0:	4b05      	ldr	r3, [pc, #20]	; (80016d8 <ws28xx_fill_a_bit+0x28>)
 80016c2:	b240      	sxtb	r0, r0
 80016c4:	189a      	adds	r2, r3, r2
 80016c6:	5713      	ldrsb	r3, [r2, r4]
	uint8_t		idx_bit = 0;
	uint16_t idx_buffer = 0;
	idx_buffer =  bit_number/8;
	idx_bit =	7-(bit_number % 8);
	if(bit_value == 0)
 80016c8:	2900      	cmp	r1, #0
 80016ca:	d102      	bne.n	80016d2 <ws28xx_fill_a_bit+0x22>
		ws28xx_temp[buffer_nember][idx_buffer] = 	ws28xx_temp[buffer_nember][idx_buffer] & (~(0x01<<idx_bit)) ;
 80016cc:	4383      	bics	r3, r0
	else	
		ws28xx_temp[buffer_nember][idx_buffer] = 	ws28xx_temp[buffer_nember][idx_buffer] | (0x01<<idx_bit) ;
 80016ce:	5513      	strb	r3, [r2, r4]
}	
 80016d0:	bd30      	pop	{r4, r5, pc}
		ws28xx_temp[buffer_nember][idx_buffer] = 	ws28xx_temp[buffer_nember][idx_buffer] | (0x01<<idx_bit) ;
 80016d2:	4303      	orrs	r3, r0
 80016d4:	e7fb      	b.n	80016ce <ws28xx_fill_a_bit+0x1e>
 80016d6:	46c0      	nop			; (mov r8, r8)
 80016d8:	20000344 	.word	0x20000344

080016dc <ws28xx_set_buffer>:
///////////////////////////////////////////////////////////////////////////////////////////////////////
void	ws28xx_set_buffer(uint8_t RGB_bit_number_0_23,uint8_t bit_Value_0_1,uint16_t buffer_nember)
{	 
 80016dc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	uint16_t fill_bit=RGB_bit_number_0_23*24;
 80016de:	2518      	movs	r5, #24
{	 
 80016e0:	0016      	movs	r6, r2
	uint16_t fill_bit=RGB_bit_number_0_23*24;
 80016e2:	4345      	muls	r5, r0
	if(bit_Value_0_1 == 0)
 80016e4:	2900      	cmp	r1, #0
 80016e6:	d115      	bne.n	8001714 <ws28xx_set_buffer+0x38>
 80016e8:	002c      	movs	r4, r5
 80016ea:	1cef      	adds	r7, r5, #3
	{
		for(uint8_t i=0; i<3 ; i++)
			ws28xx_fill_a_bit(fill_bit+i,1,buffer_nember);
 80016ec:	0020      	movs	r0, r4
 80016ee:	3401      	adds	r4, #1
 80016f0:	0032      	movs	r2, r6
 80016f2:	2101      	movs	r1, #1
 80016f4:	b2a4      	uxth	r4, r4
 80016f6:	f7ff ffdb 	bl	80016b0 <ws28xx_fill_a_bit>
		for(uint8_t i=0; i<3 ; i++)
 80016fa:	42a7      	cmp	r7, r4
 80016fc:	d1f6      	bne.n	80016ec <ws28xx_set_buffer+0x10>
 80016fe:	3518      	adds	r5, #24
		for(uint8_t i=3; i<24 ; i++)
			ws28xx_fill_a_bit(fill_bit+i,0,buffer_nember);	
 8001700:	0020      	movs	r0, r4
 8001702:	3401      	adds	r4, #1
 8001704:	0032      	movs	r2, r6
 8001706:	2100      	movs	r1, #0
 8001708:	b2a4      	uxth	r4, r4
 800170a:	f7ff ffd1 	bl	80016b0 <ws28xx_fill_a_bit>
		for(uint8_t i=3; i<24 ; i++)
 800170e:	42a5      	cmp	r5, r4
 8001710:	d1f6      	bne.n	8001700 <ws28xx_set_buffer+0x24>
		for(uint8_t i=0; i<7 ; i++)
			ws28xx_fill_a_bit(fill_bit+i,1,buffer_nember);
		for(uint8_t i=7; i<24 ; i++)
			ws28xx_fill_a_bit(fill_bit+i,0,buffer_nember);	
	}
}
 8001712:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	if(bit_Value_0_1 == 0)
 8001714:	002c      	movs	r4, r5
 8001716:	1def      	adds	r7, r5, #7
			ws28xx_fill_a_bit(fill_bit+i,1,buffer_nember);
 8001718:	0020      	movs	r0, r4
 800171a:	3401      	adds	r4, #1
 800171c:	0032      	movs	r2, r6
 800171e:	2101      	movs	r1, #1
 8001720:	b2a4      	uxth	r4, r4
 8001722:	f7ff ffc5 	bl	80016b0 <ws28xx_fill_a_bit>
		for(uint8_t i=0; i<7 ; i++)
 8001726:	42bc      	cmp	r4, r7
 8001728:	d1f6      	bne.n	8001718 <ws28xx_set_buffer+0x3c>
 800172a:	3518      	adds	r5, #24
			ws28xx_fill_a_bit(fill_bit+i,0,buffer_nember);	
 800172c:	0020      	movs	r0, r4
 800172e:	3401      	adds	r4, #1
 8001730:	0032      	movs	r2, r6
 8001732:	2100      	movs	r1, #0
 8001734:	b2a4      	uxth	r4, r4
 8001736:	f7ff ffbb 	bl	80016b0 <ws28xx_fill_a_bit>
		for(uint8_t i=7; i<24 ; i++)
 800173a:	42a5      	cmp	r5, r4
 800173c:	d1f6      	bne.n	800172c <ws28xx_set_buffer+0x50>
 800173e:	e7e8      	b.n	8001712 <ws28xx_set_buffer+0x36>

08001740 <ws28xx_Put_Pixels>:
}
/////////////////////////////////////////////////////////////////////////////////////////////////////// 
///////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////
void	ws28xx_Put_Pixels(ws28xx_Data_TypeDef	*LED_Pixel,uint16_t len)
{
 8001740:	b5f0      	push	{r4, r5, r6, r7, lr}
	
	for(uint16_t x=0 ; x<len ;x++)
 8001742:	2400      	movs	r4, #0
	{
		for(int8_t i=0; i<8 ; i++)
			ws28xx_set_buffer( i+0 ,(LED_Pixel[x].G & (0x80>>i)) ,x);
 8001744:	2780      	movs	r7, #128	; 0x80
{
 8001746:	b085      	sub	sp, #20
 8001748:	9003      	str	r0, [sp, #12]
 800174a:	9102      	str	r1, [sp, #8]
 800174c:	b2a3      	uxth	r3, r4
 800174e:	9301      	str	r3, [sp, #4]
	for(uint16_t x=0 ; x<len ;x++)
 8001750:	9b02      	ldr	r3, [sp, #8]
 8001752:	42a3      	cmp	r3, r4
 8001754:	d108      	bne.n	8001768 <ws28xx_Put_Pixels+0x28>
		for(int8_t i=0; i<8 ; i++)
			ws28xx_set_buffer( i+16 ,(LED_Pixel[x].B & (0x80>>i)) ,x);

	}
	
	HAL_SPI_Transmit_DMA(WS28XX_SPI,&ws28xx_temp[0][0],(72)*len);
 8001756:	2248      	movs	r2, #72	; 0x48
 8001758:	435a      	muls	r2, r3
 800175a:	491a      	ldr	r1, [pc, #104]	; (80017c4 <ws28xx_Put_Pixels+0x84>)
 800175c:	b292      	uxth	r2, r2
 800175e:	481a      	ldr	r0, [pc, #104]	; (80017c8 <ws28xx_Put_Pixels+0x88>)
 8001760:	f001 f9e8 	bl	8002b34 <HAL_SPI_Transmit_DMA>
	
}
 8001764:	b005      	add	sp, #20
 8001766:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8001768:	2603      	movs	r6, #3
	for(uint16_t x=0 ; x<len ;x++)
 800176a:	2500      	movs	r5, #0
 800176c:	4366      	muls	r6, r4
 800176e:	9b03      	ldr	r3, [sp, #12]
 8001770:	199e      	adds	r6, r3, r6
			ws28xx_set_buffer( i+0 ,(LED_Pixel[x].G & (0x80>>i)) ,x);
 8001772:	0039      	movs	r1, r7
 8001774:	4129      	asrs	r1, r5
 8001776:	7873      	ldrb	r3, [r6, #1]
 8001778:	b2e8      	uxtb	r0, r5
 800177a:	4019      	ands	r1, r3
 800177c:	9a01      	ldr	r2, [sp, #4]
 800177e:	3501      	adds	r5, #1
 8001780:	f7ff ffac 	bl	80016dc <ws28xx_set_buffer>
		for(int8_t i=0; i<8 ; i++)
 8001784:	2d08      	cmp	r5, #8
 8001786:	d1f4      	bne.n	8001772 <ws28xx_Put_Pixels+0x32>
 8001788:	2500      	movs	r5, #0
			ws28xx_set_buffer( i+8 ,(LED_Pixel[x].R & (0x80>>i)) ,x );
 800178a:	0039      	movs	r1, r7
 800178c:	0028      	movs	r0, r5
 800178e:	4129      	asrs	r1, r5
 8001790:	7833      	ldrb	r3, [r6, #0]
 8001792:	3008      	adds	r0, #8
 8001794:	4019      	ands	r1, r3
 8001796:	b2c0      	uxtb	r0, r0
 8001798:	9a01      	ldr	r2, [sp, #4]
 800179a:	3501      	adds	r5, #1
 800179c:	f7ff ff9e 	bl	80016dc <ws28xx_set_buffer>
		for(int8_t i=0; i<8 ; i++)
 80017a0:	2d08      	cmp	r5, #8
 80017a2:	d1f2      	bne.n	800178a <ws28xx_Put_Pixels+0x4a>
 80017a4:	2500      	movs	r5, #0
			ws28xx_set_buffer( i+16 ,(LED_Pixel[x].B & (0x80>>i)) ,x);
 80017a6:	0039      	movs	r1, r7
 80017a8:	0028      	movs	r0, r5
 80017aa:	4129      	asrs	r1, r5
 80017ac:	78b3      	ldrb	r3, [r6, #2]
 80017ae:	3010      	adds	r0, #16
 80017b0:	4019      	ands	r1, r3
 80017b2:	b2c0      	uxtb	r0, r0
 80017b4:	9a01      	ldr	r2, [sp, #4]
 80017b6:	3501      	adds	r5, #1
 80017b8:	f7ff ff90 	bl	80016dc <ws28xx_set_buffer>
		for(int8_t i=0; i<8 ; i++)
 80017bc:	2d08      	cmp	r5, #8
 80017be:	d1f2      	bne.n	80017a6 <ws28xx_Put_Pixels+0x66>
 80017c0:	3401      	adds	r4, #1
 80017c2:	e7c3      	b.n	800174c <ws28xx_Put_Pixels+0xc>
 80017c4:	20000344 	.word	0x20000344
 80017c8:	200001d0 	.word	0x200001d0

080017cc <ws28xx_Update>:
/////////////////////////////////////////////////////////////////////////////////////////////////////// 
///////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////
void	ws28xx_Update(void)
{
 80017cc:	b510      	push	{r4, lr}
	
	ws28xx_Put_Pixels(ws28xxLEDs,WS28XX_MAX_PIXEL);	
 80017ce:	2104      	movs	r1, #4
 80017d0:	4801      	ldr	r0, [pc, #4]	; (80017d8 <ws28xx_Update+0xc>)
 80017d2:	f7ff ffb5 	bl	8001740 <ws28xx_Put_Pixels>
	
}
 80017d6:	bd10      	pop	{r4, pc}
 80017d8:	20000338 	.word	0x20000338

080017dc <ws28xx_SetColor>:
}
/////////////////////////////////////////////////////////////////////////////////////////////////////// 
///////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////
void	ws28xx_SetColor(uint16_t Pixel,ws28xx_Color_TypeDef Color)
{
 80017dc:	b510      	push	{r4, lr}
 80017de:	0004      	movs	r4, r0
	if(Pixel >= WS28XX_MAX_PIXEL )
 80017e0:	2803      	cmp	r0, #3
 80017e2:	d841      	bhi.n	8001868 <ws28xx_SetColor+0x8c>
		return;	
	switch(Color)
 80017e4:	2913      	cmp	r1, #19
 80017e6:	d83f      	bhi.n	8001868 <ws28xx_SetColor+0x8c>
 80017e8:	2303      	movs	r3, #3
 80017ea:	0008      	movs	r0, r1
 80017ec:	4a32      	ldr	r2, [pc, #200]	; (80018b8 <ws28xx_SetColor+0xdc>)
			ws28xxLEDs[Pixel].G = 0;
			ws28xxLEDs[Pixel].B = 0;
		break;
		//---------------------
		case ws28xx_Color_White:
			ws28xxLEDs[Pixel].R = 255;
 80017ee:	4363      	muls	r3, r4
	switch(Color)
 80017f0:	f7fe fc94 	bl	800011c <__gnu_thumb1_case_uqi>
 80017f4:	1634110a 	.word	0x1634110a
 80017f8:	34231d28 	.word	0x34231d28
 80017fc:	413f2e3b 	.word	0x413f2e3b
 8001800:	4a3d4345 	.word	0x4a3d4345
 8001804:	0f5a554f 	.word	0x0f5a554f
			ws28xxLEDs[Pixel].R = 0;
 8001808:	2100      	movs	r1, #0
			ws28xxLEDs[Pixel].G = 0;
			ws28xxLEDs[Pixel].B = 128;
		break;
		//---------------------
		case ws28xx_Color_Silver:
			ws28xxLEDs[Pixel].R = 192;
 800180a:	54d1      	strb	r1, [r2, r3]
			ws28xxLEDs[Pixel].G = 192;
 800180c:	18d3      	adds	r3, r2, r3
 800180e:	7059      	strb	r1, [r3, #1]
 8001810:	e029      	b.n	8001866 <ws28xx_SetColor+0x8a>
			ws28xxLEDs[Pixel].R = 255;
 8001812:	21ff      	movs	r1, #255	; 0xff
 8001814:	e7f9      	b.n	800180a <ws28xx_SetColor+0x2e>
			ws28xxLEDs[Pixel].R = 80;
 8001816:	2150      	movs	r1, #80	; 0x50
			ws28xxLEDs[Pixel].R = 128;
 8001818:	54d1      	strb	r1, [r2, r3]
			ws28xxLEDs[Pixel].G = 0;
 800181a:	18d3      	adds	r3, r2, r3
 800181c:	2200      	movs	r2, #0
 800181e:	e00a      	b.n	8001836 <ws28xx_SetColor+0x5a>
			ws28xxLEDs[Pixel].R = 0;
 8001820:	2100      	movs	r1, #0
 8001822:	54d1      	strb	r1, [r2, r3]
			ws28xxLEDs[Pixel].G = 0;
 8001824:	18d3      	adds	r3, r2, r3
			ws28xxLEDs[Pixel].B = 255;
 8001826:	22ff      	movs	r2, #255	; 0xff
			ws28xxLEDs[Pixel].G = 0;
 8001828:	7059      	strb	r1, [r3, #1]
		break;
		//---------------------
		case ws28xx_Color_Pink:
			ws28xxLEDs[Pixel].R = 255;
			ws28xxLEDs[Pixel].G = 20;
			ws28xxLEDs[Pixel].B = 147;
 800182a:	709a      	strb	r2, [r3, #2]
 800182c:	e01c      	b.n	8001868 <ws28xx_SetColor+0x8c>
			ws28xxLEDs[Pixel].R = 0;
 800182e:	2100      	movs	r1, #0
 8001830:	54d1      	strb	r1, [r2, r3]
			ws28xxLEDs[Pixel].G = 255;
 8001832:	18d3      	adds	r3, r2, r3
 8001834:	22ff      	movs	r2, #255	; 0xff
			ws28xxLEDs[Pixel].G = 42;
 8001836:	705a      	strb	r2, [r3, #1]
 8001838:	e7f7      	b.n	800182a <ws28xx_SetColor+0x4e>
			ws28xxLEDs[Pixel].R = 255;
 800183a:	21ff      	movs	r1, #255	; 0xff
			ws28xxLEDs[Pixel].R = 128;
 800183c:	54d1      	strb	r1, [r2, r3]
			ws28xxLEDs[Pixel].G = 0;
 800183e:	18d3      	adds	r3, r2, r3
 8001840:	2200      	movs	r2, #0
 8001842:	e00f      	b.n	8001864 <ws28xx_SetColor+0x88>
			ws28xxLEDs[Pixel].R = 255;
 8001844:	21ff      	movs	r1, #255	; 0xff
			ws28xxLEDs[Pixel].R = 128;
 8001846:	54d1      	strb	r1, [r2, r3]
			ws28xxLEDs[Pixel].G = 128;
 8001848:	18d3      	adds	r3, r2, r3
 800184a:	7059      	strb	r1, [r3, #1]
			ws28xxLEDs[Pixel].B = 0;
 800184c:	2200      	movs	r2, #0
 800184e:	e7ec      	b.n	800182a <ws28xx_SetColor+0x4e>
			ws28xxLEDs[Pixel].R = 0;
 8001850:	2100      	movs	r1, #0
 8001852:	54d1      	strb	r1, [r2, r3]
			ws28xxLEDs[Pixel].G = 0;
 8001854:	18d3      	adds	r3, r2, r3
 8001856:	7059      	strb	r1, [r3, #1]
			ws28xxLEDs[Pixel].B = 128;
 8001858:	2280      	movs	r2, #128	; 0x80
 800185a:	e7e6      	b.n	800182a <ws28xx_SetColor+0x4e>
			ws28xxLEDs[Pixel].R = 0;
 800185c:	2100      	movs	r1, #0
 800185e:	54d1      	strb	r1, [r2, r3]
			ws28xxLEDs[Pixel].G = 128;
 8001860:	18d3      	adds	r3, r2, r3
 8001862:	2280      	movs	r2, #128	; 0x80
			ws28xxLEDs[Pixel].G = 0;
 8001864:	705a      	strb	r2, [r3, #1]
			ws28xxLEDs[Pixel].B = 192;
 8001866:	7099      	strb	r1, [r3, #2]
	

		
	}
	
}
 8001868:	bd10      	pop	{r4, pc}
			ws28xxLEDs[Pixel].R = 128;
 800186a:	2180      	movs	r1, #128	; 0x80
 800186c:	e7d4      	b.n	8001818 <ws28xx_SetColor+0x3c>
			ws28xxLEDs[Pixel].R = 128;
 800186e:	2180      	movs	r1, #128	; 0x80
 8001870:	e7cb      	b.n	800180a <ws28xx_SetColor+0x2e>
			ws28xxLEDs[Pixel].R = 128;
 8001872:	2180      	movs	r1, #128	; 0x80
 8001874:	e7e7      	b.n	8001846 <ws28xx_SetColor+0x6a>
			ws28xxLEDs[Pixel].R = 128;
 8001876:	2180      	movs	r1, #128	; 0x80
 8001878:	e7e0      	b.n	800183c <ws28xx_SetColor+0x60>
			ws28xxLEDs[Pixel].R = 192;
 800187a:	21c0      	movs	r1, #192	; 0xc0
 800187c:	e7c5      	b.n	800180a <ws28xx_SetColor+0x2e>
			ws28xxLEDs[Pixel].R = 0;
 800187e:	2100      	movs	r1, #0
 8001880:	54d1      	strb	r1, [r2, r3]
			ws28xxLEDs[Pixel].G = 128;
 8001882:	18d3      	adds	r3, r2, r3
 8001884:	2280      	movs	r2, #128	; 0x80
 8001886:	e7d6      	b.n	8001836 <ws28xx_SetColor+0x5a>
			ws28xxLEDs[Pixel].R = 165;
 8001888:	21a5      	movs	r1, #165	; 0xa5
 800188a:	54d1      	strb	r1, [r2, r3]
			ws28xxLEDs[Pixel].G = 42;
 800188c:	18d3      	adds	r3, r2, r3
 800188e:	222a      	movs	r2, #42	; 0x2a
 8001890:	e7d1      	b.n	8001836 <ws28xx_SetColor+0x5a>
			ws28xxLEDs[Pixel].R = 255;
 8001892:	21ff      	movs	r1, #255	; 0xff
 8001894:	54d1      	strb	r1, [r2, r3]
			ws28xxLEDs[Pixel].G = 165;
 8001896:	18d3      	adds	r3, r2, r3
 8001898:	22a5      	movs	r2, #165	; 0xa5
			ws28xxLEDs[Pixel].G = 215;
 800189a:	705a      	strb	r2, [r3, #1]
 800189c:	e7d6      	b.n	800184c <ws28xx_SetColor+0x70>
			ws28xxLEDs[Pixel].R = 255;
 800189e:	21ff      	movs	r1, #255	; 0xff
 80018a0:	54d1      	strb	r1, [r2, r3]
			ws28xxLEDs[Pixel].G = 215;
 80018a2:	18d3      	adds	r3, r2, r3
 80018a4:	22d7      	movs	r2, #215	; 0xd7
 80018a6:	e7f8      	b.n	800189a <ws28xx_SetColor+0xbe>
			ws28xxLEDs[Pixel].R = 255;
 80018a8:	21ff      	movs	r1, #255	; 0xff
 80018aa:	54d1      	strb	r1, [r2, r3]
			ws28xxLEDs[Pixel].G = 20;
 80018ac:	18d3      	adds	r3, r2, r3
 80018ae:	2214      	movs	r2, #20
 80018b0:	705a      	strb	r2, [r3, #1]
			ws28xxLEDs[Pixel].B = 147;
 80018b2:	327f      	adds	r2, #127	; 0x7f
 80018b4:	e7b9      	b.n	800182a <ws28xx_SetColor+0x4e>
 80018b6:	46c0      	nop			; (mov r8, r8)
 80018b8:	20000338 	.word	0x20000338

080018bc <ws28xx_fadeGreen>:
		ws28xx_SetColor(i,Color);	
}


void	ws28xx_fadeGreen()
{
 80018bc:	b570      	push	{r4, r5, r6, lr}

	for(uint16_t i=0 ; i<=128 ; i++)
 80018be:	2500      	movs	r5, #0
	{
		ws28xxLEDs[0].R = 0;
 80018c0:	2300      	movs	r3, #0
 80018c2:	4c18      	ldr	r4, [pc, #96]	; (8001924 <ws28xx_fadeGreen+0x68>)
		ws28xxLEDs[0].G = i;
 80018c4:	b2ea      	uxtb	r2, r5
		ws28xxLEDs[0].R = 0;
 80018c6:	7023      	strb	r3, [r4, #0]
		ws28xxLEDs[0].G = i;
 80018c8:	7062      	strb	r2, [r4, #1]
		ws28xxLEDs[0].B = 0;
 80018ca:	70a3      	strb	r3, [r4, #2]
		ws28xxLEDs[1].R = 0;
 80018cc:	70e3      	strb	r3, [r4, #3]
		ws28xxLEDs[1].G = i;
 80018ce:	7122      	strb	r2, [r4, #4]
		ws28xxLEDs[1].B = 0;
 80018d0:	7163      	strb	r3, [r4, #5]
		ws28xxLEDs[2].R = 0;
 80018d2:	71a3      	strb	r3, [r4, #6]
		ws28xxLEDs[2].G = i;
 80018d4:	71e2      	strb	r2, [r4, #7]
		ws28xxLEDs[2].B = 0;
 80018d6:	7223      	strb	r3, [r4, #8]
		ws28xxLEDs[3].R = 0;
 80018d8:	7263      	strb	r3, [r4, #9]
		ws28xxLEDs[3].G = i;
 80018da:	72a2      	strb	r2, [r4, #10]
		ws28xxLEDs[3].B = 0;
 80018dc:	72e3      	strb	r3, [r4, #11]
	for(uint16_t i=0 ; i<=128 ; i++)
 80018de:	3501      	adds	r5, #1
		ws28xx_Update();
 80018e0:	f7ff ff74 	bl	80017cc <ws28xx_Update>
	for(uint16_t i=0 ; i<=128 ; i++)
 80018e4:	b2ad      	uxth	r5, r5
		HAL_Delay(5);
 80018e6:	2005      	movs	r0, #5
 80018e8:	f000 f89a 	bl	8001a20 <HAL_Delay>
	for(uint16_t i=0 ; i<=128 ; i++)
 80018ec:	2d81      	cmp	r5, #129	; 0x81
 80018ee:	d1e7      	bne.n	80018c0 <ws28xx_fadeGreen+0x4>
	}
	for(uint16_t i=128 ; i>0 ; i--)
 80018f0:	3d01      	subs	r5, #1
	{
		ws28xxLEDs[0].R = 0;
 80018f2:	2300      	movs	r3, #0
		ws28xxLEDs[0].G = i;
 80018f4:	b2ea      	uxtb	r2, r5
		ws28xxLEDs[0].R = 0;
 80018f6:	7023      	strb	r3, [r4, #0]
		ws28xxLEDs[0].G = i;
 80018f8:	7062      	strb	r2, [r4, #1]
		ws28xxLEDs[0].B = 0;
 80018fa:	70a3      	strb	r3, [r4, #2]
		ws28xxLEDs[1].R = 0;
 80018fc:	70e3      	strb	r3, [r4, #3]
		ws28xxLEDs[1].G = i;
 80018fe:	7122      	strb	r2, [r4, #4]
		ws28xxLEDs[1].B = 0;
 8001900:	7163      	strb	r3, [r4, #5]
		ws28xxLEDs[2].R = 0;
 8001902:	71a3      	strb	r3, [r4, #6]
		ws28xxLEDs[2].G = i;
 8001904:	71e2      	strb	r2, [r4, #7]
		ws28xxLEDs[2].B = 0;
 8001906:	7223      	strb	r3, [r4, #8]
		ws28xxLEDs[3].R = 0;
 8001908:	7263      	strb	r3, [r4, #9]
		ws28xxLEDs[3].G = i;
 800190a:	72a2      	strb	r2, [r4, #10]
		ws28xxLEDs[3].B = 0;
 800190c:	72e3      	strb	r3, [r4, #11]
	for(uint16_t i=128 ; i>0 ; i--)
 800190e:	3d01      	subs	r5, #1
		ws28xx_Update();
 8001910:	f7ff ff5c 	bl	80017cc <ws28xx_Update>
	for(uint16_t i=128 ; i>0 ; i--)
 8001914:	b2ad      	uxth	r5, r5
		HAL_Delay(5);
 8001916:	2005      	movs	r0, #5
 8001918:	f000 f882 	bl	8001a20 <HAL_Delay>
	for(uint16_t i=128 ; i>0 ; i--)
 800191c:	2d00      	cmp	r5, #0
 800191e:	d1e8      	bne.n	80018f2 <ws28xx_fadeGreen+0x36>
	}
}
 8001920:	bd70      	pop	{r4, r5, r6, pc}
 8001922:	46c0      	nop			; (mov r8, r8)
 8001924:	20000338 	.word	0x20000338

08001928 <ws28xx_fadeRed>:

void	ws28xx_fadeRed()
{
 8001928:	b570      	push	{r4, r5, r6, lr}

	for(uint16_t i=0 ; i<=128 ; i++)
 800192a:	2500      	movs	r5, #0
	{
		ws28xxLEDs[0].R = i;
		ws28xxLEDs[0].G = 0;
 800192c:	2300      	movs	r3, #0
		ws28xxLEDs[0].R = i;
 800192e:	4c18      	ldr	r4, [pc, #96]	; (8001990 <ws28xx_fadeRed+0x68>)
 8001930:	b2ea      	uxtb	r2, r5
 8001932:	7022      	strb	r2, [r4, #0]
		ws28xxLEDs[0].G = 0;
 8001934:	7063      	strb	r3, [r4, #1]
		ws28xxLEDs[0].B = 0;
 8001936:	70a3      	strb	r3, [r4, #2]
		ws28xxLEDs[1].R = i;
 8001938:	70e2      	strb	r2, [r4, #3]
		ws28xxLEDs[1].G = 0;
 800193a:	7123      	strb	r3, [r4, #4]
		ws28xxLEDs[1].B = 0;
 800193c:	7163      	strb	r3, [r4, #5]
		ws28xxLEDs[2].R = i;
 800193e:	71a2      	strb	r2, [r4, #6]
		ws28xxLEDs[2].G = 0;
 8001940:	71e3      	strb	r3, [r4, #7]
		ws28xxLEDs[2].B = 0;
 8001942:	7223      	strb	r3, [r4, #8]
		ws28xxLEDs[3].R = i;
 8001944:	7262      	strb	r2, [r4, #9]
		ws28xxLEDs[3].G = 0;
 8001946:	72a3      	strb	r3, [r4, #10]
		ws28xxLEDs[3].B = 0;
 8001948:	72e3      	strb	r3, [r4, #11]
	for(uint16_t i=0 ; i<=128 ; i++)
 800194a:	3501      	adds	r5, #1
		ws28xx_Update();
 800194c:	f7ff ff3e 	bl	80017cc <ws28xx_Update>
	for(uint16_t i=0 ; i<=128 ; i++)
 8001950:	b2ad      	uxth	r5, r5
		HAL_Delay(5);
 8001952:	2005      	movs	r0, #5
 8001954:	f000 f864 	bl	8001a20 <HAL_Delay>
	for(uint16_t i=0 ; i<=128 ; i++)
 8001958:	2d81      	cmp	r5, #129	; 0x81
 800195a:	d1e7      	bne.n	800192c <ws28xx_fadeRed+0x4>
	}
	for(uint16_t i=128 ; i>0 ; i--)
 800195c:	3d01      	subs	r5, #1
	{
		ws28xxLEDs[0].R = i;
		ws28xxLEDs[0].G = 0;
 800195e:	2300      	movs	r3, #0
		ws28xxLEDs[0].R = i;
 8001960:	b2ea      	uxtb	r2, r5
 8001962:	7022      	strb	r2, [r4, #0]
		ws28xxLEDs[0].G = 0;
 8001964:	7063      	strb	r3, [r4, #1]
		ws28xxLEDs[0].B = 0;
 8001966:	70a3      	strb	r3, [r4, #2]
		ws28xxLEDs[1].R = i;
 8001968:	70e2      	strb	r2, [r4, #3]
		ws28xxLEDs[1].G = 0;
 800196a:	7123      	strb	r3, [r4, #4]
		ws28xxLEDs[1].B = 0;
 800196c:	7163      	strb	r3, [r4, #5]
		ws28xxLEDs[2].R = i;
 800196e:	71a2      	strb	r2, [r4, #6]
		ws28xxLEDs[2].G = 0;
 8001970:	71e3      	strb	r3, [r4, #7]
		ws28xxLEDs[2].B = 0;
 8001972:	7223      	strb	r3, [r4, #8]
		ws28xxLEDs[3].R = i;
 8001974:	7262      	strb	r2, [r4, #9]
		ws28xxLEDs[3].G = 0;
 8001976:	72a3      	strb	r3, [r4, #10]
		ws28xxLEDs[3].B = 0;
 8001978:	72e3      	strb	r3, [r4, #11]
	for(uint16_t i=128 ; i>0 ; i--)
 800197a:	3d01      	subs	r5, #1
		ws28xx_Update();
 800197c:	f7ff ff26 	bl	80017cc <ws28xx_Update>
	for(uint16_t i=128 ; i>0 ; i--)
 8001980:	b2ad      	uxth	r5, r5
		HAL_Delay(5);
 8001982:	2005      	movs	r0, #5
 8001984:	f000 f84c 	bl	8001a20 <HAL_Delay>
	for(uint16_t i=128 ; i>0 ; i--)
 8001988:	2d00      	cmp	r5, #0
 800198a:	d1e8      	bne.n	800195e <ws28xx_fadeRed+0x36>
	}
}
 800198c:	bd70      	pop	{r4, r5, r6, pc}
 800198e:	46c0      	nop			; (mov r8, r8)
 8001990:	20000338 	.word	0x20000338

08001994 <HAL_InitTick>:
  *       implementation  in user file.
  * @param TickPriority Tick interrupt priority.
  * @retval HAL status
  */
__weak HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)
{
 8001994:	b570      	push	{r4, r5, r6, lr}
 8001996:	0005      	movs	r5, r0
  /*Configure the SysTick to have interrupt in 1ms time basis*/
  if (HAL_SYSTICK_Config(SystemCoreClock / (1000U / uwTickFreq)) > 0U)
 8001998:	20fa      	movs	r0, #250	; 0xfa
 800199a:	4b0d      	ldr	r3, [pc, #52]	; (80019d0 <HAL_InitTick+0x3c>)
 800199c:	0080      	lsls	r0, r0, #2
 800199e:	7819      	ldrb	r1, [r3, #0]
 80019a0:	f7fe fbc6 	bl	8000130 <__udivsi3>
 80019a4:	4b0b      	ldr	r3, [pc, #44]	; (80019d4 <HAL_InitTick+0x40>)
 80019a6:	0001      	movs	r1, r0
 80019a8:	6818      	ldr	r0, [r3, #0]
 80019aa:	f7fe fbc1 	bl	8000130 <__udivsi3>
 80019ae:	f000 f9b3 	bl	8001d18 <HAL_SYSTICK_Config>
 80019b2:	0004      	movs	r4, r0
  {
    return HAL_ERROR;
 80019b4:	2001      	movs	r0, #1
  if (HAL_SYSTICK_Config(SystemCoreClock / (1000U / uwTickFreq)) > 0U)
 80019b6:	2c00      	cmp	r4, #0
 80019b8:	d109      	bne.n	80019ce <HAL_InitTick+0x3a>
  }

  /* Configure the SysTick IRQ priority */
  if (TickPriority < (1UL << __NVIC_PRIO_BITS))
 80019ba:	2d03      	cmp	r5, #3
 80019bc:	d807      	bhi.n	80019ce <HAL_InitTick+0x3a>
  {
    HAL_NVIC_SetPriority(SysTick_IRQn, TickPriority, 0U);
 80019be:	3802      	subs	r0, #2
 80019c0:	0022      	movs	r2, r4
 80019c2:	0029      	movs	r1, r5
 80019c4:	f000 f962 	bl	8001c8c <HAL_NVIC_SetPriority>
    uwTickPrio = TickPriority;
 80019c8:	0020      	movs	r0, r4
 80019ca:	4b03      	ldr	r3, [pc, #12]	; (80019d8 <HAL_InitTick+0x44>)
 80019cc:	601d      	str	r5, [r3, #0]
    return HAL_ERROR;
  }

   /* Return function status */
  return HAL_OK;
}
 80019ce:	bd70      	pop	{r4, r5, r6, pc}
 80019d0:	20000028 	.word	0x20000028
 80019d4:	20000024 	.word	0x20000024
 80019d8:	2000002c 	.word	0x2000002c

080019dc <HAL_Init>:
  __HAL_FLASH_PREFETCH_BUFFER_ENABLE();
 80019dc:	2310      	movs	r3, #16
 80019de:	4a06      	ldr	r2, [pc, #24]	; (80019f8 <HAL_Init+0x1c>)
{
 80019e0:	b510      	push	{r4, lr}
  __HAL_FLASH_PREFETCH_BUFFER_ENABLE();
 80019e2:	6811      	ldr	r1, [r2, #0]
  HAL_InitTick(TICK_INT_PRIORITY);
 80019e4:	2000      	movs	r0, #0
  __HAL_FLASH_PREFETCH_BUFFER_ENABLE();
 80019e6:	430b      	orrs	r3, r1
 80019e8:	6013      	str	r3, [r2, #0]
  HAL_InitTick(TICK_INT_PRIORITY);
 80019ea:	f7ff ffd3 	bl	8001994 <HAL_InitTick>
  HAL_MspInit();
 80019ee:	f7ff fcd3 	bl	8001398 <HAL_MspInit>
}
 80019f2:	2000      	movs	r0, #0
 80019f4:	bd10      	pop	{r4, pc}
 80019f6:	46c0      	nop			; (mov r8, r8)
 80019f8:	40022000 	.word	0x40022000

080019fc <HAL_IncTick>:
  *       implementations in user file.
  * @retval None
  */
__weak void HAL_IncTick(void)
{
  uwTick += uwTickFreq;
 80019fc:	4a03      	ldr	r2, [pc, #12]	; (8001a0c <HAL_IncTick+0x10>)
 80019fe:	4b04      	ldr	r3, [pc, #16]	; (8001a10 <HAL_IncTick+0x14>)
 8001a00:	6811      	ldr	r1, [r2, #0]
 8001a02:	781b      	ldrb	r3, [r3, #0]
 8001a04:	185b      	adds	r3, r3, r1
 8001a06:	6013      	str	r3, [r2, #0]
}
 8001a08:	4770      	bx	lr
 8001a0a:	46c0      	nop			; (mov r8, r8)
 8001a0c:	20000464 	.word	0x20000464
 8001a10:	20000028 	.word	0x20000028

08001a14 <HAL_GetTick>:
  *       implementations in user file.
  * @retval tick value
  */
__weak uint32_t HAL_GetTick(void)
{
  return uwTick;
 8001a14:	4b01      	ldr	r3, [pc, #4]	; (8001a1c <HAL_GetTick+0x8>)
 8001a16:	6818      	ldr	r0, [r3, #0]
}
 8001a18:	4770      	bx	lr
 8001a1a:	46c0      	nop			; (mov r8, r8)
 8001a1c:	20000464 	.word	0x20000464

08001a20 <HAL_Delay>:
  *       implementations in user file.
  * @param Delay specifies the delay time length, in milliseconds.
  * @retval None
  */
__weak void HAL_Delay(uint32_t Delay)
{
 8001a20:	b570      	push	{r4, r5, r6, lr}
 8001a22:	0004      	movs	r4, r0
  uint32_t tickstart = HAL_GetTick();
 8001a24:	f7ff fff6 	bl	8001a14 <HAL_GetTick>
 8001a28:	0005      	movs	r5, r0
  uint32_t wait = Delay;
  
  /* Add a freq to guarantee minimum wait */
  if (wait < HAL_MAX_DELAY)
 8001a2a:	1c63      	adds	r3, r4, #1
 8001a2c:	d002      	beq.n	8001a34 <HAL_Delay+0x14>
  {
    wait += (uint32_t)(uwTickFreq);
 8001a2e:	4b04      	ldr	r3, [pc, #16]	; (8001a40 <HAL_Delay+0x20>)
 8001a30:	781b      	ldrb	r3, [r3, #0]
 8001a32:	18e4      	adds	r4, r4, r3
  }
  
  while((HAL_GetTick() - tickstart) < wait)
 8001a34:	f7ff ffee 	bl	8001a14 <HAL_GetTick>
 8001a38:	1b40      	subs	r0, r0, r5
 8001a3a:	42a0      	cmp	r0, r4
 8001a3c:	d3fa      	bcc.n	8001a34 <HAL_Delay+0x14>
  {
  }
}
 8001a3e:	bd70      	pop	{r4, r5, r6, pc}
 8001a40:	20000028 	.word	0x20000028

08001a44 <HAL_ADC_Init>:
  *         of structure "ADC_InitTypeDef".
  * @param  hadc ADC handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_ADC_Init(ADC_HandleTypeDef* hadc)
{
 8001a44:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8001a46:	0004      	movs	r4, r0
  uint32_t tmpCFGR1 = 0U;

  /* Check ADC handle */
  if(hadc == NULL)
  {
    return HAL_ERROR;
 8001a48:	2001      	movs	r0, #1
  if(hadc == NULL)
 8001a4a:	2c00      	cmp	r4, #0
 8001a4c:	d07e      	beq.n	8001b4c <HAL_ADC_Init+0x108>
  /* Refer to header of this file for more details on clock enabling procedure*/
  
  /* Actions performed only if ADC is coming from state reset:                */
  /* - Initialization of ADC MSP                                              */
  /* - ADC voltage regulator enable                                           */
  if (hadc->State == HAL_ADC_STATE_RESET)
 8001a4e:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8001a50:	2b00      	cmp	r3, #0
 8001a52:	d106      	bne.n	8001a62 <HAL_ADC_Init+0x1e>
  {
    /* Initialize ADC error code */
    ADC_CLEAR_ERRORCODE(hadc);
    
    /* Allocate lock resource and initialize it */
    hadc->Lock = HAL_UNLOCKED;
 8001a54:	0022      	movs	r2, r4
 8001a56:	3234      	adds	r2, #52	; 0x34
    ADC_CLEAR_ERRORCODE(hadc);
 8001a58:	63e3      	str	r3, [r4, #60]	; 0x3c
    
    /* Init the low level hardware */
    hadc->MspInitCallback(hadc);
#else
    /* Init the low level hardware */
    HAL_ADC_MspInit(hadc);
 8001a5a:	0020      	movs	r0, r4
    hadc->Lock = HAL_UNLOCKED;
 8001a5c:	7013      	strb	r3, [r2, #0]
    HAL_ADC_MspInit(hadc);
 8001a5e:	f7ff fcb3 	bl	80013c8 <HAL_ADC_MspInit>
  /* Configuration of ADC parameters if previous preliminary actions are      */ 
  /* correctly completed.                                                     */
  /* and if there is no conversion on going on regular group (ADC can be      */ 
  /* enabled anyway, in case of call of this function to update a parameter   */
  /* on the fly).                                                             */
  if (HAL_IS_BIT_CLR(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL) &&
 8001a62:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8001a64:	06db      	lsls	r3, r3, #27
 8001a66:	d500      	bpl.n	8001a6a <HAL_ADC_Init+0x26>
 8001a68:	e085      	b.n	8001b76 <HAL_ADC_Init+0x132>
      (tmp_hal_status == HAL_OK)                                &&
      (ADC_IS_CONVERSION_ONGOING_REGULAR(hadc) == RESET)          )
 8001a6a:	2204      	movs	r2, #4
 8001a6c:	6823      	ldr	r3, [r4, #0]
 8001a6e:	6898      	ldr	r0, [r3, #8]
 8001a70:	4010      	ands	r0, r2
      (tmp_hal_status == HAL_OK)                                &&
 8001a72:	d000      	beq.n	8001a76 <HAL_ADC_Init+0x32>
 8001a74:	e07f      	b.n	8001b76 <HAL_ADC_Init+0x132>
  {
    /* Set ADC state */
    ADC_STATE_CLR_SET(hadc->State,
 8001a76:	6ba2      	ldr	r2, [r4, #56]	; 0x38
 8001a78:	4942      	ldr	r1, [pc, #264]	; (8001b84 <HAL_ADC_Init+0x140>)
 8001a7a:	4011      	ands	r1, r2
 8001a7c:	2202      	movs	r2, #2
 8001a7e:	430a      	orrs	r2, r1
    /* Parameters update conditioned to ADC state:                            */
    /* Parameters that can be updated only when ADC is disabled:              */
    /*  - ADC clock mode                                                      */
    /*  - ADC clock prescaler                                                 */
    /*  - ADC resolution                                                      */
    if (ADC_IS_ENABLE(hadc) == RESET)
 8001a80:	2103      	movs	r1, #3
    ADC_STATE_CLR_SET(hadc->State,
 8001a82:	63a2      	str	r2, [r4, #56]	; 0x38
    if (ADC_IS_ENABLE(hadc) == RESET)
 8001a84:	689a      	ldr	r2, [r3, #8]
 8001a86:	400a      	ands	r2, r1
 8001a88:	2a01      	cmp	r2, #1
 8001a8a:	d105      	bne.n	8001a98 <HAL_ADC_Init+0x54>
 8001a8c:	6819      	ldr	r1, [r3, #0]
 8001a8e:	4211      	tst	r1, r2
 8001a90:	d10e      	bne.n	8001ab0 <HAL_ADC_Init+0x6c>
 8001a92:	68da      	ldr	r2, [r3, #12]
 8001a94:	0412      	lsls	r2, r2, #16
 8001a96:	d40b      	bmi.n	8001ab0 <HAL_ADC_Init+0x6c>
      /* parameters):                                                         */
      /*   - internal measurement paths: Vbat, temperature sensor, Vref       */
      /*     (set into HAL_ADC_ConfigChannel() )                              */
     
      /* Configuration of ADC resolution                                      */
      MODIFY_REG(hadc->Instance->CFGR1,
 8001a98:	2118      	movs	r1, #24
 8001a9a:	68da      	ldr	r2, [r3, #12]
 8001a9c:	438a      	bics	r2, r1
 8001a9e:	68a1      	ldr	r1, [r4, #8]
 8001aa0:	430a      	orrs	r2, r1
 8001aa2:	60da      	str	r2, [r3, #12]
                 ADC_CFGR1_RES        ,
                 hadc->Init.Resolution );
      
      /* Configuration of ADC clock mode: clock source AHB or HSI with        */
      /* selectable prescaler                                                 */
      MODIFY_REG(hadc->Instance->CFGR2    ,
 8001aa4:	6919      	ldr	r1, [r3, #16]
 8001aa6:	6862      	ldr	r2, [r4, #4]
 8001aa8:	0089      	lsls	r1, r1, #2
 8001aaa:	0889      	lsrs	r1, r1, #2
 8001aac:	4311      	orrs	r1, r2
 8001aae:	6119      	str	r1, [r3, #16]
    /*  - external trigger polarity                                           */
    /*  - data alignment                                                      */
    /*  - resolution                                                          */
    /*  - scan direction                                                      */
    /*  - DMA continuous request                                              */
    hadc->Instance->CFGR1 &= ~( ADC_CFGR1_DISCEN  |
 8001ab0:	68da      	ldr	r2, [r3, #12]
 8001ab2:	4935      	ldr	r1, [pc, #212]	; (8001b88 <HAL_ADC_Init+0x144>)
 8001ab4:	400a      	ands	r2, r1
 8001ab6:	60da      	str	r2, [r3, #12]
                                ADC_CFGR1_EXTEN   |
                                ADC_CFGR1_ALIGN   |
                                ADC_CFGR1_SCANDIR |
                                ADC_CFGR1_DMACFG   );

    tmpCFGR1 |= (ADC_CFGR1_AUTOWAIT((uint32_t)hadc->Init.LowPowerAutoWait)        |
 8001ab8:	7e25      	ldrb	r5, [r4, #24]
                 ADC_CFGR1_AUTOOFF((uint32_t)hadc->Init.LowPowerAutoPowerOff)     |
 8001aba:	7e62      	ldrb	r2, [r4, #25]
    tmpCFGR1 |= (ADC_CFGR1_AUTOWAIT((uint32_t)hadc->Init.LowPowerAutoWait)        |
 8001abc:	03ad      	lsls	r5, r5, #14
                 ADC_CFGR1_AUTOOFF((uint32_t)hadc->Init.LowPowerAutoPowerOff)     |
 8001abe:	03d2      	lsls	r2, r2, #15
    tmpCFGR1 |= (ADC_CFGR1_AUTOWAIT((uint32_t)hadc->Init.LowPowerAutoWait)        |
 8001ac0:	4315      	orrs	r5, r2
                 ADC_CFGR1_CONTINUOUS((uint32_t)hadc->Init.ContinuousConvMode)    |
                 ADC_CFGR1_OVERRUN(hadc->Init.Overrun)                            |
 8001ac2:	6aa2      	ldr	r2, [r4, #40]	; 0x28
                 ADC_CFGR1_CONTINUOUS((uint32_t)hadc->Init.ContinuousConvMode)    |
 8001ac4:	7ea1      	ldrb	r1, [r4, #26]
                 ADC_CFGR1_OVERRUN(hadc->Init.Overrun)                            |
 8001ac6:	3a01      	subs	r2, #1
 8001ac8:	1e56      	subs	r6, r2, #1
 8001aca:	41b2      	sbcs	r2, r6
 8001acc:	0316      	lsls	r6, r2, #12
 8001ace:	68e2      	ldr	r2, [r4, #12]
                 ADC_CFGR1_CONTINUOUS((uint32_t)hadc->Init.ContinuousConvMode)    |
 8001ad0:	034f      	lsls	r7, r1, #13
 8001ad2:	4315      	orrs	r5, r2
                 hadc->Init.DataAlign                                             |
                 ADC_SCANDIR(hadc->Init.ScanConvMode)                             |
 8001ad4:	6922      	ldr	r2, [r4, #16]
 8001ad6:	432f      	orrs	r7, r5
 8001ad8:	2a02      	cmp	r2, #2
 8001ada:	d100      	bne.n	8001ade <HAL_ADC_Init+0x9a>
 8001adc:	2004      	movs	r0, #4
                 ADC_CFGR1_DMACONTREQ((uint32_t)hadc->Init.DMAContinuousRequests)  );
 8001ade:	1d62      	adds	r2, r4, #5
 8001ae0:	7fd2      	ldrb	r2, [r2, #31]
 8001ae2:	0052      	lsls	r2, r2, #1
                 ADC_SCANDIR(hadc->Init.ScanConvMode)                             |
 8001ae4:	433a      	orrs	r2, r7
 8001ae6:	4332      	orrs	r2, r6
 8001ae8:	4302      	orrs	r2, r0
    
    /* Enable discontinuous mode only if continuous mode is disabled */
    if (hadc->Init.DiscontinuousConvMode == ENABLE)
 8001aea:	7ee0      	ldrb	r0, [r4, #27]
 8001aec:	2801      	cmp	r0, #1
 8001aee:	d104      	bne.n	8001afa <HAL_ADC_Init+0xb6>
    {
      if (hadc->Init.ContinuousConvMode == DISABLE)
 8001af0:	2900      	cmp	r1, #0
 8001af2:	d12c      	bne.n	8001b4e <HAL_ADC_Init+0x10a>
      {
        /* Enable the selected ADC group regular discontinuous mode */
        tmpCFGR1 |= ADC_CFGR1_DISCEN;
 8001af4:	2180      	movs	r1, #128	; 0x80
 8001af6:	0249      	lsls	r1, r1, #9
 8001af8:	430a      	orrs	r2, r1
    /* Enable external trigger if trigger selection is different of software  */
    /* start.                                                                 */
    /* Note: This configuration keeps the hardware feature of parameter       */
    /*       ExternalTrigConvEdge "trigger edge none" equivalent to           */
    /*       software start.                                                  */
    if (hadc->Init.ExternalTrigConv != ADC_SOFTWARE_START)
 8001afa:	20c2      	movs	r0, #194	; 0xc2
 8001afc:	69e1      	ldr	r1, [r4, #28]
 8001afe:	30ff      	adds	r0, #255	; 0xff
 8001b00:	4281      	cmp	r1, r0
 8001b02:	d002      	beq.n	8001b0a <HAL_ADC_Init+0xc6>
    {
      tmpCFGR1 |= ( hadc->Init.ExternalTrigConv    |
 8001b04:	6a20      	ldr	r0, [r4, #32]
 8001b06:	4301      	orrs	r1, r0
 8001b08:	430a      	orrs	r2, r1
    /* Management of parameters "SamplingTimeCommon" and "SamplingTime"       */
    /* (obsolete): sampling time set in this function if parameter            */
    /*  "SamplingTimeCommon" has been set to a valid sampling time.           */
    /* Otherwise, sampling time is set into ADC channel initialization        */
    /* structure with parameter "SamplingTime" (obsolete).                    */
    if (IS_ADC_SAMPLE_TIME(hadc->Init.SamplingTimeCommon))
 8001b0a:	2080      	movs	r0, #128	; 0x80
    hadc->Instance->CFGR1 |= tmpCFGR1;
 8001b0c:	68d9      	ldr	r1, [r3, #12]
    if (IS_ADC_SAMPLE_TIME(hadc->Init.SamplingTimeCommon))
 8001b0e:	0540      	lsls	r0, r0, #21
    hadc->Instance->CFGR1 |= tmpCFGR1;
 8001b10:	4311      	orrs	r1, r2
 8001b12:	60d9      	str	r1, [r3, #12]
    if (IS_ADC_SAMPLE_TIME(hadc->Init.SamplingTimeCommon))
 8001b14:	6ae1      	ldr	r1, [r4, #44]	; 0x2c
 8001b16:	4281      	cmp	r1, r0
 8001b18:	d002      	beq.n	8001b20 <HAL_ADC_Init+0xdc>
 8001b1a:	1e48      	subs	r0, r1, #1
 8001b1c:	2806      	cmp	r0, #6
 8001b1e:	d807      	bhi.n	8001b30 <HAL_ADC_Init+0xec>
    {
      /* Channel sampling time configuration */
      /* Clear the old sample time */
      hadc->Instance->SMPR &= ~(ADC_SMPR_SMP);
 8001b20:	2507      	movs	r5, #7
 8001b22:	6958      	ldr	r0, [r3, #20]
      
      /* Set the new sample time */
      hadc->Instance->SMPR |= ADC_SMPR_SET(hadc->Init.SamplingTimeCommon);
 8001b24:	4029      	ands	r1, r5
      hadc->Instance->SMPR &= ~(ADC_SMPR_SMP);
 8001b26:	43a8      	bics	r0, r5
 8001b28:	6158      	str	r0, [r3, #20]
      hadc->Instance->SMPR |= ADC_SMPR_SET(hadc->Init.SamplingTimeCommon);
 8001b2a:	6958      	ldr	r0, [r3, #20]
 8001b2c:	4301      	orrs	r1, r0
 8001b2e:	6159      	str	r1, [r3, #20]
    /* Check back that ADC registers have effectively been configured to      */
    /* ensure of no potential problem of ADC core IP clocking.                */
    /* Check through register CFGR1 (excluding analog watchdog configuration: */
    /* set into separate dedicated function, and bits of ADC resolution set   */
    /* out of temporary variable 'tmpCFGR1').                                 */
    if ((hadc->Instance->CFGR1 & ~(ADC_CFGR1_AWDCH | ADC_CFGR1_AWDEN | ADC_CFGR1_AWDSGL | ADC_CFGR1_RES))
 8001b30:	68db      	ldr	r3, [r3, #12]
 8001b32:	4916      	ldr	r1, [pc, #88]	; (8001b8c <HAL_ADC_Init+0x148>)
 8001b34:	400b      	ands	r3, r1
 8001b36:	4293      	cmp	r3, r2
 8001b38:	d111      	bne.n	8001b5e <HAL_ADC_Init+0x11a>
         == tmpCFGR1)
    {
      /* Set ADC error code to none */
      ADC_CLEAR_ERRORCODE(hadc);
 8001b3a:	2000      	movs	r0, #0
      
      /* Set the ADC state */
      ADC_STATE_CLR_SET(hadc->State,
 8001b3c:	2203      	movs	r2, #3
      ADC_CLEAR_ERRORCODE(hadc);
 8001b3e:	63e0      	str	r0, [r4, #60]	; 0x3c
      ADC_STATE_CLR_SET(hadc->State,
 8001b40:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8001b42:	4393      	bics	r3, r2
 8001b44:	001a      	movs	r2, r3
 8001b46:	2301      	movs	r3, #1
 8001b48:	4313      	orrs	r3, r2
 8001b4a:	63a3      	str	r3, [r4, #56]	; 0x38
    tmp_hal_status = HAL_ERROR;
  }
  
  /* Return function status */
  return tmp_hal_status;
}
 8001b4c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
 8001b4e:	2120      	movs	r1, #32
 8001b50:	6ba5      	ldr	r5, [r4, #56]	; 0x38
 8001b52:	4329      	orrs	r1, r5
 8001b54:	63a1      	str	r1, [r4, #56]	; 0x38
        SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_INTERNAL);
 8001b56:	6be1      	ldr	r1, [r4, #60]	; 0x3c
 8001b58:	4308      	orrs	r0, r1
 8001b5a:	63e0      	str	r0, [r4, #60]	; 0x3c
 8001b5c:	e7cd      	b.n	8001afa <HAL_ADC_Init+0xb6>
      ADC_STATE_CLR_SET(hadc->State,
 8001b5e:	2212      	movs	r2, #18
 8001b60:	6ba3      	ldr	r3, [r4, #56]	; 0x38
      SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_INTERNAL);
 8001b62:	2001      	movs	r0, #1
      ADC_STATE_CLR_SET(hadc->State,
 8001b64:	4393      	bics	r3, r2
 8001b66:	001a      	movs	r2, r3
 8001b68:	2310      	movs	r3, #16
 8001b6a:	4313      	orrs	r3, r2
 8001b6c:	63a3      	str	r3, [r4, #56]	; 0x38
      SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_INTERNAL);
 8001b6e:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 8001b70:	4303      	orrs	r3, r0
 8001b72:	63e3      	str	r3, [r4, #60]	; 0x3c
 8001b74:	e7ea      	b.n	8001b4c <HAL_ADC_Init+0x108>
    SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
 8001b76:	2310      	movs	r3, #16
 8001b78:	6ba2      	ldr	r2, [r4, #56]	; 0x38
    tmp_hal_status = HAL_ERROR;
 8001b7a:	2001      	movs	r0, #1
    SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
 8001b7c:	4313      	orrs	r3, r2
 8001b7e:	63a3      	str	r3, [r4, #56]	; 0x38
 8001b80:	e7e4      	b.n	8001b4c <HAL_ADC_Init+0x108>
 8001b82:	46c0      	nop			; (mov r8, r8)
 8001b84:	fffffefd 	.word	0xfffffefd
 8001b88:	fffe0219 	.word	0xfffe0219
 8001b8c:	833fffe7 	.word	0x833fffe7

08001b90 <HAL_ADC_ConfigChannel>:
  * @param  hadc ADC handle
  * @param  sConfig Structure of ADC channel for regular group.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_ADC_ConfigChannel(ADC_HandleTypeDef* hadc, ADC_ChannelConfTypeDef* sConfig)
{
 8001b90:	b5f0      	push	{r4, r5, r6, r7, lr}
  HAL_StatusTypeDef tmp_hal_status = HAL_OK;
  __IO uint32_t wait_loop_index = 0U;
 8001b92:	2300      	movs	r3, #0
  {
    assert_param(IS_ADC_SAMPLE_TIME(sConfig->SamplingTime));
  }
  
  /* Process locked */
  __HAL_LOCK(hadc);
 8001b94:	0004      	movs	r4, r0
{
 8001b96:	b085      	sub	sp, #20
  __IO uint32_t wait_loop_index = 0U;
 8001b98:	9303      	str	r3, [sp, #12]
  __HAL_LOCK(hadc);
 8001b9a:	3434      	adds	r4, #52	; 0x34
 8001b9c:	7823      	ldrb	r3, [r4, #0]
{
 8001b9e:	0002      	movs	r2, r0
  __HAL_LOCK(hadc);
 8001ba0:	2002      	movs	r0, #2
 8001ba2:	2b01      	cmp	r3, #1
 8001ba4:	d02f      	beq.n	8001c06 <HAL_ADC_ConfigChannel+0x76>
  if (! IS_ADC_SAMPLE_TIME(hadc->Init.SamplingTimeCommon))
 8001ba6:	6ad3      	ldr	r3, [r2, #44]	; 0x2c
  /* Parameters that can be updated when ADC is disabled or enabled without   */
  /* conversion on going on regular group:                                    */
  /*  - Channel number                                                        */
  /*  - Channel sampling time                                                 */
  /*  - Management of internal measurement channels: VrefInt/TempSensor/Vbat  */
  if (ADC_IS_CONVERSION_ONGOING_REGULAR(hadc) == RESET)
 8001ba8:	6817      	ldr	r7, [r2, #0]
  if (! IS_ADC_SAMPLE_TIME(hadc->Init.SamplingTimeCommon))
 8001baa:	469c      	mov	ip, r3
  __HAL_LOCK(hadc);
 8001bac:	2301      	movs	r3, #1
  if (ADC_IS_CONVERSION_ONGOING_REGULAR(hadc) == RESET)
 8001bae:	68bd      	ldr	r5, [r7, #8]
 8001bb0:	1800      	adds	r0, r0, r0
  __HAL_LOCK(hadc);
 8001bb2:	7023      	strb	r3, [r4, #0]
  if (ADC_IS_CONVERSION_ONGOING_REGULAR(hadc) == RESET)
 8001bb4:	4005      	ands	r5, r0
 8001bb6:	d159      	bne.n	8001c6c <HAL_ADC_ConfigChannel+0xdc>
 8001bb8:	680e      	ldr	r6, [r1, #0]
  {
    /* Configure channel: depending on rank setting, add it or remove it from */
    /* ADC conversion sequencer.                                              */
    if (sConfig->Rank != ADC_RANK_NONE)
 8001bba:	482f      	ldr	r0, [pc, #188]	; (8001c78 <HAL_ADC_ConfigChannel+0xe8>)
 8001bbc:	40b3      	lsls	r3, r6
 8001bbe:	0032      	movs	r2, r6
 8001bc0:	9301      	str	r3, [sp, #4]
 8001bc2:	684b      	ldr	r3, [r1, #4]
 8001bc4:	3a10      	subs	r2, #16
 8001bc6:	4283      	cmp	r3, r0
 8001bc8:	d03d      	beq.n	8001c46 <HAL_ADC_ConfigChannel+0xb6>
    {
      /* Regular sequence configuration */
      /* Set the channel selection register from the selected channel */
      hadc->Instance->CHSELR |= ADC_CHSELR_CHANNEL(sConfig->Channel);
 8001bca:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8001bcc:	9801      	ldr	r0, [sp, #4]
 8001bce:	4318      	orrs	r0, r3
      /* Channel sampling time configuration */
      /* Management of parameters "SamplingTimeCommon" and "SamplingTime"     */
      /* (obsolete): sampling time set in this function with                  */
      /* parameter "SamplingTime" (obsolete) only if not already set into     */
      /* ADC initialization structure with parameter "SamplingTimeCommon".    */
      if (! IS_ADC_SAMPLE_TIME(hadc->Init.SamplingTimeCommon))
 8001bd0:	2380      	movs	r3, #128	; 0x80
      hadc->Instance->CHSELR |= ADC_CHSELR_CHANNEL(sConfig->Channel);
 8001bd2:	62b8      	str	r0, [r7, #40]	; 0x28
      if (! IS_ADC_SAMPLE_TIME(hadc->Init.SamplingTimeCommon))
 8001bd4:	055b      	lsls	r3, r3, #21
 8001bd6:	459c      	cmp	ip, r3
 8001bd8:	d010      	beq.n	8001bfc <HAL_ADC_ConfigChannel+0x6c>
 8001bda:	4663      	mov	r3, ip
 8001bdc:	3b01      	subs	r3, #1
 8001bde:	2b06      	cmp	r3, #6
 8001be0:	d90c      	bls.n	8001bfc <HAL_ADC_ConfigChannel+0x6c>
      {
        /* Modify sampling time if needed (not needed in case of reoccurrence */
        /* for several channels programmed consecutively into the sequencer)  */
        if (sConfig->SamplingTime != ADC_GET_SAMPLINGTIME(hadc))
 8001be2:	688b      	ldr	r3, [r1, #8]
 8001be4:	2107      	movs	r1, #7
 8001be6:	6978      	ldr	r0, [r7, #20]
 8001be8:	4008      	ands	r0, r1
 8001bea:	4283      	cmp	r3, r0
 8001bec:	d006      	beq.n	8001bfc <HAL_ADC_ConfigChannel+0x6c>
        {
          /* Channel sampling time configuration */
          /* Clear the old sample time */
          hadc->Instance->SMPR &= ~(ADC_SMPR_SMP);
 8001bee:	6978      	ldr	r0, [r7, #20]
          
          /* Set the new sample time */
          hadc->Instance->SMPR |= ADC_SMPR_SET(sConfig->SamplingTime);
 8001bf0:	400b      	ands	r3, r1
          hadc->Instance->SMPR &= ~(ADC_SMPR_SMP);
 8001bf2:	4388      	bics	r0, r1
 8001bf4:	6178      	str	r0, [r7, #20]
          hadc->Instance->SMPR |= ADC_SMPR_SET(sConfig->SamplingTime);
 8001bf6:	6978      	ldr	r0, [r7, #20]
 8001bf8:	4303      	orrs	r3, r0
 8001bfa:	617b      	str	r3, [r7, #20]
      /* internal measurement paths enable: If internal channel selected,     */
      /* enable dedicated internal buffers and path.                          */
      /* Note: these internal measurement paths can be disabled using         */
      /*       HAL_ADC_DeInit() or removing the channel from sequencer with   */
      /*       channel configuration parameter "Rank".                        */
      if(ADC_IS_CHANNEL_INTERNAL(sConfig->Channel))
 8001bfc:	2a01      	cmp	r2, #1
 8001bfe:	d904      	bls.n	8001c0a <HAL_ADC_ConfigChannel+0x7a>
  HAL_StatusTypeDef tmp_hal_status = HAL_OK;
 8001c00:	2000      	movs	r0, #0
    
    tmp_hal_status = HAL_ERROR;
  }
  
  /* Process unlocked */
  __HAL_UNLOCK(hadc);
 8001c02:	2300      	movs	r3, #0
 8001c04:	7023      	strb	r3, [r4, #0]
  
  /* Return function status */
  return tmp_hal_status;
}
 8001c06:	b005      	add	sp, #20
 8001c08:	bdf0      	pop	{r4, r5, r6, r7, pc}
        ADC->CCR |= ADC_CHANNEL_INTERNAL_PATH(sConfig->Channel);
 8001c0a:	0033      	movs	r3, r6
 8001c0c:	3b10      	subs	r3, #16
 8001c0e:	1e58      	subs	r0, r3, #1
 8001c10:	4183      	sbcs	r3, r0
 8001c12:	2080      	movs	r0, #128	; 0x80
 8001c14:	4919      	ldr	r1, [pc, #100]	; (8001c7c <HAL_ADC_ConfigChannel+0xec>)
 8001c16:	425b      	negs	r3, r3
 8001c18:	680a      	ldr	r2, [r1, #0]
 8001c1a:	059b      	lsls	r3, r3, #22
 8001c1c:	0400      	lsls	r0, r0, #16
 8001c1e:	181b      	adds	r3, r3, r0
 8001c20:	4313      	orrs	r3, r2
 8001c22:	600b      	str	r3, [r1, #0]
        if (sConfig->Channel == ADC_CHANNEL_TEMPSENSOR)
 8001c24:	2e10      	cmp	r6, #16
 8001c26:	d1eb      	bne.n	8001c00 <HAL_ADC_ConfigChannel+0x70>
          wait_loop_index = (ADC_TEMPSENSOR_DELAY_US * (SystemCoreClock / 1000000U));
 8001c28:	4b15      	ldr	r3, [pc, #84]	; (8001c80 <HAL_ADC_ConfigChannel+0xf0>)
 8001c2a:	4916      	ldr	r1, [pc, #88]	; (8001c84 <HAL_ADC_ConfigChannel+0xf4>)
 8001c2c:	6818      	ldr	r0, [r3, #0]
 8001c2e:	f7fe fa7f 	bl	8000130 <__udivsi3>
 8001c32:	230a      	movs	r3, #10
 8001c34:	4358      	muls	r0, r3
 8001c36:	9003      	str	r0, [sp, #12]
          while(wait_loop_index != 0U)
 8001c38:	9b03      	ldr	r3, [sp, #12]
 8001c3a:	2b00      	cmp	r3, #0
 8001c3c:	d0e0      	beq.n	8001c00 <HAL_ADC_ConfigChannel+0x70>
            wait_loop_index--;
 8001c3e:	9b03      	ldr	r3, [sp, #12]
 8001c40:	3b01      	subs	r3, #1
 8001c42:	9303      	str	r3, [sp, #12]
 8001c44:	e7f8      	b.n	8001c38 <HAL_ADC_ConfigChannel+0xa8>
      hadc->Instance->CHSELR &= ~ADC_CHSELR_CHANNEL(sConfig->Channel);
 8001c46:	6ab9      	ldr	r1, [r7, #40]	; 0x28
 8001c48:	9b01      	ldr	r3, [sp, #4]
 8001c4a:	4399      	bics	r1, r3
 8001c4c:	62b9      	str	r1, [r7, #40]	; 0x28
      if(ADC_IS_CHANNEL_INTERNAL(sConfig->Channel))
 8001c4e:	2a01      	cmp	r2, #1
 8001c50:	d8d6      	bhi.n	8001c00 <HAL_ADC_ConfigChannel+0x70>
        ADC->CCR &= ~ADC_CHANNEL_INTERNAL_PATH(sConfig->Channel);
 8001c52:	1e53      	subs	r3, r2, #1
 8001c54:	419a      	sbcs	r2, r3
 8001c56:	4253      	negs	r3, r2
 8001c58:	2280      	movs	r2, #128	; 0x80
 8001c5a:	4908      	ldr	r1, [pc, #32]	; (8001c7c <HAL_ADC_ConfigChannel+0xec>)
 8001c5c:	03d2      	lsls	r2, r2, #15
 8001c5e:	4013      	ands	r3, r2
 8001c60:	4a09      	ldr	r2, [pc, #36]	; (8001c88 <HAL_ADC_ConfigChannel+0xf8>)
 8001c62:	6808      	ldr	r0, [r1, #0]
 8001c64:	189b      	adds	r3, r3, r2
 8001c66:	4003      	ands	r3, r0
 8001c68:	600b      	str	r3, [r1, #0]
 8001c6a:	e7c9      	b.n	8001c00 <HAL_ADC_ConfigChannel+0x70>
    SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
 8001c6c:	2120      	movs	r1, #32
 8001c6e:	6b90      	ldr	r0, [r2, #56]	; 0x38
 8001c70:	4301      	orrs	r1, r0
 8001c72:	6391      	str	r1, [r2, #56]	; 0x38
    tmp_hal_status = HAL_ERROR;
 8001c74:	0018      	movs	r0, r3
 8001c76:	e7c4      	b.n	8001c02 <HAL_ADC_ConfigChannel+0x72>
 8001c78:	00001001 	.word	0x00001001
 8001c7c:	40012708 	.word	0x40012708
 8001c80:	20000024 	.word	0x20000024
 8001c84:	000f4240 	.word	0x000f4240
 8001c88:	ff7fffff 	.word	0xff7fffff

08001c8c <HAL_NVIC_SetPriority>:
  *         with stm32f0xx devices, this parameter is a dummy value and it is ignored, because 
  *         no subpriority supported in Cortex M0 based products.   
  * @retval None
  */
void HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority)
{ 
 8001c8c:	b530      	push	{r4, r5, lr}
 8001c8e:	25ff      	movs	r5, #255	; 0xff
 8001c90:	2403      	movs	r4, #3
 8001c92:	002a      	movs	r2, r5
 8001c94:	b2c3      	uxtb	r3, r0
 8001c96:	401c      	ands	r4, r3
 8001c98:	00e4      	lsls	r4, r4, #3
 8001c9a:	40a2      	lsls	r2, r4
 8001c9c:	0189      	lsls	r1, r1, #6
 8001c9e:	4029      	ands	r1, r5
 8001ca0:	43d2      	mvns	r2, r2
 8001ca2:	40a1      	lsls	r1, r4
  \param [in]  priority  Priority to set.
  \note    The priority cannot be set for every processor exception.
 */
__STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if ((int32_t)(IRQn) >= 0)
 8001ca4:	2800      	cmp	r0, #0
 8001ca6:	db0a      	blt.n	8001cbe <HAL_NVIC_SetPriority+0x32>
  {
    NVIC->IP[_IP_IDX(IRQn)]  = ((uint32_t)(NVIC->IP[_IP_IDX(IRQn)]  & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
 8001ca8:	24c0      	movs	r4, #192	; 0xc0
 8001caa:	4b0b      	ldr	r3, [pc, #44]	; (8001cd8 <HAL_NVIC_SetPriority+0x4c>)
 8001cac:	0880      	lsrs	r0, r0, #2
 8001cae:	0080      	lsls	r0, r0, #2
 8001cb0:	18c0      	adds	r0, r0, r3
 8001cb2:	00a4      	lsls	r4, r4, #2
 8001cb4:	5903      	ldr	r3, [r0, r4]
 8001cb6:	401a      	ands	r2, r3
 8001cb8:	4311      	orrs	r1, r2
 8001cba:	5101      	str	r1, [r0, r4]
  /* Check the parameters */
  assert_param(IS_NVIC_PREEMPTION_PRIORITY(PreemptPriority));
  NVIC_SetPriority(IRQn,PreemptPriority);
}
 8001cbc:	bd30      	pop	{r4, r5, pc}
       (((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
  }
  else
  {
    SCB->SHP[_SHP_IDX(IRQn)] = ((uint32_t)(SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
 8001cbe:	200f      	movs	r0, #15
 8001cc0:	4003      	ands	r3, r0
 8001cc2:	3b08      	subs	r3, #8
 8001cc4:	4805      	ldr	r0, [pc, #20]	; (8001cdc <HAL_NVIC_SetPriority+0x50>)
 8001cc6:	089b      	lsrs	r3, r3, #2
 8001cc8:	009b      	lsls	r3, r3, #2
 8001cca:	181b      	adds	r3, r3, r0
 8001ccc:	69d8      	ldr	r0, [r3, #28]
 8001cce:	4002      	ands	r2, r0
 8001cd0:	4311      	orrs	r1, r2
 8001cd2:	61d9      	str	r1, [r3, #28]
 8001cd4:	e7f2      	b.n	8001cbc <HAL_NVIC_SetPriority+0x30>
 8001cd6:	46c0      	nop			; (mov r8, r8)
 8001cd8:	e000e100 	.word	0xe000e100
 8001cdc:	e000ed00 	.word	0xe000ed00

08001ce0 <HAL_NVIC_EnableIRQ>:
  if ((int32_t)(IRQn) >= 0)
 8001ce0:	2800      	cmp	r0, #0
 8001ce2:	db05      	blt.n	8001cf0 <HAL_NVIC_EnableIRQ+0x10>
    NVIC->ISER[0U] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 8001ce4:	231f      	movs	r3, #31
 8001ce6:	4018      	ands	r0, r3
 8001ce8:	3b1e      	subs	r3, #30
 8001cea:	4083      	lsls	r3, r0
 8001cec:	4a01      	ldr	r2, [pc, #4]	; (8001cf4 <HAL_NVIC_EnableIRQ+0x14>)
 8001cee:	6013      	str	r3, [r2, #0]
  /* Check the parameters */
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));
  
  /* Enable interrupt */
  NVIC_EnableIRQ(IRQn);
}
 8001cf0:	4770      	bx	lr
 8001cf2:	46c0      	nop			; (mov r8, r8)
 8001cf4:	e000e100 	.word	0xe000e100

08001cf8 <HAL_NVIC_DisableIRQ>:
  if ((int32_t)(IRQn) >= 0)
 8001cf8:	2800      	cmp	r0, #0
 8001cfa:	db09      	blt.n	8001d10 <HAL_NVIC_DisableIRQ+0x18>
    NVIC->ICER[0U] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 8001cfc:	231f      	movs	r3, #31
 8001cfe:	4018      	ands	r0, r3
 8001d00:	3b1e      	subs	r3, #30
 8001d02:	4083      	lsls	r3, r0
 8001d04:	4a03      	ldr	r2, [pc, #12]	; (8001d14 <HAL_NVIC_DisableIRQ+0x1c>)
 8001d06:	67d3      	str	r3, [r2, #124]	; 0x7c
  \details Acts as a special kind of Data Memory Barrier.
           It completes when all explicit memory accesses before this instruction complete.
 */
__STATIC_FORCEINLINE void __DSB(void)
{
  __ASM volatile ("dsb 0xF":::"memory");
 8001d08:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
 8001d0c:	f3bf 8f6f 	isb	sy
  /* Check the parameters */
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));
  
  /* Disable interrupt */
  NVIC_DisableIRQ(IRQn);
}
 8001d10:	4770      	bx	lr
 8001d12:	46c0      	nop			; (mov r8, r8)
 8001d14:	e000e104 	.word	0xe000e104

08001d18 <HAL_SYSTICK_Config>:
           function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
           must contain a vendor-specific implementation of this function.
 */
__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
{
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
 8001d18:	4a09      	ldr	r2, [pc, #36]	; (8001d40 <HAL_SYSTICK_Config+0x28>)
 8001d1a:	1e43      	subs	r3, r0, #1
  {
    return (1UL);                                                   /* Reload value impossible */
 8001d1c:	2001      	movs	r0, #1
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
 8001d1e:	4293      	cmp	r3, r2
 8001d20:	d80d      	bhi.n	8001d3e <HAL_SYSTICK_Config+0x26>
    SCB->SHP[_SHP_IDX(IRQn)] = ((uint32_t)(SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
 8001d22:	21c0      	movs	r1, #192	; 0xc0
  }

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
 8001d24:	4a07      	ldr	r2, [pc, #28]	; (8001d44 <HAL_SYSTICK_Config+0x2c>)
    SCB->SHP[_SHP_IDX(IRQn)] = ((uint32_t)(SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
 8001d26:	4808      	ldr	r0, [pc, #32]	; (8001d48 <HAL_SYSTICK_Config+0x30>)
  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
 8001d28:	6053      	str	r3, [r2, #4]
    SCB->SHP[_SHP_IDX(IRQn)] = ((uint32_t)(SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
 8001d2a:	6a03      	ldr	r3, [r0, #32]
 8001d2c:	0609      	lsls	r1, r1, #24
 8001d2e:	021b      	lsls	r3, r3, #8
 8001d30:	0a1b      	lsrs	r3, r3, #8
 8001d32:	430b      	orrs	r3, r1
 8001d34:	6203      	str	r3, [r0, #32]
  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
 8001d36:	2000      	movs	r0, #0
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 8001d38:	2307      	movs	r3, #7
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
 8001d3a:	6090      	str	r0, [r2, #8]
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 8001d3c:	6013      	str	r3, [r2, #0]
  *                  - 1  Function failed.
  */
uint32_t HAL_SYSTICK_Config(uint32_t TicksNumb)
{
   return SysTick_Config(TicksNumb);
}
 8001d3e:	4770      	bx	lr
 8001d40:	00ffffff 	.word	0x00ffffff
 8001d44:	e000e010 	.word	0xe000e010
 8001d48:	e000ed00 	.word	0xe000ed00

08001d4c <HAL_NVIC_ClearPendingIRQ>:
  if ((int32_t)(IRQn) >= 0)
 8001d4c:	2800      	cmp	r0, #0
 8001d4e:	db07      	blt.n	8001d60 <HAL_NVIC_ClearPendingIRQ+0x14>
    NVIC->ICPR[0U] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 8001d50:	231f      	movs	r3, #31
 8001d52:	22c0      	movs	r2, #192	; 0xc0
 8001d54:	4018      	ands	r0, r3
 8001d56:	3b1e      	subs	r3, #30
 8001d58:	4083      	lsls	r3, r0
 8001d5a:	4902      	ldr	r1, [pc, #8]	; (8001d64 <HAL_NVIC_ClearPendingIRQ+0x18>)
 8001d5c:	0052      	lsls	r2, r2, #1
 8001d5e:	508b      	str	r3, [r1, r2]
  /* Check the parameters */
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));
  
  /* Clear pending interrupt */
  NVIC_ClearPendingIRQ(IRQn);
}
 8001d60:	4770      	bx	lr
 8001d62:	46c0      	nop			; (mov r8, r8)
 8001d64:	e000e100 	.word	0xe000e100

08001d68 <HAL_DMA_Init>:
  * @param  hdma Pointer to a DMA_HandleTypeDef structure that contains
  *               the configuration information for the specified DMA Channel.  
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMA_Init(DMA_HandleTypeDef *hdma)
{ 
 8001d68:	b570      	push	{r4, r5, r6, lr}
 8001d6a:	0004      	movs	r4, r0
  uint32_t tmp = 0U;
  
  /* Check the DMA handle allocation */
  if(NULL == hdma)
  {
    return HAL_ERROR;
 8001d6c:	2501      	movs	r5, #1
  if(NULL == hdma)
 8001d6e:	2800      	cmp	r0, #0
 8001d70:	d024      	beq.n	8001dbc <HAL_DMA_Init+0x54>
  assert_param(IS_DMA_MEMORY_DATA_SIZE(hdma->Init.MemDataAlignment));
  assert_param(IS_DMA_MODE(hdma->Init.Mode));
  assert_param(IS_DMA_PRIORITY(hdma->Init.Priority));
  
  /* Change DMA peripheral state */
  hdma->State = HAL_DMA_STATE_BUSY;
 8001d72:	2302      	movs	r3, #2
 8001d74:	1c86      	adds	r6, r0, #2

  /* Get the CR register value */
  tmp = hdma->Instance->CCR;
 8001d76:	6800      	ldr	r0, [r0, #0]
  hdma->State = HAL_DMA_STATE_BUSY;
 8001d78:	77f3      	strb	r3, [r6, #31]
  tmp = hdma->Instance->CCR;
 8001d7a:	6802      	ldr	r2, [r0, #0]
  
  /* Clear PL, MSIZE, PSIZE, MINC, PINC, CIRC, DIR bits */
  tmp &= ((uint32_t)~(DMA_CCR_PL    | DMA_CCR_MSIZE  | DMA_CCR_PSIZE  | \
 8001d7c:	4b10      	ldr	r3, [pc, #64]	; (8001dc0 <HAL_DMA_Init+0x58>)
                      DMA_CCR_MINC  | DMA_CCR_PINC   | DMA_CCR_CIRC   | \
                      DMA_CCR_DIR));
  
  /* Prepare the DMA Channel configuration */
  tmp |=  hdma->Init.Direction        |
 8001d7e:	68a1      	ldr	r1, [r4, #8]
  tmp &= ((uint32_t)~(DMA_CCR_PL    | DMA_CCR_MSIZE  | DMA_CCR_PSIZE  | \
 8001d80:	401a      	ands	r2, r3
  tmp |=  hdma->Init.Direction        |
 8001d82:	6863      	ldr	r3, [r4, #4]
 8001d84:	430b      	orrs	r3, r1
          hdma->Init.PeriphInc           | hdma->Init.MemInc           |
 8001d86:	68e1      	ldr	r1, [r4, #12]
 8001d88:	430b      	orrs	r3, r1
 8001d8a:	6921      	ldr	r1, [r4, #16]
 8001d8c:	430b      	orrs	r3, r1
          hdma->Init.PeriphDataAlignment | hdma->Init.MemDataAlignment |
 8001d8e:	6961      	ldr	r1, [r4, #20]
 8001d90:	430b      	orrs	r3, r1
 8001d92:	69a1      	ldr	r1, [r4, #24]
 8001d94:	430b      	orrs	r3, r1
          hdma->Init.Mode                | hdma->Init.Priority;
 8001d96:	69e1      	ldr	r1, [r4, #28]
 8001d98:	430b      	orrs	r3, r1
  tmp |=  hdma->Init.Direction        |
 8001d9a:	4313      	orrs	r3, r2

  /* Write to DMA Channel CR register */
  hdma->Instance->CCR = tmp;  
 8001d9c:	6003      	str	r3, [r0, #0]
    hdma->DmaBaseAddress = DMA2;
  }
#else
  /* calculation of the channel index */
  /* DMA1 */
  hdma->ChannelIndex = (((uint32_t)hdma->Instance - (uint32_t)DMA1_Channel1) / ((uint32_t)DMA1_Channel2 - (uint32_t)DMA1_Channel1)) << 2U;
 8001d9e:	4b09      	ldr	r3, [pc, #36]	; (8001dc4 <HAL_DMA_Init+0x5c>)
 8001da0:	2114      	movs	r1, #20
 8001da2:	18c0      	adds	r0, r0, r3
 8001da4:	f7fe f9c4 	bl	8000130 <__udivsi3>
  hdma->DmaBaseAddress = DMA1;
 8001da8:	4b07      	ldr	r3, [pc, #28]	; (8001dc8 <HAL_DMA_Init+0x60>)
  hdma->ChannelIndex = (((uint32_t)hdma->Instance - (uint32_t)DMA1_Channel1) / ((uint32_t)DMA1_Channel2 - (uint32_t)DMA1_Channel1)) << 2U;
 8001daa:	0080      	lsls	r0, r0, #2
  hdma->DmaBaseAddress = DMA1;
 8001dac:	63e3      	str	r3, [r4, #60]	; 0x3c
  hdma->ErrorCode = HAL_DMA_ERROR_NONE;
 8001dae:	2300      	movs	r3, #0
  hdma->ChannelIndex = (((uint32_t)hdma->Instance - (uint32_t)DMA1_Channel1) / ((uint32_t)DMA1_Channel2 - (uint32_t)DMA1_Channel1)) << 2U;
 8001db0:	6420      	str	r0, [r4, #64]	; 0x40
  hdma->ErrorCode = HAL_DMA_ERROR_NONE;
 8001db2:	63a3      	str	r3, [r4, #56]	; 0x38
  hdma->State = HAL_DMA_STATE_READY;
 8001db4:	77f5      	strb	r5, [r6, #31]
  hdma->Lock = HAL_UNLOCKED;
 8001db6:	1964      	adds	r4, r4, r5
  return HAL_OK;
 8001db8:	001d      	movs	r5, r3
  hdma->Lock = HAL_UNLOCKED;
 8001dba:	77e3      	strb	r3, [r4, #31]
}  
 8001dbc:	0028      	movs	r0, r5
 8001dbe:	bd70      	pop	{r4, r5, r6, pc}
 8001dc0:	ffffc00f 	.word	0xffffc00f
 8001dc4:	bffdfff8 	.word	0xbffdfff8
 8001dc8:	40020000 	.word	0x40020000

08001dcc <HAL_DMA_Start_IT>:
{
 8001dcc:	b5f0      	push	{r4, r5, r6, r7, lr}
  __HAL_LOCK(hdma);
 8001dce:	1c44      	adds	r4, r0, #1
 8001dd0:	7fe6      	ldrb	r6, [r4, #31]
{
 8001dd2:	0005      	movs	r5, r0
  __HAL_LOCK(hdma);
 8001dd4:	2002      	movs	r0, #2
 8001dd6:	2e01      	cmp	r6, #1
 8001dd8:	d027      	beq.n	8001e2a <HAL_DMA_Start_IT+0x5e>
 8001dda:	3801      	subs	r0, #1
 8001ddc:	77e0      	strb	r0, [r4, #31]
  if(HAL_DMA_STATE_READY == hdma->State)
 8001dde:	1ca8      	adds	r0, r5, #2
 8001de0:	7fc6      	ldrb	r6, [r0, #31]
 8001de2:	4684      	mov	ip, r0
 8001de4:	b2f6      	uxtb	r6, r6
 8001de6:	2002      	movs	r0, #2
 8001de8:	2700      	movs	r7, #0
 8001dea:	2e01      	cmp	r6, #1
 8001dec:	d128      	bne.n	8001e40 <HAL_DMA_Start_IT+0x74>
  	hdma->State = HAL_DMA_STATE_BUSY;
 8001dee:	4664      	mov	r4, ip
 8001df0:	77e0      	strb	r0, [r4, #31]
  	hdma->Instance->CCR &= ~DMA_CCR_EN;
 8001df2:	682c      	ldr	r4, [r5, #0]
  	hdma->ErrorCode = HAL_DMA_ERROR_NONE;
 8001df4:	63af      	str	r7, [r5, #56]	; 0x38
  	hdma->Instance->CCR &= ~DMA_CCR_EN;
 8001df6:	6820      	ldr	r0, [r4, #0]
  hdma->DmaBaseAddress->IFCR  = (DMA_FLAG_GL1 << hdma->ChannelIndex);
 8001df8:	6c2f      	ldr	r7, [r5, #64]	; 0x40
  	hdma->Instance->CCR &= ~DMA_CCR_EN;
 8001dfa:	43b0      	bics	r0, r6
  hdma->DmaBaseAddress->IFCR  = (DMA_FLAG_GL1 << hdma->ChannelIndex);
 8001dfc:	40be      	lsls	r6, r7
  	hdma->Instance->CCR &= ~DMA_CCR_EN;
 8001dfe:	6020      	str	r0, [r4, #0]
  hdma->DmaBaseAddress->IFCR  = (DMA_FLAG_GL1 << hdma->ChannelIndex);
 8001e00:	6be8      	ldr	r0, [r5, #60]	; 0x3c
 8001e02:	6046      	str	r6, [r0, #4]
  hdma->Instance->CNDTR = DataLength;
 8001e04:	6063      	str	r3, [r4, #4]
  if((hdma->Init.Direction) == DMA_MEMORY_TO_PERIPH)
 8001e06:	686b      	ldr	r3, [r5, #4]
 8001e08:	6828      	ldr	r0, [r5, #0]
 8001e0a:	2b10      	cmp	r3, #16
 8001e0c:	d10e      	bne.n	8001e2c <HAL_DMA_Start_IT+0x60>
    hdma->Instance->CPAR = DstAddress;
 8001e0e:	60a2      	str	r2, [r4, #8]
    hdma->Instance->CMAR = SrcAddress;
 8001e10:	60e1      	str	r1, [r4, #12]
    if(NULL != hdma->XferHalfCpltCallback )
 8001e12:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
      hdma->Instance->CCR |= (DMA_IT_TC | DMA_IT_HT | DMA_IT_TE);
 8001e14:	6822      	ldr	r2, [r4, #0]
    if(NULL != hdma->XferHalfCpltCallback )
 8001e16:	2b00      	cmp	r3, #0
 8001e18:	d00b      	beq.n	8001e32 <HAL_DMA_Start_IT+0x66>
      hdma->Instance->CCR |= (DMA_IT_TC | DMA_IT_HT | DMA_IT_TE);
 8001e1a:	230e      	movs	r3, #14
 8001e1c:	4313      	orrs	r3, r2
  		hdma->Instance->CCR &= ~DMA_IT_HT;
 8001e1e:	6023      	str	r3, [r4, #0]
  	hdma->Instance->CCR |= DMA_CCR_EN;
 8001e20:	2301      	movs	r3, #1
 8001e22:	6802      	ldr	r2, [r0, #0]
 8001e24:	4313      	orrs	r3, r2
 8001e26:	6003      	str	r3, [r0, #0]
	HAL_StatusTypeDef status = HAL_OK;
 8001e28:	2000      	movs	r0, #0
} 
 8001e2a:	bdf0      	pop	{r4, r5, r6, r7, pc}
    hdma->Instance->CPAR = SrcAddress;
 8001e2c:	60a1      	str	r1, [r4, #8]
    hdma->Instance->CMAR = DstAddress;
 8001e2e:	60e2      	str	r2, [r4, #12]
 8001e30:	e7ef      	b.n	8001e12 <HAL_DMA_Start_IT+0x46>
  		hdma->Instance->CCR |= (DMA_IT_TC | DMA_IT_TE);
 8001e32:	230a      	movs	r3, #10
 8001e34:	4313      	orrs	r3, r2
  		hdma->Instance->CCR &= ~DMA_IT_HT;
 8001e36:	2204      	movs	r2, #4
  		hdma->Instance->CCR |= (DMA_IT_TC | DMA_IT_TE);
 8001e38:	6023      	str	r3, [r4, #0]
  		hdma->Instance->CCR &= ~DMA_IT_HT;
 8001e3a:	6823      	ldr	r3, [r4, #0]
 8001e3c:	4393      	bics	r3, r2
 8001e3e:	e7ee      	b.n	8001e1e <HAL_DMA_Start_IT+0x52>
    __HAL_UNLOCK(hdma); 
 8001e40:	77e7      	strb	r7, [r4, #31]
 8001e42:	e7f2      	b.n	8001e2a <HAL_DMA_Start_IT+0x5e>

08001e44 <HAL_DMA_Abort_IT>:
{  
 8001e44:	b570      	push	{r4, r5, r6, lr}
  if(HAL_DMA_STATE_BUSY != hdma->State)
 8001e46:	1c84      	adds	r4, r0, #2
 8001e48:	7fe3      	ldrb	r3, [r4, #31]
 8001e4a:	2b02      	cmp	r3, #2
 8001e4c:	d004      	beq.n	8001e58 <HAL_DMA_Abort_IT+0x14>
    hdma->ErrorCode = HAL_DMA_ERROR_NO_XFER;
 8001e4e:	2304      	movs	r3, #4
 8001e50:	6383      	str	r3, [r0, #56]	; 0x38
    status = HAL_ERROR;
 8001e52:	3b03      	subs	r3, #3
}
 8001e54:	0018      	movs	r0, r3
 8001e56:	bd70      	pop	{r4, r5, r6, pc}
    hdma->Instance->CCR &= ~(DMA_IT_TC | DMA_IT_HT | DMA_IT_TE);
 8001e58:	210e      	movs	r1, #14
 8001e5a:	6803      	ldr	r3, [r0, #0]
    hdma->DmaBaseAddress->IFCR = DMA_FLAG_GL1 << hdma->ChannelIndex;
 8001e5c:	6c05      	ldr	r5, [r0, #64]	; 0x40
    hdma->Instance->CCR &= ~(DMA_IT_TC | DMA_IT_HT | DMA_IT_TE);
 8001e5e:	681a      	ldr	r2, [r3, #0]
 8001e60:	438a      	bics	r2, r1
 8001e62:	601a      	str	r2, [r3, #0]
    hdma->Instance->CCR &= ~DMA_CCR_EN;
 8001e64:	2201      	movs	r2, #1
 8001e66:	6819      	ldr	r1, [r3, #0]
 8001e68:	4391      	bics	r1, r2
 8001e6a:	6019      	str	r1, [r3, #0]
    hdma->DmaBaseAddress->IFCR = DMA_FLAG_GL1 << hdma->ChannelIndex;
 8001e6c:	0011      	movs	r1, r2
 8001e6e:	40a9      	lsls	r1, r5
 8001e70:	6bc3      	ldr	r3, [r0, #60]	; 0x3c
 8001e72:	6059      	str	r1, [r3, #4]
    hdma->State = HAL_DMA_STATE_READY;
 8001e74:	77e2      	strb	r2, [r4, #31]
    __HAL_UNLOCK(hdma);
 8001e76:	2400      	movs	r4, #0
 8001e78:	1883      	adds	r3, r0, r2
    if(hdma->XferAbortCallback != NULL)
 8001e7a:	6b42      	ldr	r2, [r0, #52]	; 0x34
    __HAL_UNLOCK(hdma);
 8001e7c:	77dc      	strb	r4, [r3, #31]
  HAL_StatusTypeDef status = HAL_OK;
 8001e7e:	0013      	movs	r3, r2
    if(hdma->XferAbortCallback != NULL)
 8001e80:	42a2      	cmp	r2, r4
 8001e82:	d0e7      	beq.n	8001e54 <HAL_DMA_Abort_IT+0x10>
      hdma->XferAbortCallback(hdma);
 8001e84:	4790      	blx	r2
  HAL_StatusTypeDef status = HAL_OK;
 8001e86:	0023      	movs	r3, r4
 8001e88:	e7e4      	b.n	8001e54 <HAL_DMA_Abort_IT+0x10>

08001e8a <HAL_DMA_IRQHandler>:
{
 8001e8a:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  if ((RESET != (flag_it & (DMA_FLAG_HT1 << hdma->ChannelIndex))) && (RESET != (source_it & DMA_IT_HT)))
 8001e8c:	2704      	movs	r7, #4
 8001e8e:	003e      	movs	r6, r7
 8001e90:	6c01      	ldr	r1, [r0, #64]	; 0x40
	uint32_t flag_it = hdma->DmaBaseAddress->ISR;
 8001e92:	6bc2      	ldr	r2, [r0, #60]	; 0x3c
  if ((RESET != (flag_it & (DMA_FLAG_HT1 << hdma->ChannelIndex))) && (RESET != (source_it & DMA_IT_HT)))
 8001e94:	408e      	lsls	r6, r1
	uint32_t flag_it = hdma->DmaBaseAddress->ISR;
 8001e96:	6815      	ldr	r5, [r2, #0]
  uint32_t source_it = hdma->Instance->CCR;
 8001e98:	6803      	ldr	r3, [r0, #0]
 8001e9a:	681c      	ldr	r4, [r3, #0]
  if ((RESET != (flag_it & (DMA_FLAG_HT1 << hdma->ChannelIndex))) && (RESET != (source_it & DMA_IT_HT)))
 8001e9c:	4235      	tst	r5, r6
 8001e9e:	d00d      	beq.n	8001ebc <HAL_DMA_IRQHandler+0x32>
 8001ea0:	423c      	tst	r4, r7
 8001ea2:	d00b      	beq.n	8001ebc <HAL_DMA_IRQHandler+0x32>
  	if((hdma->Instance->CCR & DMA_CCR_CIRC) == 0U)
 8001ea4:	6819      	ldr	r1, [r3, #0]
 8001ea6:	0689      	lsls	r1, r1, #26
 8001ea8:	d402      	bmi.n	8001eb0 <HAL_DMA_IRQHandler+0x26>
  		hdma->Instance->CCR &= ~DMA_IT_HT;
 8001eaa:	6819      	ldr	r1, [r3, #0]
 8001eac:	43b9      	bics	r1, r7
 8001eae:	6019      	str	r1, [r3, #0]
  	if(hdma->XferHalfCpltCallback != NULL)
 8001eb0:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
  	hdma->DmaBaseAddress->IFCR = DMA_FLAG_HT1 << hdma->ChannelIndex;
 8001eb2:	6056      	str	r6, [r2, #4]
  	if(hdma->XferHalfCpltCallback != NULL)
 8001eb4:	2b00      	cmp	r3, #0
 8001eb6:	d019      	beq.n	8001eec <HAL_DMA_IRQHandler+0x62>
    	hdma->XferErrorCallback(hdma);
 8001eb8:	4798      	blx	r3
}  
 8001eba:	e017      	b.n	8001eec <HAL_DMA_IRQHandler+0x62>
  else if ((RESET != (flag_it & (DMA_FLAG_TC1 << hdma->ChannelIndex))) && (RESET != (source_it & DMA_IT_TC)))
 8001ebc:	2702      	movs	r7, #2
 8001ebe:	003e      	movs	r6, r7
 8001ec0:	408e      	lsls	r6, r1
 8001ec2:	4235      	tst	r5, r6
 8001ec4:	d013      	beq.n	8001eee <HAL_DMA_IRQHandler+0x64>
 8001ec6:	423c      	tst	r4, r7
 8001ec8:	d011      	beq.n	8001eee <HAL_DMA_IRQHandler+0x64>
  	if((hdma->Instance->CCR & DMA_CCR_CIRC) == 0U)
 8001eca:	6819      	ldr	r1, [r3, #0]
 8001ecc:	0689      	lsls	r1, r1, #26
 8001ece:	d406      	bmi.n	8001ede <HAL_DMA_IRQHandler+0x54>
  		hdma->Instance->CCR &= ~(DMA_IT_TC | DMA_IT_TE);
 8001ed0:	240a      	movs	r4, #10
 8001ed2:	6819      	ldr	r1, [r3, #0]
 8001ed4:	43a1      	bics	r1, r4
 8001ed6:	6019      	str	r1, [r3, #0]
  		hdma->State = HAL_DMA_STATE_READY;
 8001ed8:	2101      	movs	r1, #1
 8001eda:	19c3      	adds	r3, r0, r7
 8001edc:	77d9      	strb	r1, [r3, #31]
  	hdma->DmaBaseAddress->IFCR = DMA_FLAG_TC1 << hdma->ChannelIndex;
 8001ede:	6056      	str	r6, [r2, #4]
  	__HAL_UNLOCK(hdma);
 8001ee0:	2200      	movs	r2, #0
 8001ee2:	1c43      	adds	r3, r0, #1
 8001ee4:	77da      	strb	r2, [r3, #31]
  	if(hdma->XferCpltCallback != NULL)
 8001ee6:	6a83      	ldr	r3, [r0, #40]	; 0x28
    if(hdma->XferErrorCallback != NULL)
 8001ee8:	4293      	cmp	r3, r2
 8001eea:	d1e5      	bne.n	8001eb8 <HAL_DMA_IRQHandler+0x2e>
}  
 8001eec:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  else if (( RESET != (flag_it & (DMA_FLAG_TE1 << hdma->ChannelIndex))) && (RESET != (source_it & DMA_IT_TE)))
 8001eee:	2608      	movs	r6, #8
 8001ef0:	0037      	movs	r7, r6
 8001ef2:	408f      	lsls	r7, r1
 8001ef4:	423d      	tst	r5, r7
 8001ef6:	d0f9      	beq.n	8001eec <HAL_DMA_IRQHandler+0x62>
 8001ef8:	4234      	tst	r4, r6
 8001efa:	d0f7      	beq.n	8001eec <HAL_DMA_IRQHandler+0x62>
    hdma->Instance->CCR &= ~(DMA_IT_TC | DMA_IT_HT | DMA_IT_TE);
 8001efc:	250e      	movs	r5, #14
 8001efe:	681c      	ldr	r4, [r3, #0]
 8001f00:	43ac      	bics	r4, r5
 8001f02:	601c      	str	r4, [r3, #0]
    hdma->DmaBaseAddress->IFCR = DMA_FLAG_GL1 << hdma->ChannelIndex;
 8001f04:	2301      	movs	r3, #1
 8001f06:	001c      	movs	r4, r3
 8001f08:	408c      	lsls	r4, r1
 8001f0a:	6054      	str	r4, [r2, #4]
    hdma->State = HAL_DMA_STATE_READY;    
 8001f0c:	1c82      	adds	r2, r0, #2
    hdma->ErrorCode = HAL_DMA_ERROR_TE;
 8001f0e:	6383      	str	r3, [r0, #56]	; 0x38
    hdma->State = HAL_DMA_STATE_READY;    
 8001f10:	77d3      	strb	r3, [r2, #31]
    __HAL_UNLOCK(hdma); 
 8001f12:	2200      	movs	r2, #0
 8001f14:	18c3      	adds	r3, r0, r3
 8001f16:	77da      	strb	r2, [r3, #31]
    if(hdma->XferErrorCallback != NULL)
 8001f18:	6b03      	ldr	r3, [r0, #48]	; 0x30
 8001f1a:	e7e5      	b.n	8001ee8 <HAL_DMA_IRQHandler+0x5e>

08001f1c <FLASH_SetErrorCode>:
  */
static void FLASH_SetErrorCode(void)
{
  uint32_t flags = 0U;
  
  if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_WRPERR))
 8001f1c:	2110      	movs	r1, #16
 8001f1e:	4b0c      	ldr	r3, [pc, #48]	; (8001f50 <FLASH_SetErrorCode+0x34>)
{
 8001f20:	b530      	push	{r4, r5, lr}
  if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_WRPERR))
 8001f22:	68d8      	ldr	r0, [r3, #12]
  uint32_t flags = 0U;
 8001f24:	2200      	movs	r2, #0
  if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_WRPERR))
 8001f26:	4208      	tst	r0, r1
 8001f28:	d005      	beq.n	8001f36 <FLASH_SetErrorCode+0x1a>
  {
    pFlash.ErrorCode |= HAL_FLASH_ERROR_WRP;
 8001f2a:	480a      	ldr	r0, [pc, #40]	; (8001f54 <FLASH_SetErrorCode+0x38>)
 8001f2c:	3202      	adds	r2, #2
 8001f2e:	69c4      	ldr	r4, [r0, #28]
 8001f30:	4322      	orrs	r2, r4
 8001f32:	61c2      	str	r2, [r0, #28]
    flags |= FLASH_FLAG_WRPERR;
 8001f34:	000a      	movs	r2, r1
  }
  if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_PGERR))
 8001f36:	2004      	movs	r0, #4
 8001f38:	68d9      	ldr	r1, [r3, #12]
 8001f3a:	4201      	tst	r1, r0
 8001f3c:	d005      	beq.n	8001f4a <FLASH_SetErrorCode+0x2e>
  {
    pFlash.ErrorCode |= HAL_FLASH_ERROR_PROG;
 8001f3e:	2101      	movs	r1, #1
 8001f40:	4c04      	ldr	r4, [pc, #16]	; (8001f54 <FLASH_SetErrorCode+0x38>)
    flags |= FLASH_FLAG_PGERR;
 8001f42:	4302      	orrs	r2, r0
    pFlash.ErrorCode |= HAL_FLASH_ERROR_PROG;
 8001f44:	69e5      	ldr	r5, [r4, #28]
 8001f46:	4329      	orrs	r1, r5
 8001f48:	61e1      	str	r1, [r4, #28]
  }
  /* Clear FLASH error pending bits */
  __HAL_FLASH_CLEAR_FLAG(flags);
 8001f4a:	60da      	str	r2, [r3, #12]
}  
 8001f4c:	bd30      	pop	{r4, r5, pc}
 8001f4e:	46c0      	nop			; (mov r8, r8)
 8001f50:	40022000 	.word	0x40022000
 8001f54:	20000468 	.word	0x20000468

08001f58 <HAL_FLASH_Unlock>:
  if(READ_BIT(FLASH->CR, FLASH_CR_LOCK) != RESET)
 8001f58:	4b06      	ldr	r3, [pc, #24]	; (8001f74 <HAL_FLASH_Unlock+0x1c>)
  HAL_StatusTypeDef status = HAL_OK;
 8001f5a:	2000      	movs	r0, #0
  if(READ_BIT(FLASH->CR, FLASH_CR_LOCK) != RESET)
 8001f5c:	691a      	ldr	r2, [r3, #16]
 8001f5e:	0612      	lsls	r2, r2, #24
 8001f60:	d506      	bpl.n	8001f70 <HAL_FLASH_Unlock+0x18>
    WRITE_REG(FLASH->KEYR, FLASH_KEY1);
 8001f62:	4a05      	ldr	r2, [pc, #20]	; (8001f78 <HAL_FLASH_Unlock+0x20>)
 8001f64:	605a      	str	r2, [r3, #4]
    WRITE_REG(FLASH->KEYR, FLASH_KEY2);
 8001f66:	4a05      	ldr	r2, [pc, #20]	; (8001f7c <HAL_FLASH_Unlock+0x24>)
 8001f68:	605a      	str	r2, [r3, #4]
    if(READ_BIT(FLASH->CR, FLASH_CR_LOCK) != RESET)
 8001f6a:	6918      	ldr	r0, [r3, #16]
 8001f6c:	0600      	lsls	r0, r0, #24
  HAL_StatusTypeDef status = HAL_OK;
 8001f6e:	0fc0      	lsrs	r0, r0, #31
}
 8001f70:	4770      	bx	lr
 8001f72:	46c0      	nop			; (mov r8, r8)
 8001f74:	40022000 	.word	0x40022000
 8001f78:	45670123 	.word	0x45670123
 8001f7c:	cdef89ab 	.word	0xcdef89ab

08001f80 <HAL_FLASH_Lock>:
  SET_BIT(FLASH->CR, FLASH_CR_LOCK);
 8001f80:	2380      	movs	r3, #128	; 0x80
 8001f82:	4a03      	ldr	r2, [pc, #12]	; (8001f90 <HAL_FLASH_Lock+0x10>)
}
 8001f84:	2000      	movs	r0, #0
  SET_BIT(FLASH->CR, FLASH_CR_LOCK);
 8001f86:	6911      	ldr	r1, [r2, #16]
 8001f88:	430b      	orrs	r3, r1
 8001f8a:	6113      	str	r3, [r2, #16]
}
 8001f8c:	4770      	bx	lr
 8001f8e:	46c0      	nop			; (mov r8, r8)
 8001f90:	40022000 	.word	0x40022000

08001f94 <FLASH_WaitForLastOperation>:
{
 8001f94:	b570      	push	{r4, r5, r6, lr}
 8001f96:	0004      	movs	r4, r0
  uint32_t tickstart = HAL_GetTick();
 8001f98:	f7ff fd3c 	bl	8001a14 <HAL_GetTick>
  while(__HAL_FLASH_GET_FLAG(FLASH_FLAG_BSY)) 
 8001f9c:	2501      	movs	r5, #1
  uint32_t tickstart = HAL_GetTick();
 8001f9e:	0006      	movs	r6, r0
  while(__HAL_FLASH_GET_FLAG(FLASH_FLAG_BSY)) 
 8001fa0:	4b10      	ldr	r3, [pc, #64]	; (8001fe4 <FLASH_WaitForLastOperation+0x50>)
 8001fa2:	001a      	movs	r2, r3
 8001fa4:	68d9      	ldr	r1, [r3, #12]
 8001fa6:	4229      	tst	r1, r5
 8001fa8:	d10f      	bne.n	8001fca <FLASH_WaitForLastOperation+0x36>
  if (__HAL_FLASH_GET_FLAG(FLASH_FLAG_EOP))
 8001faa:	2120      	movs	r1, #32
 8001fac:	68d8      	ldr	r0, [r3, #12]
 8001fae:	4208      	tst	r0, r1
 8001fb0:	d000      	beq.n	8001fb4 <FLASH_WaitForLastOperation+0x20>
    __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_EOP);
 8001fb2:	60d9      	str	r1, [r3, #12]
  if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_WRPERR)  || 
 8001fb4:	2310      	movs	r3, #16
 8001fb6:	68d0      	ldr	r0, [r2, #12]
 8001fb8:	4018      	ands	r0, r3
 8001fba:	d102      	bne.n	8001fc2 <FLASH_WaitForLastOperation+0x2e>
     __HAL_FLASH_GET_FLAG(FLASH_FLAG_PGERR))
 8001fbc:	68d3      	ldr	r3, [r2, #12]
  if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_WRPERR)  || 
 8001fbe:	075b      	lsls	r3, r3, #29
 8001fc0:	d508      	bpl.n	8001fd4 <FLASH_WaitForLastOperation+0x40>
    FLASH_SetErrorCode();
 8001fc2:	f7ff ffab 	bl	8001f1c <FLASH_SetErrorCode>
    return HAL_ERROR;
 8001fc6:	2001      	movs	r0, #1
 8001fc8:	e004      	b.n	8001fd4 <FLASH_WaitForLastOperation+0x40>
    if (Timeout != HAL_MAX_DELAY)
 8001fca:	1c61      	adds	r1, r4, #1
 8001fcc:	d0ea      	beq.n	8001fa4 <FLASH_WaitForLastOperation+0x10>
      if((Timeout == 0U) || ((HAL_GetTick()-tickstart) > Timeout))
 8001fce:	2c00      	cmp	r4, #0
 8001fd0:	d101      	bne.n	8001fd6 <FLASH_WaitForLastOperation+0x42>
        return HAL_TIMEOUT;
 8001fd2:	2003      	movs	r0, #3
}
 8001fd4:	bd70      	pop	{r4, r5, r6, pc}
      if((Timeout == 0U) || ((HAL_GetTick()-tickstart) > Timeout))
 8001fd6:	f7ff fd1d 	bl	8001a14 <HAL_GetTick>
 8001fda:	1b80      	subs	r0, r0, r6
 8001fdc:	42a0      	cmp	r0, r4
 8001fde:	d9df      	bls.n	8001fa0 <FLASH_WaitForLastOperation+0xc>
 8001fe0:	e7f7      	b.n	8001fd2 <FLASH_WaitForLastOperation+0x3e>
 8001fe2:	46c0      	nop			; (mov r8, r8)
 8001fe4:	40022000 	.word	0x40022000

08001fe8 <HAL_FLASH_Program>:
{
 8001fe8:	b5f0      	push	{r4, r5, r6, r7, lr}
 8001fea:	b085      	sub	sp, #20
 8001fec:	9202      	str	r2, [sp, #8]
 8001fee:	9303      	str	r3, [sp, #12]
  __HAL_LOCK(&pFlash);
 8001ff0:	4b1b      	ldr	r3, [pc, #108]	; (8002060 <HAL_FLASH_Program+0x78>)
{
 8001ff2:	9101      	str	r1, [sp, #4]
  __HAL_LOCK(&pFlash);
 8001ff4:	7e1a      	ldrb	r2, [r3, #24]
{
 8001ff6:	0004      	movs	r4, r0
  __HAL_LOCK(&pFlash);
 8001ff8:	2002      	movs	r0, #2
 8001ffa:	2a01      	cmp	r2, #1
 8001ffc:	d02e      	beq.n	800205c <HAL_FLASH_Program+0x74>
 8001ffe:	2201      	movs	r2, #1
    status = FLASH_WaitForLastOperation(FLASH_TIMEOUT_VALUE);
 8002000:	4818      	ldr	r0, [pc, #96]	; (8002064 <HAL_FLASH_Program+0x7c>)
  __HAL_LOCK(&pFlash);
 8002002:	761a      	strb	r2, [r3, #24]
    status = FLASH_WaitForLastOperation(FLASH_TIMEOUT_VALUE);
 8002004:	f7ff ffc6 	bl	8001f94 <FLASH_WaitForLastOperation>
  if(status == HAL_OK)
 8002008:	2800      	cmp	r0, #0
 800200a:	d124      	bne.n	8002056 <HAL_FLASH_Program+0x6e>
      nbiterations = 1U;
 800200c:	0026      	movs	r6, r4
    if(TypeProgram == FLASH_TYPEPROGRAM_HALFWORD)
 800200e:	2c01      	cmp	r4, #1
 8002010:	d002      	beq.n	8002018 <HAL_FLASH_Program+0x30>
    else if(TypeProgram == FLASH_TYPEPROGRAM_WORD)
 8002012:	2c02      	cmp	r4, #2
 8002014:	d000      	beq.n	8002018 <HAL_FLASH_Program+0x30>
      nbiterations = 4U;
 8002016:	2604      	movs	r6, #4
 8002018:	2400      	movs	r4, #0
      FLASH_Program_HalfWord((Address + (2U*index)), (uint16_t)(Data >> (16U*index)));
 800201a:	9802      	ldr	r0, [sp, #8]
 800201c:	9903      	ldr	r1, [sp, #12]
 800201e:	0122      	lsls	r2, r4, #4
 8002020:	f7fe f912 	bl	8000248 <__aeabi_llsr>
  pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;
 8002024:	2200      	movs	r2, #0
    SET_BIT(FLASH->CR, FLASH_CR_PG);
 8002026:	2701      	movs	r7, #1
  pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;
 8002028:	4b0d      	ldr	r3, [pc, #52]	; (8002060 <HAL_FLASH_Program+0x78>)
    SET_BIT(FLASH->CR, FLASH_CR_PG);
 800202a:	4d0f      	ldr	r5, [pc, #60]	; (8002068 <HAL_FLASH_Program+0x80>)
  pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;
 800202c:	61da      	str	r2, [r3, #28]
    SET_BIT(FLASH->CR, FLASH_CR_PG);
 800202e:	692b      	ldr	r3, [r5, #16]
 8002030:	9a01      	ldr	r2, [sp, #4]
 8002032:	433b      	orrs	r3, r7
 8002034:	612b      	str	r3, [r5, #16]
 8002036:	0063      	lsls	r3, r4, #1
 8002038:	189b      	adds	r3, r3, r2
      FLASH_Program_HalfWord((Address + (2U*index)), (uint16_t)(Data >> (16U*index)));
 800203a:	b280      	uxth	r0, r0
  *(__IO uint16_t*)Address = Data;
 800203c:	8018      	strh	r0, [r3, #0]
        status = FLASH_WaitForLastOperation(FLASH_TIMEOUT_VALUE);
 800203e:	4809      	ldr	r0, [pc, #36]	; (8002064 <HAL_FLASH_Program+0x7c>)
 8002040:	f7ff ffa8 	bl	8001f94 <FLASH_WaitForLastOperation>
        CLEAR_BIT(FLASH->CR, FLASH_CR_PG);
 8002044:	692b      	ldr	r3, [r5, #16]
 8002046:	43bb      	bics	r3, r7
 8002048:	612b      	str	r3, [r5, #16]
      if (status != HAL_OK)
 800204a:	2800      	cmp	r0, #0
 800204c:	d103      	bne.n	8002056 <HAL_FLASH_Program+0x6e>
 800204e:	19e4      	adds	r4, r4, r7
    for (index = 0U; index < nbiterations; index++)
 8002050:	b2e3      	uxtb	r3, r4
 8002052:	429e      	cmp	r6, r3
 8002054:	d8e1      	bhi.n	800201a <HAL_FLASH_Program+0x32>
  __HAL_UNLOCK(&pFlash);
 8002056:	2200      	movs	r2, #0
 8002058:	4b01      	ldr	r3, [pc, #4]	; (8002060 <HAL_FLASH_Program+0x78>)
 800205a:	761a      	strb	r2, [r3, #24]
}
 800205c:	b005      	add	sp, #20
 800205e:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8002060:	20000468 	.word	0x20000468
 8002064:	0000c350 	.word	0x0000c350
 8002068:	40022000 	.word	0x40022000

0800206c <FLASH_MassErase>:
  * @retval None
  */
static void FLASH_MassErase(void)
{
  /* Clean the error context */
  pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;
 800206c:	2200      	movs	r2, #0
 800206e:	4b06      	ldr	r3, [pc, #24]	; (8002088 <FLASH_MassErase+0x1c>)
 8002070:	61da      	str	r2, [r3, #28]

    /* Only bank1 will be erased*/
    SET_BIT(FLASH->CR, FLASH_CR_MER);
 8002072:	4b06      	ldr	r3, [pc, #24]	; (800208c <FLASH_MassErase+0x20>)
 8002074:	3204      	adds	r2, #4
 8002076:	6919      	ldr	r1, [r3, #16]
 8002078:	430a      	orrs	r2, r1
 800207a:	611a      	str	r2, [r3, #16]
    SET_BIT(FLASH->CR, FLASH_CR_STRT);
 800207c:	2240      	movs	r2, #64	; 0x40
 800207e:	6919      	ldr	r1, [r3, #16]
 8002080:	430a      	orrs	r2, r1
 8002082:	611a      	str	r2, [r3, #16]
}
 8002084:	4770      	bx	lr
 8002086:	46c0      	nop			; (mov r8, r8)
 8002088:	20000468 	.word	0x20000468
 800208c:	40022000 	.word	0x40022000

08002090 <FLASH_PageErase>:
  * @retval None
  */
void FLASH_PageErase(uint32_t PageAddress)
{
  /* Clean the error context */
  pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;
 8002090:	2200      	movs	r2, #0
 8002092:	4b06      	ldr	r3, [pc, #24]	; (80020ac <FLASH_PageErase+0x1c>)
 8002094:	61da      	str	r2, [r3, #28]

    /* Proceed to erase the page */
    SET_BIT(FLASH->CR, FLASH_CR_PER);
 8002096:	4b06      	ldr	r3, [pc, #24]	; (80020b0 <FLASH_PageErase+0x20>)
 8002098:	3202      	adds	r2, #2
 800209a:	6919      	ldr	r1, [r3, #16]
 800209c:	430a      	orrs	r2, r1
 800209e:	611a      	str	r2, [r3, #16]
    WRITE_REG(FLASH->AR, PageAddress);
    SET_BIT(FLASH->CR, FLASH_CR_STRT);
 80020a0:	2240      	movs	r2, #64	; 0x40
    WRITE_REG(FLASH->AR, PageAddress);
 80020a2:	6158      	str	r0, [r3, #20]
    SET_BIT(FLASH->CR, FLASH_CR_STRT);
 80020a4:	6919      	ldr	r1, [r3, #16]
 80020a6:	430a      	orrs	r2, r1
 80020a8:	611a      	str	r2, [r3, #16]
}
 80020aa:	4770      	bx	lr
 80020ac:	20000468 	.word	0x20000468
 80020b0:	40022000 	.word	0x40022000

080020b4 <HAL_FLASHEx_Erase>:
{
 80020b4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  __HAL_LOCK(&pFlash);
 80020b6:	4e21      	ldr	r6, [pc, #132]	; (800213c <HAL_FLASHEx_Erase+0x88>)
{
 80020b8:	0005      	movs	r5, r0
  __HAL_LOCK(&pFlash);
 80020ba:	7e33      	ldrb	r3, [r6, #24]
{
 80020bc:	000f      	movs	r7, r1
  __HAL_LOCK(&pFlash);
 80020be:	2002      	movs	r0, #2
 80020c0:	2b01      	cmp	r3, #1
 80020c2:	d00c      	beq.n	80020de <HAL_FLASHEx_Erase+0x2a>
 80020c4:	2301      	movs	r3, #1
 80020c6:	7633      	strb	r3, [r6, #24]
  if (pEraseInit->TypeErase == FLASH_TYPEERASE_MASSERASE)
 80020c8:	682b      	ldr	r3, [r5, #0]
      if (FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE) == HAL_OK)
 80020ca:	481d      	ldr	r0, [pc, #116]	; (8002140 <HAL_FLASHEx_Erase+0x8c>)
  if (pEraseInit->TypeErase == FLASH_TYPEERASE_MASSERASE)
 80020cc:	2b01      	cmp	r3, #1
 80020ce:	d112      	bne.n	80020f6 <HAL_FLASHEx_Erase+0x42>
      if (FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE) == HAL_OK)
 80020d0:	f7ff ff60 	bl	8001f94 <FLASH_WaitForLastOperation>
 80020d4:	2800      	cmp	r0, #0
 80020d6:	d003      	beq.n	80020e0 <HAL_FLASHEx_Erase+0x2c>
  HAL_StatusTypeDef status = HAL_ERROR;
 80020d8:	2001      	movs	r0, #1
  __HAL_UNLOCK(&pFlash);
 80020da:	2300      	movs	r3, #0
 80020dc:	7633      	strb	r3, [r6, #24]
}
 80020de:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        FLASH_MassErase();
 80020e0:	f7ff ffc4 	bl	800206c <FLASH_MassErase>
        status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
 80020e4:	4816      	ldr	r0, [pc, #88]	; (8002140 <HAL_FLASHEx_Erase+0x8c>)
 80020e6:	f7ff ff55 	bl	8001f94 <FLASH_WaitForLastOperation>
        CLEAR_BIT(FLASH->CR, FLASH_CR_MER);
 80020ea:	2104      	movs	r1, #4
 80020ec:	4a15      	ldr	r2, [pc, #84]	; (8002144 <HAL_FLASHEx_Erase+0x90>)
 80020ee:	6913      	ldr	r3, [r2, #16]
 80020f0:	438b      	bics	r3, r1
 80020f2:	6113      	str	r3, [r2, #16]
 80020f4:	e7f1      	b.n	80020da <HAL_FLASHEx_Erase+0x26>
      if (FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE) == HAL_OK)
 80020f6:	f7ff ff4d 	bl	8001f94 <FLASH_WaitForLastOperation>
 80020fa:	2800      	cmp	r0, #0
 80020fc:	d1ec      	bne.n	80020d8 <HAL_FLASHEx_Erase+0x24>
        *PageError = 0xFFFFFFFFU;
 80020fe:	2301      	movs	r3, #1
 8002100:	425b      	negs	r3, r3
 8002102:	603b      	str	r3, [r7, #0]
        for(address = pEraseInit->PageAddress;
 8002104:	686c      	ldr	r4, [r5, #4]
  HAL_StatusTypeDef status = HAL_ERROR;
 8002106:	3001      	adds	r0, #1
            address < ((pEraseInit->NbPages * FLASH_PAGE_SIZE) + pEraseInit->PageAddress);
 8002108:	68ab      	ldr	r3, [r5, #8]
 800210a:	686a      	ldr	r2, [r5, #4]
 800210c:	029b      	lsls	r3, r3, #10
 800210e:	189b      	adds	r3, r3, r2
        for(address = pEraseInit->PageAddress;
 8002110:	42a3      	cmp	r3, r4
 8002112:	d9e2      	bls.n	80020da <HAL_FLASHEx_Erase+0x26>
          FLASH_PageErase(address);
 8002114:	0020      	movs	r0, r4
 8002116:	f7ff ffbb 	bl	8002090 <FLASH_PageErase>
          status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
 800211a:	4809      	ldr	r0, [pc, #36]	; (8002140 <HAL_FLASHEx_Erase+0x8c>)
 800211c:	f7ff ff3a 	bl	8001f94 <FLASH_WaitForLastOperation>
          CLEAR_BIT(FLASH->CR, FLASH_CR_PER);
 8002120:	2102      	movs	r1, #2
 8002122:	4a08      	ldr	r2, [pc, #32]	; (8002144 <HAL_FLASHEx_Erase+0x90>)
 8002124:	6913      	ldr	r3, [r2, #16]
 8002126:	438b      	bics	r3, r1
 8002128:	6113      	str	r3, [r2, #16]
          if (status != HAL_OK)
 800212a:	2800      	cmp	r0, #0
 800212c:	d001      	beq.n	8002132 <HAL_FLASHEx_Erase+0x7e>
            *PageError = address;
 800212e:	603c      	str	r4, [r7, #0]
            break;
 8002130:	e7d3      	b.n	80020da <HAL_FLASHEx_Erase+0x26>
            address += FLASH_PAGE_SIZE)
 8002132:	2380      	movs	r3, #128	; 0x80
 8002134:	00db      	lsls	r3, r3, #3
 8002136:	18e4      	adds	r4, r4, r3
 8002138:	e7e6      	b.n	8002108 <HAL_FLASHEx_Erase+0x54>
 800213a:	46c0      	nop			; (mov r8, r8)
 800213c:	20000468 	.word	0x20000468
 8002140:	0000c350 	.word	0x0000c350
 8002144:	40022000 	.word	0x40022000

08002148 <HAL_GPIO_Init>:
  * @param  GPIO_Init pointer to a GPIO_InitTypeDef structure that contains
  *         the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init)
{ 
 8002148:	b5f0      	push	{r4, r5, r6, r7, lr}
  assert_param(IS_GPIO_PIN(GPIO_Init->Pin));
  assert_param(IS_GPIO_MODE(GPIO_Init->Mode));
  assert_param(IS_GPIO_PULL(GPIO_Init->Pull));

  /* Configure the port pins */
  while (((GPIO_Init->Pin) >> position) != 0x00u)
 800214a:	680b      	ldr	r3, [r1, #0]
{ 
 800214c:	b087      	sub	sp, #28
  while (((GPIO_Init->Pin) >> position) != 0x00u)
 800214e:	9303      	str	r3, [sp, #12]
  uint32_t position = 0x00u;
 8002150:	2300      	movs	r3, #0
{ 
 8002152:	9101      	str	r1, [sp, #4]
  while (((GPIO_Init->Pin) >> position) != 0x00u)
 8002154:	9a03      	ldr	r2, [sp, #12]
 8002156:	40da      	lsrs	r2, r3
 8002158:	d101      	bne.n	800215e <HAL_GPIO_Init+0x16>
      }
    }

    position++;
  } 
}
 800215a:	b007      	add	sp, #28
 800215c:	bdf0      	pop	{r4, r5, r6, r7, pc}
    iocurrent = (GPIO_Init->Pin) & (1uL << position);
 800215e:	2201      	movs	r2, #1
 8002160:	409a      	lsls	r2, r3
 8002162:	9202      	str	r2, [sp, #8]
 8002164:	9902      	ldr	r1, [sp, #8]
 8002166:	9a03      	ldr	r2, [sp, #12]
 8002168:	400a      	ands	r2, r1
 800216a:	9200      	str	r2, [sp, #0]
    if (iocurrent != 0x00u)
 800216c:	d100      	bne.n	8002170 <HAL_GPIO_Init+0x28>
 800216e:	e08c      	b.n	800228a <HAL_GPIO_Init+0x142>
      if((GPIO_Init->Mode == GPIO_MODE_AF_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
 8002170:	9a01      	ldr	r2, [sp, #4]
 8002172:	2110      	movs	r1, #16
 8002174:	6852      	ldr	r2, [r2, #4]
 8002176:	0016      	movs	r6, r2
 8002178:	438e      	bics	r6, r1
 800217a:	2e02      	cmp	r6, #2
 800217c:	d10e      	bne.n	800219c <HAL_GPIO_Init+0x54>
        temp &= ~(0xFu << ((position & 0x07u) * 4u));
 800217e:	2507      	movs	r5, #7
 8002180:	401d      	ands	r5, r3
 8002182:	00ad      	lsls	r5, r5, #2
 8002184:	3901      	subs	r1, #1
 8002186:	40a9      	lsls	r1, r5
        temp = GPIOx->AFR[position >> 3u];
 8002188:	08dc      	lsrs	r4, r3, #3
 800218a:	00a4      	lsls	r4, r4, #2
 800218c:	1904      	adds	r4, r0, r4
 800218e:	6a27      	ldr	r7, [r4, #32]
        temp &= ~(0xFu << ((position & 0x07u) * 4u));
 8002190:	438f      	bics	r7, r1
        temp |= ((GPIO_Init->Alternate) << ((position & 0x07u) * 4u));
 8002192:	9901      	ldr	r1, [sp, #4]
 8002194:	6909      	ldr	r1, [r1, #16]
 8002196:	40a9      	lsls	r1, r5
 8002198:	430f      	orrs	r7, r1
        GPIOx->AFR[position >> 3u] = temp;
 800219a:	6227      	str	r7, [r4, #32]
      temp &= ~(GPIO_MODER_MODER0 << (position * 2u));
 800219c:	2403      	movs	r4, #3
 800219e:	005f      	lsls	r7, r3, #1
 80021a0:	40bc      	lsls	r4, r7
 80021a2:	43e4      	mvns	r4, r4
      temp = GPIOx->MODER;
 80021a4:	6805      	ldr	r5, [r0, #0]
      if((GPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_PP) ||
 80021a6:	3e01      	subs	r6, #1
      temp &= ~(GPIO_MODER_MODER0 << (position * 2u));
 80021a8:	4025      	ands	r5, r4
 80021aa:	46ac      	mov	ip, r5
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2u));
 80021ac:	2503      	movs	r5, #3
 80021ae:	4015      	ands	r5, r2
 80021b0:	40bd      	lsls	r5, r7
 80021b2:	4661      	mov	r1, ip
 80021b4:	430d      	orrs	r5, r1
      GPIOx->MODER = temp;
 80021b6:	6005      	str	r5, [r0, #0]
      if((GPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_PP) ||
 80021b8:	2e01      	cmp	r6, #1
 80021ba:	d80f      	bhi.n	80021dc <HAL_GPIO_Init+0x94>
        temp |= (GPIO_Init->Speed << (position * 2u));
 80021bc:	9901      	ldr	r1, [sp, #4]
        temp = GPIOx->OSPEEDR;
 80021be:	6886      	ldr	r6, [r0, #8]
        temp |= (GPIO_Init->Speed << (position * 2u));
 80021c0:	68cd      	ldr	r5, [r1, #12]
        temp &= ~(GPIO_OSPEEDER_OSPEEDR0 << (position * 2u));
 80021c2:	4026      	ands	r6, r4
        temp |= (GPIO_Init->Speed << (position * 2u));
 80021c4:	40bd      	lsls	r5, r7
 80021c6:	4335      	orrs	r5, r6
        GPIOx->OSPEEDR = temp;
 80021c8:	6085      	str	r5, [r0, #8]
        temp = GPIOx->OTYPER;
 80021ca:	6846      	ldr	r6, [r0, #4]
        temp &= ~(GPIO_OTYPER_OT_0 << position) ;
 80021cc:	9902      	ldr	r1, [sp, #8]
        temp |= (((GPIO_Init->Mode & GPIO_OUTPUT_TYPE) >> 4u) << position);
 80021ce:	0915      	lsrs	r5, r2, #4
        temp &= ~(GPIO_OTYPER_OT_0 << position) ;
 80021d0:	438e      	bics	r6, r1
        temp |= (((GPIO_Init->Mode & GPIO_OUTPUT_TYPE) >> 4u) << position);
 80021d2:	2101      	movs	r1, #1
 80021d4:	400d      	ands	r5, r1
 80021d6:	409d      	lsls	r5, r3
 80021d8:	4335      	orrs	r5, r6
        GPIOx->OTYPER = temp;
 80021da:	6045      	str	r5, [r0, #4]
      temp = GPIOx->PUPDR;
 80021dc:	68c5      	ldr	r5, [r0, #12]
      temp |= ((GPIO_Init->Pull) << (position * 2u));
 80021de:	9901      	ldr	r1, [sp, #4]
      temp &= ~(GPIO_PUPDR_PUPDR0 << (position * 2u));
 80021e0:	402c      	ands	r4, r5
      temp |= ((GPIO_Init->Pull) << (position * 2u));
 80021e2:	688d      	ldr	r5, [r1, #8]
      if((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE)
 80021e4:	2180      	movs	r1, #128	; 0x80
      temp |= ((GPIO_Init->Pull) << (position * 2u));
 80021e6:	40bd      	lsls	r5, r7
      if((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE)
 80021e8:	0549      	lsls	r1, r1, #21
      temp |= ((GPIO_Init->Pull) << (position * 2u));
 80021ea:	432c      	orrs	r4, r5
      GPIOx->PUPDR = temp;
 80021ec:	60c4      	str	r4, [r0, #12]
      if((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE)
 80021ee:	420a      	tst	r2, r1
 80021f0:	d04b      	beq.n	800228a <HAL_GPIO_Init+0x142>
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 80021f2:	2101      	movs	r1, #1
 80021f4:	4c26      	ldr	r4, [pc, #152]	; (8002290 <HAL_GPIO_Init+0x148>)
        temp &= ~(0x0FuL << (4u * (position & 0x03u)));
 80021f6:	2603      	movs	r6, #3
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 80021f8:	69a5      	ldr	r5, [r4, #24]
        temp &= ~(0x0FuL << (4u * (position & 0x03u)));
 80021fa:	401e      	ands	r6, r3
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 80021fc:	430d      	orrs	r5, r1
 80021fe:	61a5      	str	r5, [r4, #24]
 8002200:	69a4      	ldr	r4, [r4, #24]
        temp = SYSCFG->EXTICR[position >> 2u];
 8002202:	089d      	lsrs	r5, r3, #2
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 8002204:	400c      	ands	r4, r1
 8002206:	9405      	str	r4, [sp, #20]
 8002208:	9c05      	ldr	r4, [sp, #20]
        temp &= ~(0x0FuL << (4u * (position & 0x03u)));
 800220a:	240f      	movs	r4, #15
 800220c:	4921      	ldr	r1, [pc, #132]	; (8002294 <HAL_GPIO_Init+0x14c>)
 800220e:	00ad      	lsls	r5, r5, #2
 8002210:	00b6      	lsls	r6, r6, #2
 8002212:	186d      	adds	r5, r5, r1
 8002214:	40b4      	lsls	r4, r6
        temp |= (GPIO_GET_INDEX(GPIOx) << (4u * (position & 0x03u)));
 8002216:	2190      	movs	r1, #144	; 0x90
        temp = SYSCFG->EXTICR[position >> 2u];
 8002218:	68af      	ldr	r7, [r5, #8]
        temp |= (GPIO_GET_INDEX(GPIOx) << (4u * (position & 0x03u)));
 800221a:	05c9      	lsls	r1, r1, #23
        temp &= ~(0x0FuL << (4u * (position & 0x03u)));
 800221c:	43a7      	bics	r7, r4
        temp |= (GPIO_GET_INDEX(GPIOx) << (4u * (position & 0x03u)));
 800221e:	2400      	movs	r4, #0
 8002220:	4288      	cmp	r0, r1
 8002222:	d00c      	beq.n	800223e <HAL_GPIO_Init+0xf6>
 8002224:	491c      	ldr	r1, [pc, #112]	; (8002298 <HAL_GPIO_Init+0x150>)
 8002226:	3401      	adds	r4, #1
 8002228:	4288      	cmp	r0, r1
 800222a:	d008      	beq.n	800223e <HAL_GPIO_Init+0xf6>
 800222c:	491b      	ldr	r1, [pc, #108]	; (800229c <HAL_GPIO_Init+0x154>)
 800222e:	3401      	adds	r4, #1
 8002230:	4288      	cmp	r0, r1
 8002232:	d004      	beq.n	800223e <HAL_GPIO_Init+0xf6>
 8002234:	491a      	ldr	r1, [pc, #104]	; (80022a0 <HAL_GPIO_Init+0x158>)
 8002236:	3403      	adds	r4, #3
 8002238:	4288      	cmp	r0, r1
 800223a:	d100      	bne.n	800223e <HAL_GPIO_Init+0xf6>
 800223c:	3c02      	subs	r4, #2
 800223e:	40b4      	lsls	r4, r6
        temp &= ~(iocurrent);
 8002240:	9900      	ldr	r1, [sp, #0]
        temp |= (GPIO_GET_INDEX(GPIOx) << (4u * (position & 0x03u)));
 8002242:	433c      	orrs	r4, r7
          temp |= iocurrent;
 8002244:	000e      	movs	r6, r1
        SYSCFG->EXTICR[position >> 2u] = temp;
 8002246:	60ac      	str	r4, [r5, #8]
        temp = EXTI->IMR;
 8002248:	4c16      	ldr	r4, [pc, #88]	; (80022a4 <HAL_GPIO_Init+0x15c>)
        temp &= ~(iocurrent);
 800224a:	43cd      	mvns	r5, r1
        temp = EXTI->IMR;
 800224c:	6827      	ldr	r7, [r4, #0]
          temp |= iocurrent;
 800224e:	433e      	orrs	r6, r7
        if((GPIO_Init->Mode & GPIO_MODE_IT) == GPIO_MODE_IT)
 8002250:	03d1      	lsls	r1, r2, #15
 8002252:	d401      	bmi.n	8002258 <HAL_GPIO_Init+0x110>
        temp &= ~(iocurrent);
 8002254:	003e      	movs	r6, r7
 8002256:	402e      	ands	r6, r5
        EXTI->IMR = temp;
 8002258:	6026      	str	r6, [r4, #0]
        temp = EXTI->EMR;
 800225a:	6867      	ldr	r7, [r4, #4]
          temp |= iocurrent;
 800225c:	9e00      	ldr	r6, [sp, #0]
 800225e:	433e      	orrs	r6, r7
        if((GPIO_Init->Mode & GPIO_MODE_EVT) == GPIO_MODE_EVT)
 8002260:	0391      	lsls	r1, r2, #14
 8002262:	d401      	bmi.n	8002268 <HAL_GPIO_Init+0x120>
        temp &= ~(iocurrent);
 8002264:	003e      	movs	r6, r7
 8002266:	402e      	ands	r6, r5
        EXTI->EMR = temp;
 8002268:	6066      	str	r6, [r4, #4]
        temp = EXTI->RTSR;
 800226a:	68a7      	ldr	r7, [r4, #8]
          temp |= iocurrent;
 800226c:	9e00      	ldr	r6, [sp, #0]
 800226e:	433e      	orrs	r6, r7
        if((GPIO_Init->Mode & RISING_EDGE) == RISING_EDGE)
 8002270:	02d1      	lsls	r1, r2, #11
 8002272:	d401      	bmi.n	8002278 <HAL_GPIO_Init+0x130>
        temp &= ~(iocurrent);
 8002274:	003e      	movs	r6, r7
 8002276:	402e      	ands	r6, r5
        EXTI->RTSR = temp;
 8002278:	60a6      	str	r6, [r4, #8]
        temp = EXTI->FTSR;
 800227a:	68e6      	ldr	r6, [r4, #12]
          temp |= iocurrent;
 800227c:	9f00      	ldr	r7, [sp, #0]
 800227e:	4337      	orrs	r7, r6
        if((GPIO_Init->Mode & FALLING_EDGE) == FALLING_EDGE)
 8002280:	0292      	lsls	r2, r2, #10
 8002282:	d401      	bmi.n	8002288 <HAL_GPIO_Init+0x140>
        temp &= ~(iocurrent);
 8002284:	402e      	ands	r6, r5
 8002286:	0037      	movs	r7, r6
        EXTI->FTSR = temp;
 8002288:	60e7      	str	r7, [r4, #12]
    position++;
 800228a:	3301      	adds	r3, #1
 800228c:	e762      	b.n	8002154 <HAL_GPIO_Init+0xc>
 800228e:	46c0      	nop			; (mov r8, r8)
 8002290:	40021000 	.word	0x40021000
 8002294:	40010000 	.word	0x40010000
 8002298:	48000400 	.word	0x48000400
 800229c:	48000800 	.word	0x48000800
 80022a0:	48000c00 	.word	0x48000c00
 80022a4:	40010400 	.word	0x40010400

080022a8 <HAL_GPIO_ReadPin>:
  GPIO_PinState bitstatus;

  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));

  if ((GPIOx->IDR & GPIO_Pin) != (uint32_t)GPIO_PIN_RESET)
 80022a8:	6900      	ldr	r0, [r0, #16]
 80022aa:	4008      	ands	r0, r1
 80022ac:	1e41      	subs	r1, r0, #1
 80022ae:	4188      	sbcs	r0, r1
  }
  else
  {
    bitstatus = GPIO_PIN_RESET;
  }
  return bitstatus;
 80022b0:	b2c0      	uxtb	r0, r0
  }
 80022b2:	4770      	bx	lr

080022b4 <HAL_GPIO_WritePin>:
{
  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));
  assert_param(IS_GPIO_PIN_ACTION(PinState));

  if (PinState != GPIO_PIN_RESET)
 80022b4:	2a00      	cmp	r2, #0
 80022b6:	d001      	beq.n	80022bc <HAL_GPIO_WritePin+0x8>
  {
    GPIOx->BSRR = (uint32_t)GPIO_Pin;
 80022b8:	6181      	str	r1, [r0, #24]
  }
  else
  {
    GPIOx->BRR = (uint32_t)GPIO_Pin;
  }
}
 80022ba:	4770      	bx	lr
    GPIOx->BRR = (uint32_t)GPIO_Pin;
 80022bc:	6281      	str	r1, [r0, #40]	; 0x28
}
 80022be:	e7fc      	b.n	80022ba <HAL_GPIO_WritePin+0x6>

080022c0 <HAL_GPIO_EXTI_Callback>:
  UNUSED(GPIO_Pin);

  /* NOTE: This function should not be modified, when the callback is needed,
            the HAL_GPIO_EXTI_Callback could be implemented in the user file
   */ 
}
 80022c0:	4770      	bx	lr
	...

080022c4 <HAL_GPIO_EXTI_IRQHandler>:
  if(__HAL_GPIO_EXTI_GET_IT(GPIO_Pin) != 0x00u)
 80022c4:	4b04      	ldr	r3, [pc, #16]	; (80022d8 <HAL_GPIO_EXTI_IRQHandler+0x14>)
{
 80022c6:	b510      	push	{r4, lr}
  if(__HAL_GPIO_EXTI_GET_IT(GPIO_Pin) != 0x00u)
 80022c8:	695a      	ldr	r2, [r3, #20]
 80022ca:	4210      	tst	r0, r2
 80022cc:	d002      	beq.n	80022d4 <HAL_GPIO_EXTI_IRQHandler+0x10>
    __HAL_GPIO_EXTI_CLEAR_IT(GPIO_Pin);
 80022ce:	6158      	str	r0, [r3, #20]
    HAL_GPIO_EXTI_Callback(GPIO_Pin);
 80022d0:	f7ff fff6 	bl	80022c0 <HAL_GPIO_EXTI_Callback>
}
 80022d4:	bd10      	pop	{r4, pc}
 80022d6:	46c0      	nop			; (mov r8, r8)
 80022d8:	40010400 	.word	0x40010400

080022dc <HAL_RCC_OscConfig>:
  *         supported by this macro. User should request a transition to HSE Off
  *         first and then HSE On or HSE Bypass.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCC_OscConfig(RCC_OscInitTypeDef  *RCC_OscInitStruct)
{
 80022dc:	b5f0      	push	{r4, r5, r6, r7, lr}
 80022de:	0004      	movs	r4, r0
 80022e0:	b085      	sub	sp, #20
  uint32_t tickstart;
  uint32_t pll_config;
  uint32_t pll_config2;

  /* Check Null pointer */
  if(RCC_OscInitStruct == NULL)
 80022e2:	2800      	cmp	r0, #0
 80022e4:	d102      	bne.n	80022ec <HAL_RCC_OscConfig+0x10>
  {
    return HAL_ERROR;
 80022e6:	2001      	movs	r0, #1
      }
    }
  }

  return HAL_OK;
}
 80022e8:	b005      	add	sp, #20
 80022ea:	bdf0      	pop	{r4, r5, r6, r7, pc}
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
 80022ec:	6803      	ldr	r3, [r0, #0]
 80022ee:	07db      	lsls	r3, r3, #31
 80022f0:	d42e      	bmi.n	8002350 <HAL_RCC_OscConfig+0x74>
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI) == RCC_OSCILLATORTYPE_HSI)
 80022f2:	6823      	ldr	r3, [r4, #0]
 80022f4:	079b      	lsls	r3, r3, #30
 80022f6:	d47e      	bmi.n	80023f6 <HAL_RCC_OscConfig+0x11a>
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI)
 80022f8:	6823      	ldr	r3, [r4, #0]
 80022fa:	071b      	lsls	r3, r3, #28
 80022fc:	d500      	bpl.n	8002300 <HAL_RCC_OscConfig+0x24>
 80022fe:	e0ba      	b.n	8002476 <HAL_RCC_OscConfig+0x19a>
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSE) == RCC_OSCILLATORTYPE_LSE)
 8002300:	6823      	ldr	r3, [r4, #0]
 8002302:	075b      	lsls	r3, r3, #29
 8002304:	d500      	bpl.n	8002308 <HAL_RCC_OscConfig+0x2c>
 8002306:	e0dd      	b.n	80024c4 <HAL_RCC_OscConfig+0x1e8>
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI14) == RCC_OSCILLATORTYPE_HSI14)
 8002308:	6823      	ldr	r3, [r4, #0]
 800230a:	06db      	lsls	r3, r3, #27
 800230c:	d51a      	bpl.n	8002344 <HAL_RCC_OscConfig+0x68>
    if(RCC_OscInitStruct->HSI14State == RCC_HSI14_ON)
 800230e:	6962      	ldr	r2, [r4, #20]
 8002310:	4db4      	ldr	r5, [pc, #720]	; (80025e4 <HAL_RCC_OscConfig+0x308>)
 8002312:	2304      	movs	r3, #4
 8002314:	2a01      	cmp	r2, #1
 8002316:	d000      	beq.n	800231a <HAL_RCC_OscConfig+0x3e>
 8002318:	e149      	b.n	80025ae <HAL_RCC_OscConfig+0x2d2>
      __HAL_RCC_HSI14ADC_DISABLE();
 800231a:	6b69      	ldr	r1, [r5, #52]	; 0x34
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSI14RDY) == RESET)
 800231c:	2602      	movs	r6, #2
      __HAL_RCC_HSI14ADC_DISABLE();
 800231e:	430b      	orrs	r3, r1
 8002320:	636b      	str	r3, [r5, #52]	; 0x34
      __HAL_RCC_HSI14_ENABLE();
 8002322:	6b6b      	ldr	r3, [r5, #52]	; 0x34
 8002324:	431a      	orrs	r2, r3
 8002326:	636a      	str	r2, [r5, #52]	; 0x34
      tickstart = HAL_GetTick();
 8002328:	f7ff fb74 	bl	8001a14 <HAL_GetTick>
 800232c:	0007      	movs	r7, r0
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSI14RDY) == RESET)
 800232e:	6b6b      	ldr	r3, [r5, #52]	; 0x34
 8002330:	4233      	tst	r3, r6
 8002332:	d100      	bne.n	8002336 <HAL_RCC_OscConfig+0x5a>
 8002334:	e134      	b.n	80025a0 <HAL_RCC_OscConfig+0x2c4>
      __HAL_RCC_HSI14_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSI14CalibrationValue);
 8002336:	21f8      	movs	r1, #248	; 0xf8
 8002338:	6b6a      	ldr	r2, [r5, #52]	; 0x34
 800233a:	69a3      	ldr	r3, [r4, #24]
 800233c:	438a      	bics	r2, r1
 800233e:	00db      	lsls	r3, r3, #3
 8002340:	4313      	orrs	r3, r2
 8002342:	636b      	str	r3, [r5, #52]	; 0x34
  if ((RCC_OscInitStruct->PLL.PLLState) != RCC_PLL_NONE)
 8002344:	6a23      	ldr	r3, [r4, #32]
 8002346:	2b00      	cmp	r3, #0
 8002348:	d000      	beq.n	800234c <HAL_RCC_OscConfig+0x70>
 800234a:	e157      	b.n	80025fc <HAL_RCC_OscConfig+0x320>
  return HAL_OK;
 800234c:	2000      	movs	r0, #0
 800234e:	e7cb      	b.n	80022e8 <HAL_RCC_OscConfig+0xc>
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_HSE) 
 8002350:	210c      	movs	r1, #12
 8002352:	4da4      	ldr	r5, [pc, #656]	; (80025e4 <HAL_RCC_OscConfig+0x308>)
 8002354:	686a      	ldr	r2, [r5, #4]
 8002356:	400a      	ands	r2, r1
 8002358:	2a04      	cmp	r2, #4
 800235a:	d006      	beq.n	800236a <HAL_RCC_OscConfig+0x8e>
       || ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && (__HAL_RCC_GET_PLL_OSCSOURCE() == RCC_PLLSOURCE_HSE)))
 800235c:	686b      	ldr	r3, [r5, #4]
 800235e:	400b      	ands	r3, r1
 8002360:	2b08      	cmp	r3, #8
 8002362:	d109      	bne.n	8002378 <HAL_RCC_OscConfig+0x9c>
 8002364:	686b      	ldr	r3, [r5, #4]
 8002366:	03db      	lsls	r3, r3, #15
 8002368:	d506      	bpl.n	8002378 <HAL_RCC_OscConfig+0x9c>
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET) && (RCC_OscInitStruct->HSEState == RCC_HSE_OFF))
 800236a:	682b      	ldr	r3, [r5, #0]
 800236c:	039b      	lsls	r3, r3, #14
 800236e:	d5c0      	bpl.n	80022f2 <HAL_RCC_OscConfig+0x16>
 8002370:	6863      	ldr	r3, [r4, #4]
 8002372:	2b00      	cmp	r3, #0
 8002374:	d1bd      	bne.n	80022f2 <HAL_RCC_OscConfig+0x16>
 8002376:	e7b6      	b.n	80022e6 <HAL_RCC_OscConfig+0xa>
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 8002378:	6863      	ldr	r3, [r4, #4]
 800237a:	2b01      	cmp	r3, #1
 800237c:	d113      	bne.n	80023a6 <HAL_RCC_OscConfig+0xca>
 800237e:	2380      	movs	r3, #128	; 0x80
 8002380:	682a      	ldr	r2, [r5, #0]
 8002382:	025b      	lsls	r3, r3, #9
 8002384:	4313      	orrs	r3, r2
 8002386:	602b      	str	r3, [r5, #0]
        tickstart = HAL_GetTick();
 8002388:	f7ff fb44 	bl	8001a14 <HAL_GetTick>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 800238c:	2680      	movs	r6, #128	; 0x80
        tickstart = HAL_GetTick();
 800238e:	0007      	movs	r7, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 8002390:	02b6      	lsls	r6, r6, #10
 8002392:	682b      	ldr	r3, [r5, #0]
 8002394:	4233      	tst	r3, r6
 8002396:	d1ac      	bne.n	80022f2 <HAL_RCC_OscConfig+0x16>
          if((HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
 8002398:	f7ff fb3c 	bl	8001a14 <HAL_GetTick>
 800239c:	1bc0      	subs	r0, r0, r7
 800239e:	2864      	cmp	r0, #100	; 0x64
 80023a0:	d9f7      	bls.n	8002392 <HAL_RCC_OscConfig+0xb6>
            return HAL_TIMEOUT;
 80023a2:	2003      	movs	r0, #3
 80023a4:	e7a0      	b.n	80022e8 <HAL_RCC_OscConfig+0xc>
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 80023a6:	2b00      	cmp	r3, #0
 80023a8:	d115      	bne.n	80023d6 <HAL_RCC_OscConfig+0xfa>
 80023aa:	682b      	ldr	r3, [r5, #0]
 80023ac:	4a8e      	ldr	r2, [pc, #568]	; (80025e8 <HAL_RCC_OscConfig+0x30c>)
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
 80023ae:	2680      	movs	r6, #128	; 0x80
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 80023b0:	4013      	ands	r3, r2
 80023b2:	602b      	str	r3, [r5, #0]
 80023b4:	682b      	ldr	r3, [r5, #0]
 80023b6:	4a8d      	ldr	r2, [pc, #564]	; (80025ec <HAL_RCC_OscConfig+0x310>)
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
 80023b8:	02b6      	lsls	r6, r6, #10
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 80023ba:	4013      	ands	r3, r2
 80023bc:	602b      	str	r3, [r5, #0]
        tickstart = HAL_GetTick();
 80023be:	f7ff fb29 	bl	8001a14 <HAL_GetTick>
 80023c2:	0007      	movs	r7, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
 80023c4:	682b      	ldr	r3, [r5, #0]
 80023c6:	4233      	tst	r3, r6
 80023c8:	d093      	beq.n	80022f2 <HAL_RCC_OscConfig+0x16>
           if((HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
 80023ca:	f7ff fb23 	bl	8001a14 <HAL_GetTick>
 80023ce:	1bc0      	subs	r0, r0, r7
 80023d0:	2864      	cmp	r0, #100	; 0x64
 80023d2:	d9f7      	bls.n	80023c4 <HAL_RCC_OscConfig+0xe8>
 80023d4:	e7e5      	b.n	80023a2 <HAL_RCC_OscConfig+0xc6>
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 80023d6:	2b05      	cmp	r3, #5
 80023d8:	d105      	bne.n	80023e6 <HAL_RCC_OscConfig+0x10a>
 80023da:	2380      	movs	r3, #128	; 0x80
 80023dc:	682a      	ldr	r2, [r5, #0]
 80023de:	02db      	lsls	r3, r3, #11
 80023e0:	4313      	orrs	r3, r2
 80023e2:	602b      	str	r3, [r5, #0]
 80023e4:	e7cb      	b.n	800237e <HAL_RCC_OscConfig+0xa2>
 80023e6:	682b      	ldr	r3, [r5, #0]
 80023e8:	4a7f      	ldr	r2, [pc, #508]	; (80025e8 <HAL_RCC_OscConfig+0x30c>)
 80023ea:	4013      	ands	r3, r2
 80023ec:	602b      	str	r3, [r5, #0]
 80023ee:	682b      	ldr	r3, [r5, #0]
 80023f0:	4a7e      	ldr	r2, [pc, #504]	; (80025ec <HAL_RCC_OscConfig+0x310>)
 80023f2:	4013      	ands	r3, r2
 80023f4:	e7c7      	b.n	8002386 <HAL_RCC_OscConfig+0xaa>
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_HSI) 
 80023f6:	220c      	movs	r2, #12
 80023f8:	4d7a      	ldr	r5, [pc, #488]	; (80025e4 <HAL_RCC_OscConfig+0x308>)
 80023fa:	686b      	ldr	r3, [r5, #4]
 80023fc:	4213      	tst	r3, r2
 80023fe:	d006      	beq.n	800240e <HAL_RCC_OscConfig+0x132>
       || ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && (__HAL_RCC_GET_PLL_OSCSOURCE() == RCC_PLLSOURCE_HSI)))
 8002400:	686b      	ldr	r3, [r5, #4]
 8002402:	4013      	ands	r3, r2
 8002404:	2b08      	cmp	r3, #8
 8002406:	d111      	bne.n	800242c <HAL_RCC_OscConfig+0x150>
 8002408:	686b      	ldr	r3, [r5, #4]
 800240a:	03db      	lsls	r3, r3, #15
 800240c:	d40e      	bmi.n	800242c <HAL_RCC_OscConfig+0x150>
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET) && (RCC_OscInitStruct->HSIState != RCC_HSI_ON))
 800240e:	682b      	ldr	r3, [r5, #0]
 8002410:	079b      	lsls	r3, r3, #30
 8002412:	d503      	bpl.n	800241c <HAL_RCC_OscConfig+0x140>
 8002414:	68e3      	ldr	r3, [r4, #12]
 8002416:	2b01      	cmp	r3, #1
 8002418:	d000      	beq.n	800241c <HAL_RCC_OscConfig+0x140>
 800241a:	e764      	b.n	80022e6 <HAL_RCC_OscConfig+0xa>
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 800241c:	21f8      	movs	r1, #248	; 0xf8
 800241e:	682a      	ldr	r2, [r5, #0]
 8002420:	6923      	ldr	r3, [r4, #16]
 8002422:	438a      	bics	r2, r1
 8002424:	00db      	lsls	r3, r3, #3
 8002426:	4313      	orrs	r3, r2
 8002428:	602b      	str	r3, [r5, #0]
 800242a:	e765      	b.n	80022f8 <HAL_RCC_OscConfig+0x1c>
      if(RCC_OscInitStruct->HSIState != RCC_HSI_OFF)
 800242c:	68e2      	ldr	r2, [r4, #12]
 800242e:	2301      	movs	r3, #1
 8002430:	2a00      	cmp	r2, #0
 8002432:	d00f      	beq.n	8002454 <HAL_RCC_OscConfig+0x178>
        __HAL_RCC_HSI_ENABLE();
 8002434:	682a      	ldr	r2, [r5, #0]
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 8002436:	2602      	movs	r6, #2
        __HAL_RCC_HSI_ENABLE();
 8002438:	4313      	orrs	r3, r2
 800243a:	602b      	str	r3, [r5, #0]
        tickstart = HAL_GetTick();
 800243c:	f7ff faea 	bl	8001a14 <HAL_GetTick>
 8002440:	0007      	movs	r7, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 8002442:	682b      	ldr	r3, [r5, #0]
 8002444:	4233      	tst	r3, r6
 8002446:	d1e9      	bne.n	800241c <HAL_RCC_OscConfig+0x140>
          if((HAL_GetTick() - tickstart ) > HSI_TIMEOUT_VALUE)
 8002448:	f7ff fae4 	bl	8001a14 <HAL_GetTick>
 800244c:	1bc0      	subs	r0, r0, r7
 800244e:	2802      	cmp	r0, #2
 8002450:	d9f7      	bls.n	8002442 <HAL_RCC_OscConfig+0x166>
 8002452:	e7a6      	b.n	80023a2 <HAL_RCC_OscConfig+0xc6>
        __HAL_RCC_HSI_DISABLE();
 8002454:	682a      	ldr	r2, [r5, #0]
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET)
 8002456:	2602      	movs	r6, #2
        __HAL_RCC_HSI_DISABLE();
 8002458:	439a      	bics	r2, r3
 800245a:	602a      	str	r2, [r5, #0]
        tickstart = HAL_GetTick();
 800245c:	f7ff fada 	bl	8001a14 <HAL_GetTick>
 8002460:	0007      	movs	r7, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET)
 8002462:	682b      	ldr	r3, [r5, #0]
 8002464:	4233      	tst	r3, r6
 8002466:	d100      	bne.n	800246a <HAL_RCC_OscConfig+0x18e>
 8002468:	e746      	b.n	80022f8 <HAL_RCC_OscConfig+0x1c>
          if((HAL_GetTick() - tickstart ) > HSI_TIMEOUT_VALUE)
 800246a:	f7ff fad3 	bl	8001a14 <HAL_GetTick>
 800246e:	1bc0      	subs	r0, r0, r7
 8002470:	2802      	cmp	r0, #2
 8002472:	d9f6      	bls.n	8002462 <HAL_RCC_OscConfig+0x186>
 8002474:	e795      	b.n	80023a2 <HAL_RCC_OscConfig+0xc6>
    if(RCC_OscInitStruct->LSIState != RCC_LSI_OFF)
 8002476:	69e2      	ldr	r2, [r4, #28]
 8002478:	2301      	movs	r3, #1
 800247a:	4d5a      	ldr	r5, [pc, #360]	; (80025e4 <HAL_RCC_OscConfig+0x308>)
 800247c:	2a00      	cmp	r2, #0
 800247e:	d010      	beq.n	80024a2 <HAL_RCC_OscConfig+0x1c6>
      __HAL_RCC_LSI_ENABLE();
 8002480:	6a6a      	ldr	r2, [r5, #36]	; 0x24
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == RESET)
 8002482:	2602      	movs	r6, #2
      __HAL_RCC_LSI_ENABLE();
 8002484:	4313      	orrs	r3, r2
 8002486:	626b      	str	r3, [r5, #36]	; 0x24
      tickstart = HAL_GetTick();
 8002488:	f7ff fac4 	bl	8001a14 <HAL_GetTick>
 800248c:	0007      	movs	r7, r0
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == RESET)
 800248e:	6a6b      	ldr	r3, [r5, #36]	; 0x24
 8002490:	4233      	tst	r3, r6
 8002492:	d000      	beq.n	8002496 <HAL_RCC_OscConfig+0x1ba>
 8002494:	e734      	b.n	8002300 <HAL_RCC_OscConfig+0x24>
        if((HAL_GetTick() - tickstart ) > LSI_TIMEOUT_VALUE)
 8002496:	f7ff fabd 	bl	8001a14 <HAL_GetTick>
 800249a:	1bc0      	subs	r0, r0, r7
 800249c:	2802      	cmp	r0, #2
 800249e:	d9f6      	bls.n	800248e <HAL_RCC_OscConfig+0x1b2>
 80024a0:	e77f      	b.n	80023a2 <HAL_RCC_OscConfig+0xc6>
      __HAL_RCC_LSI_DISABLE();
 80024a2:	6a6a      	ldr	r2, [r5, #36]	; 0x24
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != RESET)
 80024a4:	2602      	movs	r6, #2
      __HAL_RCC_LSI_DISABLE();
 80024a6:	439a      	bics	r2, r3
 80024a8:	626a      	str	r2, [r5, #36]	; 0x24
      tickstart = HAL_GetTick();
 80024aa:	f7ff fab3 	bl	8001a14 <HAL_GetTick>
 80024ae:	0007      	movs	r7, r0
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != RESET)
 80024b0:	6a6b      	ldr	r3, [r5, #36]	; 0x24
 80024b2:	4233      	tst	r3, r6
 80024b4:	d100      	bne.n	80024b8 <HAL_RCC_OscConfig+0x1dc>
 80024b6:	e723      	b.n	8002300 <HAL_RCC_OscConfig+0x24>
        if((HAL_GetTick() - tickstart ) > LSI_TIMEOUT_VALUE)
 80024b8:	f7ff faac 	bl	8001a14 <HAL_GetTick>
 80024bc:	1bc0      	subs	r0, r0, r7
 80024be:	2802      	cmp	r0, #2
 80024c0:	d9f6      	bls.n	80024b0 <HAL_RCC_OscConfig+0x1d4>
 80024c2:	e76e      	b.n	80023a2 <HAL_RCC_OscConfig+0xc6>
    if(__HAL_RCC_PWR_IS_CLK_DISABLED())
 80024c4:	2280      	movs	r2, #128	; 0x80
    FlagStatus       pwrclkchanged = RESET;
 80024c6:	2100      	movs	r1, #0
    if(__HAL_RCC_PWR_IS_CLK_DISABLED())
 80024c8:	4d46      	ldr	r5, [pc, #280]	; (80025e4 <HAL_RCC_OscConfig+0x308>)
 80024ca:	0552      	lsls	r2, r2, #21
 80024cc:	69eb      	ldr	r3, [r5, #28]
    FlagStatus       pwrclkchanged = RESET;
 80024ce:	9100      	str	r1, [sp, #0]
    if(__HAL_RCC_PWR_IS_CLK_DISABLED())
 80024d0:	4213      	tst	r3, r2
 80024d2:	d108      	bne.n	80024e6 <HAL_RCC_OscConfig+0x20a>
      __HAL_RCC_PWR_CLK_ENABLE();
 80024d4:	69eb      	ldr	r3, [r5, #28]
 80024d6:	4313      	orrs	r3, r2
 80024d8:	61eb      	str	r3, [r5, #28]
 80024da:	69eb      	ldr	r3, [r5, #28]
 80024dc:	4013      	ands	r3, r2
 80024de:	9303      	str	r3, [sp, #12]
 80024e0:	9b03      	ldr	r3, [sp, #12]
      pwrclkchanged = SET;
 80024e2:	2301      	movs	r3, #1
 80024e4:	9300      	str	r3, [sp, #0]
    if(HAL_IS_BIT_CLR(PWR->CR, PWR_CR_DBP))
 80024e6:	2780      	movs	r7, #128	; 0x80
 80024e8:	4e41      	ldr	r6, [pc, #260]	; (80025f0 <HAL_RCC_OscConfig+0x314>)
 80024ea:	007f      	lsls	r7, r7, #1
 80024ec:	6833      	ldr	r3, [r6, #0]
 80024ee:	423b      	tst	r3, r7
 80024f0:	d006      	beq.n	8002500 <HAL_RCC_OscConfig+0x224>
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 80024f2:	68a3      	ldr	r3, [r4, #8]
 80024f4:	2b01      	cmp	r3, #1
 80024f6:	d113      	bne.n	8002520 <HAL_RCC_OscConfig+0x244>
 80024f8:	6a2a      	ldr	r2, [r5, #32]
 80024fa:	4313      	orrs	r3, r2
 80024fc:	622b      	str	r3, [r5, #32]
 80024fe:	e030      	b.n	8002562 <HAL_RCC_OscConfig+0x286>
      SET_BIT(PWR->CR, PWR_CR_DBP);
 8002500:	6833      	ldr	r3, [r6, #0]
 8002502:	433b      	orrs	r3, r7
 8002504:	6033      	str	r3, [r6, #0]
      tickstart = HAL_GetTick();
 8002506:	f7ff fa85 	bl	8001a14 <HAL_GetTick>
 800250a:	9001      	str	r0, [sp, #4]
      while(HAL_IS_BIT_CLR(PWR->CR, PWR_CR_DBP))
 800250c:	6833      	ldr	r3, [r6, #0]
 800250e:	423b      	tst	r3, r7
 8002510:	d1ef      	bne.n	80024f2 <HAL_RCC_OscConfig+0x216>
        if((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
 8002512:	f7ff fa7f 	bl	8001a14 <HAL_GetTick>
 8002516:	9b01      	ldr	r3, [sp, #4]
 8002518:	1ac0      	subs	r0, r0, r3
 800251a:	2864      	cmp	r0, #100	; 0x64
 800251c:	d9f6      	bls.n	800250c <HAL_RCC_OscConfig+0x230>
 800251e:	e740      	b.n	80023a2 <HAL_RCC_OscConfig+0xc6>
 8002520:	2201      	movs	r2, #1
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 8002522:	2b00      	cmp	r3, #0
 8002524:	d114      	bne.n	8002550 <HAL_RCC_OscConfig+0x274>
 8002526:	6a2b      	ldr	r3, [r5, #32]
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
 8002528:	2702      	movs	r7, #2
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 800252a:	4393      	bics	r3, r2
 800252c:	622b      	str	r3, [r5, #32]
 800252e:	6a2b      	ldr	r3, [r5, #32]
 8002530:	3203      	adds	r2, #3
 8002532:	4393      	bics	r3, r2
 8002534:	622b      	str	r3, [r5, #32]
      tickstart = HAL_GetTick();
 8002536:	f7ff fa6d 	bl	8001a14 <HAL_GetTick>
 800253a:	0006      	movs	r6, r0
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
 800253c:	6a2b      	ldr	r3, [r5, #32]
 800253e:	423b      	tst	r3, r7
 8002540:	d025      	beq.n	800258e <HAL_RCC_OscConfig+0x2b2>
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 8002542:	f7ff fa67 	bl	8001a14 <HAL_GetTick>
 8002546:	4b2b      	ldr	r3, [pc, #172]	; (80025f4 <HAL_RCC_OscConfig+0x318>)
 8002548:	1b80      	subs	r0, r0, r6
 800254a:	4298      	cmp	r0, r3
 800254c:	d9f6      	bls.n	800253c <HAL_RCC_OscConfig+0x260>
 800254e:	e728      	b.n	80023a2 <HAL_RCC_OscConfig+0xc6>
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 8002550:	2b05      	cmp	r3, #5
 8002552:	d10b      	bne.n	800256c <HAL_RCC_OscConfig+0x290>
 8002554:	6a29      	ldr	r1, [r5, #32]
 8002556:	3b01      	subs	r3, #1
 8002558:	430b      	orrs	r3, r1
 800255a:	622b      	str	r3, [r5, #32]
 800255c:	6a2b      	ldr	r3, [r5, #32]
 800255e:	431a      	orrs	r2, r3
 8002560:	622a      	str	r2, [r5, #32]
      tickstart = HAL_GetTick();
 8002562:	f7ff fa57 	bl	8001a14 <HAL_GetTick>
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 8002566:	2702      	movs	r7, #2
      tickstart = HAL_GetTick();
 8002568:	0006      	movs	r6, r0
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 800256a:	e00d      	b.n	8002588 <HAL_RCC_OscConfig+0x2ac>
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 800256c:	6a2b      	ldr	r3, [r5, #32]
 800256e:	4393      	bics	r3, r2
 8002570:	2204      	movs	r2, #4
 8002572:	622b      	str	r3, [r5, #32]
 8002574:	6a2b      	ldr	r3, [r5, #32]
 8002576:	4393      	bics	r3, r2
 8002578:	e7c0      	b.n	80024fc <HAL_RCC_OscConfig+0x220>
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 800257a:	f7ff fa4b 	bl	8001a14 <HAL_GetTick>
 800257e:	4b1d      	ldr	r3, [pc, #116]	; (80025f4 <HAL_RCC_OscConfig+0x318>)
 8002580:	1b80      	subs	r0, r0, r6
 8002582:	4298      	cmp	r0, r3
 8002584:	d900      	bls.n	8002588 <HAL_RCC_OscConfig+0x2ac>
 8002586:	e70c      	b.n	80023a2 <HAL_RCC_OscConfig+0xc6>
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 8002588:	6a2b      	ldr	r3, [r5, #32]
 800258a:	423b      	tst	r3, r7
 800258c:	d0f5      	beq.n	800257a <HAL_RCC_OscConfig+0x29e>
    if(pwrclkchanged == SET)
 800258e:	9b00      	ldr	r3, [sp, #0]
 8002590:	2b01      	cmp	r3, #1
 8002592:	d000      	beq.n	8002596 <HAL_RCC_OscConfig+0x2ba>
 8002594:	e6b8      	b.n	8002308 <HAL_RCC_OscConfig+0x2c>
      __HAL_RCC_PWR_CLK_DISABLE();
 8002596:	69eb      	ldr	r3, [r5, #28]
 8002598:	4a17      	ldr	r2, [pc, #92]	; (80025f8 <HAL_RCC_OscConfig+0x31c>)
 800259a:	4013      	ands	r3, r2
 800259c:	61eb      	str	r3, [r5, #28]
 800259e:	e6b3      	b.n	8002308 <HAL_RCC_OscConfig+0x2c>
        if((HAL_GetTick() - tickstart) > HSI14_TIMEOUT_VALUE)
 80025a0:	f7ff fa38 	bl	8001a14 <HAL_GetTick>
 80025a4:	1bc0      	subs	r0, r0, r7
 80025a6:	2802      	cmp	r0, #2
 80025a8:	d800      	bhi.n	80025ac <HAL_RCC_OscConfig+0x2d0>
 80025aa:	e6c0      	b.n	800232e <HAL_RCC_OscConfig+0x52>
 80025ac:	e6f9      	b.n	80023a2 <HAL_RCC_OscConfig+0xc6>
    else if(RCC_OscInitStruct->HSI14State == RCC_HSI14_ADC_CONTROL)
 80025ae:	3205      	adds	r2, #5
 80025b0:	d103      	bne.n	80025ba <HAL_RCC_OscConfig+0x2de>
      __HAL_RCC_HSI14ADC_ENABLE();
 80025b2:	6b6a      	ldr	r2, [r5, #52]	; 0x34
 80025b4:	439a      	bics	r2, r3
 80025b6:	636a      	str	r2, [r5, #52]	; 0x34
 80025b8:	e6bd      	b.n	8002336 <HAL_RCC_OscConfig+0x5a>
      __HAL_RCC_HSI14ADC_DISABLE();
 80025ba:	6b6a      	ldr	r2, [r5, #52]	; 0x34
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSI14RDY) != RESET)
 80025bc:	2602      	movs	r6, #2
      __HAL_RCC_HSI14ADC_DISABLE();
 80025be:	4313      	orrs	r3, r2
      __HAL_RCC_HSI14_DISABLE();
 80025c0:	2201      	movs	r2, #1
      __HAL_RCC_HSI14ADC_DISABLE();
 80025c2:	636b      	str	r3, [r5, #52]	; 0x34
      __HAL_RCC_HSI14_DISABLE();
 80025c4:	6b6b      	ldr	r3, [r5, #52]	; 0x34
 80025c6:	4393      	bics	r3, r2
 80025c8:	636b      	str	r3, [r5, #52]	; 0x34
      tickstart = HAL_GetTick();
 80025ca:	f7ff fa23 	bl	8001a14 <HAL_GetTick>
 80025ce:	0007      	movs	r7, r0
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSI14RDY) != RESET)
 80025d0:	6b6b      	ldr	r3, [r5, #52]	; 0x34
 80025d2:	4233      	tst	r3, r6
 80025d4:	d100      	bne.n	80025d8 <HAL_RCC_OscConfig+0x2fc>
 80025d6:	e6b5      	b.n	8002344 <HAL_RCC_OscConfig+0x68>
        if((HAL_GetTick() - tickstart) > HSI14_TIMEOUT_VALUE)
 80025d8:	f7ff fa1c 	bl	8001a14 <HAL_GetTick>
 80025dc:	1bc0      	subs	r0, r0, r7
 80025de:	2802      	cmp	r0, #2
 80025e0:	d9f6      	bls.n	80025d0 <HAL_RCC_OscConfig+0x2f4>
 80025e2:	e6de      	b.n	80023a2 <HAL_RCC_OscConfig+0xc6>
 80025e4:	40021000 	.word	0x40021000
 80025e8:	fffeffff 	.word	0xfffeffff
 80025ec:	fffbffff 	.word	0xfffbffff
 80025f0:	40007000 	.word	0x40007000
 80025f4:	00001388 	.word	0x00001388
 80025f8:	efffffff 	.word	0xefffffff
    if(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_PLLCLK)
 80025fc:	200c      	movs	r0, #12
 80025fe:	4a35      	ldr	r2, [pc, #212]	; (80026d4 <HAL_RCC_OscConfig+0x3f8>)
 8002600:	6851      	ldr	r1, [r2, #4]
 8002602:	0015      	movs	r5, r2
 8002604:	4001      	ands	r1, r0
 8002606:	2908      	cmp	r1, #8
 8002608:	d047      	beq.n	800269a <HAL_RCC_OscConfig+0x3be>
 800260a:	4a33      	ldr	r2, [pc, #204]	; (80026d8 <HAL_RCC_OscConfig+0x3fc>)
      if((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_ON)
 800260c:	2b02      	cmp	r3, #2
 800260e:	d132      	bne.n	8002676 <HAL_RCC_OscConfig+0x39a>
        __HAL_RCC_PLL_DISABLE();
 8002610:	682b      	ldr	r3, [r5, #0]
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY)  != RESET)
 8002612:	2680      	movs	r6, #128	; 0x80
        __HAL_RCC_PLL_DISABLE();
 8002614:	4013      	ands	r3, r2
 8002616:	602b      	str	r3, [r5, #0]
        tickstart = HAL_GetTick();
 8002618:	f7ff f9fc 	bl	8001a14 <HAL_GetTick>
 800261c:	0007      	movs	r7, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY)  != RESET)
 800261e:	04b6      	lsls	r6, r6, #18
 8002620:	682b      	ldr	r3, [r5, #0]
 8002622:	4233      	tst	r3, r6
 8002624:	d121      	bne.n	800266a <HAL_RCC_OscConfig+0x38e>
        __HAL_RCC_PLL_CONFIG(RCC_OscInitStruct->PLL.PLLSource,
 8002626:	220f      	movs	r2, #15
 8002628:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
 800262a:	4393      	bics	r3, r2
 800262c:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 800262e:	4313      	orrs	r3, r2
 8002630:	62eb      	str	r3, [r5, #44]	; 0x2c
 8002632:	6a61      	ldr	r1, [r4, #36]	; 0x24
 8002634:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 8002636:	686a      	ldr	r2, [r5, #4]
 8002638:	430b      	orrs	r3, r1
 800263a:	4928      	ldr	r1, [pc, #160]	; (80026dc <HAL_RCC_OscConfig+0x400>)
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY)  == RESET)
 800263c:	2480      	movs	r4, #128	; 0x80
        __HAL_RCC_PLL_CONFIG(RCC_OscInitStruct->PLL.PLLSource,
 800263e:	400a      	ands	r2, r1
 8002640:	4313      	orrs	r3, r2
 8002642:	606b      	str	r3, [r5, #4]
        __HAL_RCC_PLL_ENABLE();
 8002644:	2380      	movs	r3, #128	; 0x80
 8002646:	682a      	ldr	r2, [r5, #0]
 8002648:	045b      	lsls	r3, r3, #17
 800264a:	4313      	orrs	r3, r2
 800264c:	602b      	str	r3, [r5, #0]
        tickstart = HAL_GetTick();
 800264e:	f7ff f9e1 	bl	8001a14 <HAL_GetTick>
 8002652:	0006      	movs	r6, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY)  == RESET)
 8002654:	04a4      	lsls	r4, r4, #18
 8002656:	682b      	ldr	r3, [r5, #0]
 8002658:	4223      	tst	r3, r4
 800265a:	d000      	beq.n	800265e <HAL_RCC_OscConfig+0x382>
 800265c:	e676      	b.n	800234c <HAL_RCC_OscConfig+0x70>
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 800265e:	f7ff f9d9 	bl	8001a14 <HAL_GetTick>
 8002662:	1b80      	subs	r0, r0, r6
 8002664:	2802      	cmp	r0, #2
 8002666:	d9f6      	bls.n	8002656 <HAL_RCC_OscConfig+0x37a>
 8002668:	e69b      	b.n	80023a2 <HAL_RCC_OscConfig+0xc6>
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 800266a:	f7ff f9d3 	bl	8001a14 <HAL_GetTick>
 800266e:	1bc0      	subs	r0, r0, r7
 8002670:	2802      	cmp	r0, #2
 8002672:	d9d5      	bls.n	8002620 <HAL_RCC_OscConfig+0x344>
 8002674:	e695      	b.n	80023a2 <HAL_RCC_OscConfig+0xc6>
        __HAL_RCC_PLL_DISABLE();
 8002676:	682b      	ldr	r3, [r5, #0]
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY)  != RESET)
 8002678:	2480      	movs	r4, #128	; 0x80
        __HAL_RCC_PLL_DISABLE();
 800267a:	4013      	ands	r3, r2
 800267c:	602b      	str	r3, [r5, #0]
        tickstart = HAL_GetTick();
 800267e:	f7ff f9c9 	bl	8001a14 <HAL_GetTick>
 8002682:	0006      	movs	r6, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY)  != RESET)
 8002684:	04a4      	lsls	r4, r4, #18
 8002686:	682b      	ldr	r3, [r5, #0]
 8002688:	4223      	tst	r3, r4
 800268a:	d100      	bne.n	800268e <HAL_RCC_OscConfig+0x3b2>
 800268c:	e65e      	b.n	800234c <HAL_RCC_OscConfig+0x70>
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 800268e:	f7ff f9c1 	bl	8001a14 <HAL_GetTick>
 8002692:	1b80      	subs	r0, r0, r6
 8002694:	2802      	cmp	r0, #2
 8002696:	d9f6      	bls.n	8002686 <HAL_RCC_OscConfig+0x3aa>
 8002698:	e683      	b.n	80023a2 <HAL_RCC_OscConfig+0xc6>
        return HAL_ERROR;
 800269a:	0018      	movs	r0, r3
      if((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_OFF)
 800269c:	2b01      	cmp	r3, #1
 800269e:	d100      	bne.n	80026a2 <HAL_RCC_OscConfig+0x3c6>
 80026a0:	e622      	b.n	80022e8 <HAL_RCC_OscConfig+0xc>
        if((READ_BIT(pll_config,  RCC_CFGR_PLLSRC)  != RCC_OscInitStruct->PLL.PLLSource) ||
 80026a2:	2180      	movs	r1, #128	; 0x80
        pll_config  = RCC->CFGR;
 80026a4:	6853      	ldr	r3, [r2, #4]
        if((READ_BIT(pll_config,  RCC_CFGR_PLLSRC)  != RCC_OscInitStruct->PLL.PLLSource) ||
 80026a6:	6a65      	ldr	r5, [r4, #36]	; 0x24
 80026a8:	0249      	lsls	r1, r1, #9
        pll_config2 = RCC->CFGR2;
 80026aa:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
        if((READ_BIT(pll_config,  RCC_CFGR_PLLSRC)  != RCC_OscInitStruct->PLL.PLLSource) ||
 80026ac:	4019      	ands	r1, r3
        return HAL_ERROR;
 80026ae:	2001      	movs	r0, #1
        if((READ_BIT(pll_config,  RCC_CFGR_PLLSRC)  != RCC_OscInitStruct->PLL.PLLSource) ||
 80026b0:	42a9      	cmp	r1, r5
 80026b2:	d000      	beq.n	80026b6 <HAL_RCC_OscConfig+0x3da>
 80026b4:	e618      	b.n	80022e8 <HAL_RCC_OscConfig+0xc>
           (READ_BIT(pll_config2, RCC_CFGR2_PREDIV) != RCC_OscInitStruct->PLL.PREDIV)    ||
 80026b6:	210f      	movs	r1, #15
 80026b8:	400a      	ands	r2, r1
        if((READ_BIT(pll_config,  RCC_CFGR_PLLSRC)  != RCC_OscInitStruct->PLL.PLLSource) ||
 80026ba:	6ae1      	ldr	r1, [r4, #44]	; 0x2c
 80026bc:	428a      	cmp	r2, r1
 80026be:	d000      	beq.n	80026c2 <HAL_RCC_OscConfig+0x3e6>
 80026c0:	e612      	b.n	80022e8 <HAL_RCC_OscConfig+0xc>
           (READ_BIT(pll_config,  RCC_CFGR_PLLMUL)  != RCC_OscInitStruct->PLL.PLLMUL))
 80026c2:	20f0      	movs	r0, #240	; 0xf0
 80026c4:	0380      	lsls	r0, r0, #14
 80026c6:	4003      	ands	r3, r0
           (READ_BIT(pll_config2, RCC_CFGR2_PREDIV) != RCC_OscInitStruct->PLL.PREDIV)    ||
 80026c8:	6aa0      	ldr	r0, [r4, #40]	; 0x28
 80026ca:	1a1b      	subs	r3, r3, r0
 80026cc:	1e58      	subs	r0, r3, #1
 80026ce:	4183      	sbcs	r3, r0
    return HAL_ERROR;
 80026d0:	b2d8      	uxtb	r0, r3
 80026d2:	e609      	b.n	80022e8 <HAL_RCC_OscConfig+0xc>
 80026d4:	40021000 	.word	0x40021000
 80026d8:	feffffff 	.word	0xfeffffff
 80026dc:	ffc2ffff 	.word	0xffc2ffff

080026e0 <HAL_RCC_GetSysClockFreq>:
  *         right SYSCLK value. Otherwise, any configuration based on this function will be incorrect.
  *         
  * @retval SYSCLK frequency
  */
uint32_t HAL_RCC_GetSysClockFreq(void)
{
 80026e0:	b570      	push	{r4, r5, r6, lr}
  const uint8_t aPLLMULFactorTable[16] = { 2U,  3U,  4U,  5U,  6U,  7U,  8U,  9U,
 80026e2:	4c14      	ldr	r4, [pc, #80]	; (8002734 <HAL_RCC_GetSysClockFreq+0x54>)
{
 80026e4:	b088      	sub	sp, #32
  const uint8_t aPLLMULFactorTable[16] = { 2U,  3U,  4U,  5U,  6U,  7U,  8U,  9U,
 80026e6:	2210      	movs	r2, #16
 80026e8:	0021      	movs	r1, r4
 80026ea:	4668      	mov	r0, sp
 80026ec:	f001 f89e 	bl	800382c <memcpy>
                                         10U, 11U, 12U, 13U, 14U, 15U, 16U, 16U};
  const uint8_t aPredivFactorTable[16] = { 1U, 2U,  3U,  4U,  5U,  6U,  7U,  8U,
 80026f0:	0021      	movs	r1, r4
 80026f2:	ad04      	add	r5, sp, #16
 80026f4:	2210      	movs	r2, #16
 80026f6:	3110      	adds	r1, #16
 80026f8:	0028      	movs	r0, r5
 80026fa:	f001 f897 	bl	800382c <memcpy>
  uint32_t sysclockfreq = 0U;
  
  tmpreg = RCC->CFGR;
  
  /* Get SYSCLK source -------------------------------------------------------*/
  switch (tmpreg & RCC_CFGR_SWS)
 80026fe:	220c      	movs	r2, #12
  tmpreg = RCC->CFGR;
 8002700:	4e0d      	ldr	r6, [pc, #52]	; (8002738 <HAL_RCC_GetSysClockFreq+0x58>)
 8002702:	6873      	ldr	r3, [r6, #4]
  switch (tmpreg & RCC_CFGR_SWS)
 8002704:	401a      	ands	r2, r3
 8002706:	2a08      	cmp	r2, #8
 8002708:	d111      	bne.n	800272e <HAL_RCC_GetSysClockFreq+0x4e>
      sysclockfreq = HSE_VALUE;
      break;
    }
    case RCC_SYSCLKSOURCE_STATUS_PLLCLK:  /* PLL used as system clock */
    {
      pllmul = aPLLMULFactorTable[(uint32_t)(tmpreg & RCC_CFGR_PLLMUL) >> RCC_CFGR_PLLMUL_BITNUMBER];
 800270a:	200f      	movs	r0, #15
 800270c:	466a      	mov	r2, sp
 800270e:	0c99      	lsrs	r1, r3, #18
 8002710:	4001      	ands	r1, r0
 8002712:	5c54      	ldrb	r4, [r2, r1]
      prediv = aPredivFactorTable[(uint32_t)(RCC->CFGR2 & RCC_CFGR2_PREDIV) >> RCC_CFGR2_PREDIV_BITNUMBER];
 8002714:	6af2      	ldr	r2, [r6, #44]	; 0x2c
 8002716:	4002      	ands	r2, r0
 8002718:	5ca9      	ldrb	r1, [r5, r2]
      if ((tmpreg & RCC_CFGR_PLLSRC) == RCC_PLLSOURCE_HSE)
 800271a:	03db      	lsls	r3, r3, #15
 800271c:	d505      	bpl.n	800272a <HAL_RCC_GetSysClockFreq+0x4a>
      {
        /* HSE used as PLL clock source : PLLCLK = HSE/PREDIV * PLLMUL */
        pllclk = (uint32_t)((uint64_t) HSE_VALUE / (uint64_t) (prediv)) * ((uint64_t) pllmul);
 800271e:	4807      	ldr	r0, [pc, #28]	; (800273c <HAL_RCC_GetSysClockFreq+0x5c>)
 8002720:	f7fd fd06 	bl	8000130 <__udivsi3>
#if  (defined(STM32F042x6) || defined(STM32F048xx) || defined(STM32F070x6) || defined(STM32F071xB) || defined(STM32F072xB) || defined(STM32F078xx) || defined(STM32F070xB) || defined(STM32F091xC) || defined(STM32F098xx) || defined(STM32F030xC))
        /* HSI used as PLL clock source : PLLCLK = HSI/PREDIV * PLLMUL */
        pllclk = (uint32_t)((uint64_t) HSI_VALUE / (uint64_t) (prediv)) * ((uint64_t) pllmul);
#else
        /* HSI used as PLL clock source : PLLCLK = HSI/2 * PLLMUL */
        pllclk = (uint32_t)((uint64_t) (HSI_VALUE >> 1U) * ((uint64_t) pllmul));
 8002724:	4360      	muls	r0, r4
      sysclockfreq = HSI_VALUE;
      break;
    }
  }
  return sysclockfreq;
}
 8002726:	b008      	add	sp, #32
 8002728:	bd70      	pop	{r4, r5, r6, pc}
        pllclk = (uint32_t)((uint64_t) (HSI_VALUE >> 1U) * ((uint64_t) pllmul));
 800272a:	4805      	ldr	r0, [pc, #20]	; (8002740 <HAL_RCC_GetSysClockFreq+0x60>)
 800272c:	e7fa      	b.n	8002724 <HAL_RCC_GetSysClockFreq+0x44>
      sysclockfreq = HSE_VALUE;
 800272e:	4803      	ldr	r0, [pc, #12]	; (800273c <HAL_RCC_GetSysClockFreq+0x5c>)
  return sysclockfreq;
 8002730:	e7f9      	b.n	8002726 <HAL_RCC_GetSysClockFreq+0x46>
 8002732:	46c0      	nop			; (mov r8, r8)
 8002734:	08003898 	.word	0x08003898
 8002738:	40021000 	.word	0x40021000
 800273c:	007a1200 	.word	0x007a1200
 8002740:	003d0900 	.word	0x003d0900

08002744 <HAL_RCC_ClockConfig>:
{
 8002744:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 8002746:	0005      	movs	r5, r0
 8002748:	000f      	movs	r7, r1
  if(RCC_ClkInitStruct == NULL)
 800274a:	2800      	cmp	r0, #0
 800274c:	d101      	bne.n	8002752 <HAL_RCC_ClockConfig+0xe>
    return HAL_ERROR;
 800274e:	2001      	movs	r0, #1
}
 8002750:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
  if(FLatency > __HAL_FLASH_GET_LATENCY())
 8002752:	2201      	movs	r2, #1
 8002754:	4c37      	ldr	r4, [pc, #220]	; (8002834 <HAL_RCC_ClockConfig+0xf0>)
 8002756:	6823      	ldr	r3, [r4, #0]
 8002758:	4013      	ands	r3, r2
 800275a:	428b      	cmp	r3, r1
 800275c:	d31c      	bcc.n	8002798 <HAL_RCC_ClockConfig+0x54>
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
 800275e:	6829      	ldr	r1, [r5, #0]
 8002760:	078b      	lsls	r3, r1, #30
 8002762:	d422      	bmi.n	80027aa <HAL_RCC_ClockConfig+0x66>
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
 8002764:	07cb      	lsls	r3, r1, #31
 8002766:	d42f      	bmi.n	80027c8 <HAL_RCC_ClockConfig+0x84>
  if(FLatency < __HAL_FLASH_GET_LATENCY())
 8002768:	2301      	movs	r3, #1
 800276a:	6822      	ldr	r2, [r4, #0]
 800276c:	401a      	ands	r2, r3
 800276e:	42ba      	cmp	r2, r7
 8002770:	d851      	bhi.n	8002816 <HAL_RCC_ClockConfig+0xd2>
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
 8002772:	682b      	ldr	r3, [r5, #0]
 8002774:	4c30      	ldr	r4, [pc, #192]	; (8002838 <HAL_RCC_ClockConfig+0xf4>)
 8002776:	075b      	lsls	r3, r3, #29
 8002778:	d454      	bmi.n	8002824 <HAL_RCC_ClockConfig+0xe0>
  SystemCoreClock = HAL_RCC_GetSysClockFreq() >> AHBPrescTable[(RCC->CFGR & RCC_CFGR_HPRE)>> RCC_CFGR_HPRE_BITNUMBER];
 800277a:	f7ff ffb1 	bl	80026e0 <HAL_RCC_GetSysClockFreq>
 800277e:	6863      	ldr	r3, [r4, #4]
 8002780:	4a2e      	ldr	r2, [pc, #184]	; (800283c <HAL_RCC_ClockConfig+0xf8>)
 8002782:	061b      	lsls	r3, r3, #24
 8002784:	0f1b      	lsrs	r3, r3, #28
 8002786:	5cd3      	ldrb	r3, [r2, r3]
 8002788:	40d8      	lsrs	r0, r3
 800278a:	4b2d      	ldr	r3, [pc, #180]	; (8002840 <HAL_RCC_ClockConfig+0xfc>)
 800278c:	6018      	str	r0, [r3, #0]
  HAL_InitTick (TICK_INT_PRIORITY);
 800278e:	2000      	movs	r0, #0
 8002790:	f7ff f900 	bl	8001994 <HAL_InitTick>
  return HAL_OK;
 8002794:	2000      	movs	r0, #0
 8002796:	e7db      	b.n	8002750 <HAL_RCC_ClockConfig+0xc>
    __HAL_FLASH_SET_LATENCY(FLatency);
 8002798:	6823      	ldr	r3, [r4, #0]
 800279a:	4393      	bics	r3, r2
 800279c:	430b      	orrs	r3, r1
 800279e:	6023      	str	r3, [r4, #0]
    if(__HAL_FLASH_GET_LATENCY() != FLatency)
 80027a0:	6823      	ldr	r3, [r4, #0]
 80027a2:	4013      	ands	r3, r2
 80027a4:	428b      	cmp	r3, r1
 80027a6:	d1d2      	bne.n	800274e <HAL_RCC_ClockConfig+0xa>
 80027a8:	e7d9      	b.n	800275e <HAL_RCC_ClockConfig+0x1a>
 80027aa:	4a23      	ldr	r2, [pc, #140]	; (8002838 <HAL_RCC_ClockConfig+0xf4>)
    if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
 80027ac:	074b      	lsls	r3, r1, #29
 80027ae:	d504      	bpl.n	80027ba <HAL_RCC_ClockConfig+0x76>
      MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE, RCC_HCLK_DIV16);
 80027b0:	23e0      	movs	r3, #224	; 0xe0
 80027b2:	6850      	ldr	r0, [r2, #4]
 80027b4:	00db      	lsls	r3, r3, #3
 80027b6:	4303      	orrs	r3, r0
 80027b8:	6053      	str	r3, [r2, #4]
    MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, RCC_ClkInitStruct->AHBCLKDivider);
 80027ba:	20f0      	movs	r0, #240	; 0xf0
 80027bc:	6853      	ldr	r3, [r2, #4]
 80027be:	4383      	bics	r3, r0
 80027c0:	68a8      	ldr	r0, [r5, #8]
 80027c2:	4303      	orrs	r3, r0
 80027c4:	6053      	str	r3, [r2, #4]
 80027c6:	e7cd      	b.n	8002764 <HAL_RCC_ClockConfig+0x20>
 80027c8:	4e1b      	ldr	r6, [pc, #108]	; (8002838 <HAL_RCC_ClockConfig+0xf4>)
    if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 80027ca:	686a      	ldr	r2, [r5, #4]
      if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 80027cc:	6833      	ldr	r3, [r6, #0]
    if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 80027ce:	2a01      	cmp	r2, #1
 80027d0:	d119      	bne.n	8002806 <HAL_RCC_ClockConfig+0xc2>
      if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 80027d2:	039b      	lsls	r3, r3, #14
 80027d4:	d5bb      	bpl.n	800274e <HAL_RCC_ClockConfig+0xa>
    __HAL_RCC_SYSCLK_CONFIG(RCC_ClkInitStruct->SYSCLKSource);
 80027d6:	2103      	movs	r1, #3
 80027d8:	6873      	ldr	r3, [r6, #4]
 80027da:	438b      	bics	r3, r1
 80027dc:	4313      	orrs	r3, r2
 80027de:	6073      	str	r3, [r6, #4]
    tickstart = HAL_GetTick();
 80027e0:	f7ff f918 	bl	8001a14 <HAL_GetTick>
 80027e4:	9001      	str	r0, [sp, #4]
    while (__HAL_RCC_GET_SYSCLK_SOURCE() != (RCC_ClkInitStruct->SYSCLKSource << RCC_CFGR_SWS_Pos))
 80027e6:	230c      	movs	r3, #12
 80027e8:	6872      	ldr	r2, [r6, #4]
 80027ea:	401a      	ands	r2, r3
 80027ec:	686b      	ldr	r3, [r5, #4]
 80027ee:	009b      	lsls	r3, r3, #2
 80027f0:	429a      	cmp	r2, r3
 80027f2:	d0b9      	beq.n	8002768 <HAL_RCC_ClockConfig+0x24>
      if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
 80027f4:	f7ff f90e 	bl	8001a14 <HAL_GetTick>
 80027f8:	9b01      	ldr	r3, [sp, #4]
 80027fa:	1ac0      	subs	r0, r0, r3
 80027fc:	4b11      	ldr	r3, [pc, #68]	; (8002844 <HAL_RCC_ClockConfig+0x100>)
 80027fe:	4298      	cmp	r0, r3
 8002800:	d9f1      	bls.n	80027e6 <HAL_RCC_ClockConfig+0xa2>
        return HAL_TIMEOUT;
 8002802:	2003      	movs	r0, #3
 8002804:	e7a4      	b.n	8002750 <HAL_RCC_ClockConfig+0xc>
    else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
 8002806:	2a02      	cmp	r2, #2
 8002808:	d102      	bne.n	8002810 <HAL_RCC_ClockConfig+0xcc>
      if(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
 800280a:	019b      	lsls	r3, r3, #6
 800280c:	d4e3      	bmi.n	80027d6 <HAL_RCC_ClockConfig+0x92>
 800280e:	e79e      	b.n	800274e <HAL_RCC_ClockConfig+0xa>
      if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 8002810:	079b      	lsls	r3, r3, #30
 8002812:	d4e0      	bmi.n	80027d6 <HAL_RCC_ClockConfig+0x92>
 8002814:	e79b      	b.n	800274e <HAL_RCC_ClockConfig+0xa>
    __HAL_FLASH_SET_LATENCY(FLatency);
 8002816:	6822      	ldr	r2, [r4, #0]
 8002818:	439a      	bics	r2, r3
 800281a:	6022      	str	r2, [r4, #0]
    if(__HAL_FLASH_GET_LATENCY() != FLatency)
 800281c:	6822      	ldr	r2, [r4, #0]
 800281e:	421a      	tst	r2, r3
 8002820:	d0a7      	beq.n	8002772 <HAL_RCC_ClockConfig+0x2e>
 8002822:	e794      	b.n	800274e <HAL_RCC_ClockConfig+0xa>
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE, RCC_ClkInitStruct->APB1CLKDivider);
 8002824:	6863      	ldr	r3, [r4, #4]
 8002826:	4a08      	ldr	r2, [pc, #32]	; (8002848 <HAL_RCC_ClockConfig+0x104>)
 8002828:	4013      	ands	r3, r2
 800282a:	68ea      	ldr	r2, [r5, #12]
 800282c:	4313      	orrs	r3, r2
 800282e:	6063      	str	r3, [r4, #4]
 8002830:	e7a3      	b.n	800277a <HAL_RCC_ClockConfig+0x36>
 8002832:	46c0      	nop			; (mov r8, r8)
 8002834:	40022000 	.word	0x40022000
 8002838:	40021000 	.word	0x40021000
 800283c:	08003aa7 	.word	0x08003aa7
 8002840:	20000024 	.word	0x20000024
 8002844:	00001388 	.word	0x00001388
 8002848:	fffff8ff 	.word	0xfffff8ff

0800284c <HAL_RCC_GetPCLK1Freq>:
  * @retval PCLK1 frequency
  */
uint32_t HAL_RCC_GetPCLK1Freq(void)
{
  /* Get HCLK source and Compute PCLK1 frequency ---------------------------*/
  return (HAL_RCC_GetHCLKFreq() >> APBPrescTable[(RCC->CFGR & RCC_CFGR_PPRE) >> RCC_CFGR_PPRE_BITNUMBER]);
 800284c:	4b04      	ldr	r3, [pc, #16]	; (8002860 <HAL_RCC_GetPCLK1Freq+0x14>)
 800284e:	4a05      	ldr	r2, [pc, #20]	; (8002864 <HAL_RCC_GetPCLK1Freq+0x18>)
 8002850:	685b      	ldr	r3, [r3, #4]
 8002852:	055b      	lsls	r3, r3, #21
 8002854:	0f5b      	lsrs	r3, r3, #29
 8002856:	5cd3      	ldrb	r3, [r2, r3]
 8002858:	4a03      	ldr	r2, [pc, #12]	; (8002868 <HAL_RCC_GetPCLK1Freq+0x1c>)
 800285a:	6810      	ldr	r0, [r2, #0]
 800285c:	40d8      	lsrs	r0, r3
}    
 800285e:	4770      	bx	lr
 8002860:	40021000 	.word	0x40021000
 8002864:	08003ab7 	.word	0x08003ab7
 8002868:	20000024 	.word	0x20000024

0800286c <HAL_RCCEx_PeriphCLKConfig>:
  *         the backup registers) and RCC_BDCR register are set to their reset values.
  *
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCCEx_PeriphCLKConfig(RCC_PeriphCLKInitTypeDef  *PeriphClkInit)
{
 800286c:	b5f0      	push	{r4, r5, r6, r7, lr}

  /* Check the parameters */
  assert_param(IS_RCC_PERIPHCLOCK(PeriphClkInit->PeriphClockSelection));
  
  /*---------------------------- RTC configuration -------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_RTC) == (RCC_PERIPHCLK_RTC))
 800286e:	6803      	ldr	r3, [r0, #0]
{
 8002870:	b085      	sub	sp, #20
 8002872:	0005      	movs	r5, r0
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_RTC) == (RCC_PERIPHCLK_RTC))
 8002874:	03db      	lsls	r3, r3, #15
 8002876:	d528      	bpl.n	80028ca <HAL_RCCEx_PeriphCLKConfig+0x5e>
    FlagStatus       pwrclkchanged = RESET;

    /* As soon as function is called to change RTC clock source, activation of the 
       power domain is done. */
    /* Requires to enable write access to Backup Domain of necessary */
    if(__HAL_RCC_PWR_IS_CLK_DISABLED())
 8002878:	2280      	movs	r2, #128	; 0x80
    FlagStatus       pwrclkchanged = RESET;
 800287a:	2100      	movs	r1, #0
    if(__HAL_RCC_PWR_IS_CLK_DISABLED())
 800287c:	4c37      	ldr	r4, [pc, #220]	; (800295c <HAL_RCCEx_PeriphCLKConfig+0xf0>)
 800287e:	0552      	lsls	r2, r2, #21
 8002880:	69e3      	ldr	r3, [r4, #28]
    FlagStatus       pwrclkchanged = RESET;
 8002882:	9100      	str	r1, [sp, #0]
    if(__HAL_RCC_PWR_IS_CLK_DISABLED())
 8002884:	4213      	tst	r3, r2
 8002886:	d108      	bne.n	800289a <HAL_RCCEx_PeriphCLKConfig+0x2e>
    {
    __HAL_RCC_PWR_CLK_ENABLE();
 8002888:	69e3      	ldr	r3, [r4, #28]
 800288a:	4313      	orrs	r3, r2
 800288c:	61e3      	str	r3, [r4, #28]
 800288e:	69e3      	ldr	r3, [r4, #28]
 8002890:	4013      	ands	r3, r2
 8002892:	9303      	str	r3, [sp, #12]
 8002894:	9b03      	ldr	r3, [sp, #12]
      pwrclkchanged = SET;
 8002896:	2301      	movs	r3, #1
 8002898:	9300      	str	r3, [sp, #0]
    }
    
    if(HAL_IS_BIT_CLR(PWR->CR, PWR_CR_DBP))
 800289a:	2780      	movs	r7, #128	; 0x80
 800289c:	4e30      	ldr	r6, [pc, #192]	; (8002960 <HAL_RCCEx_PeriphCLKConfig+0xf4>)
 800289e:	007f      	lsls	r7, r7, #1
 80028a0:	6833      	ldr	r3, [r6, #0]
 80028a2:	423b      	tst	r3, r7
 80028a4:	d026      	beq.n	80028f4 <HAL_RCCEx_PeriphCLKConfig+0x88>
        }
      }
    }
    
    /* Reset the Backup domain only if the RTC Clock source selection is modified from reset value */ 
    temp_reg = (RCC->BDCR & RCC_BDCR_RTCSEL);
 80028a6:	22c0      	movs	r2, #192	; 0xc0
 80028a8:	6a23      	ldr	r3, [r4, #32]
 80028aa:	0092      	lsls	r2, r2, #2
 80028ac:	4013      	ands	r3, r2
 80028ae:	4e2d      	ldr	r6, [pc, #180]	; (8002964 <HAL_RCCEx_PeriphCLKConfig+0xf8>)
    if((temp_reg != 0x00000000U) && (temp_reg != (PeriphClkInit->RTCClockSelection & RCC_BDCR_RTCSEL)))
 80028b0:	d132      	bne.n	8002918 <HAL_RCCEx_PeriphCLKConfig+0xac>
            return HAL_TIMEOUT;
          }
        }
      }
    }
    __HAL_RCC_RTC_CONFIG(PeriphClkInit->RTCClockSelection);
 80028b2:	6a23      	ldr	r3, [r4, #32]
 80028b4:	401e      	ands	r6, r3
 80028b6:	686b      	ldr	r3, [r5, #4]
 80028b8:	431e      	orrs	r6, r3

    /* Require to disable power clock if necessary */
    if(pwrclkchanged == SET)
 80028ba:	9b00      	ldr	r3, [sp, #0]
    __HAL_RCC_RTC_CONFIG(PeriphClkInit->RTCClockSelection);
 80028bc:	6226      	str	r6, [r4, #32]
    if(pwrclkchanged == SET)
 80028be:	2b01      	cmp	r3, #1
 80028c0:	d103      	bne.n	80028ca <HAL_RCCEx_PeriphCLKConfig+0x5e>
    {
      __HAL_RCC_PWR_CLK_DISABLE();
 80028c2:	69e3      	ldr	r3, [r4, #28]
 80028c4:	4a28      	ldr	r2, [pc, #160]	; (8002968 <HAL_RCCEx_PeriphCLKConfig+0xfc>)
 80028c6:	4013      	ands	r3, r2
 80028c8:	61e3      	str	r3, [r4, #28]
    }
  }

  /*------------------------------- USART1 Configuration ------------------------*/ 
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART1) == RCC_PERIPHCLK_USART1)
 80028ca:	682a      	ldr	r2, [r5, #0]
 80028cc:	07d3      	lsls	r3, r2, #31
 80028ce:	d506      	bpl.n	80028de <HAL_RCCEx_PeriphCLKConfig+0x72>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USART1CLKSOURCE(PeriphClkInit->Usart1ClockSelection));
    
    /* Configure the USART1 clock source */
    __HAL_RCC_USART1_CONFIG(PeriphClkInit->Usart1ClockSelection);
 80028d0:	2003      	movs	r0, #3
 80028d2:	4922      	ldr	r1, [pc, #136]	; (800295c <HAL_RCCEx_PeriphCLKConfig+0xf0>)
 80028d4:	6b0b      	ldr	r3, [r1, #48]	; 0x30
 80028d6:	4383      	bics	r3, r0
 80028d8:	68a8      	ldr	r0, [r5, #8]
 80028da:	4303      	orrs	r3, r0
 80028dc:	630b      	str	r3, [r1, #48]	; 0x30
#endif /* STM32F042x6 || STM32F048xx ||                */
       /* STM32F051x8 || STM32F058xx ||                */
       /* STM32F071xB || STM32F072xB || STM32F078xx || */
       /* STM32F091xC || STM32F098xx */
  
  return HAL_OK;
 80028de:	2000      	movs	r0, #0
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C1) == RCC_PERIPHCLK_I2C1)
 80028e0:	0693      	lsls	r3, r2, #26
 80028e2:	d517      	bpl.n	8002914 <HAL_RCCEx_PeriphCLKConfig+0xa8>
    __HAL_RCC_I2C1_CONFIG(PeriphClkInit->I2c1ClockSelection);
 80028e4:	2110      	movs	r1, #16
 80028e6:	4a1d      	ldr	r2, [pc, #116]	; (800295c <HAL_RCCEx_PeriphCLKConfig+0xf0>)
 80028e8:	6b13      	ldr	r3, [r2, #48]	; 0x30
 80028ea:	438b      	bics	r3, r1
 80028ec:	68e9      	ldr	r1, [r5, #12]
 80028ee:	430b      	orrs	r3, r1
 80028f0:	6313      	str	r3, [r2, #48]	; 0x30
 80028f2:	e00f      	b.n	8002914 <HAL_RCCEx_PeriphCLKConfig+0xa8>
      SET_BIT(PWR->CR, PWR_CR_DBP);
 80028f4:	6833      	ldr	r3, [r6, #0]
 80028f6:	433b      	orrs	r3, r7
 80028f8:	6033      	str	r3, [r6, #0]
      tickstart = HAL_GetTick();
 80028fa:	f7ff f88b 	bl	8001a14 <HAL_GetTick>
 80028fe:	9001      	str	r0, [sp, #4]
      while(HAL_IS_BIT_CLR(PWR->CR, PWR_CR_DBP))
 8002900:	6833      	ldr	r3, [r6, #0]
 8002902:	423b      	tst	r3, r7
 8002904:	d1cf      	bne.n	80028a6 <HAL_RCCEx_PeriphCLKConfig+0x3a>
        if((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
 8002906:	f7ff f885 	bl	8001a14 <HAL_GetTick>
 800290a:	9b01      	ldr	r3, [sp, #4]
 800290c:	1ac0      	subs	r0, r0, r3
 800290e:	2864      	cmp	r0, #100	; 0x64
 8002910:	d9f6      	bls.n	8002900 <HAL_RCCEx_PeriphCLKConfig+0x94>
          return HAL_TIMEOUT;
 8002912:	2003      	movs	r0, #3
}
 8002914:	b005      	add	sp, #20
 8002916:	bdf0      	pop	{r4, r5, r6, r7, pc}
    if((temp_reg != 0x00000000U) && (temp_reg != (PeriphClkInit->RTCClockSelection & RCC_BDCR_RTCSEL)))
 8002918:	6869      	ldr	r1, [r5, #4]
 800291a:	400a      	ands	r2, r1
 800291c:	429a      	cmp	r2, r3
 800291e:	d0c8      	beq.n	80028b2 <HAL_RCCEx_PeriphCLKConfig+0x46>
      __HAL_RCC_BACKUPRESET_FORCE();
 8002920:	2380      	movs	r3, #128	; 0x80
      temp_reg = (RCC->BDCR & ~(RCC_BDCR_RTCSEL));
 8002922:	6a22      	ldr	r2, [r4, #32]
      __HAL_RCC_BACKUPRESET_FORCE();
 8002924:	6a20      	ldr	r0, [r4, #32]
      temp_reg = (RCC->BDCR & ~(RCC_BDCR_RTCSEL));
 8002926:	0011      	movs	r1, r2
      __HAL_RCC_BACKUPRESET_FORCE();
 8002928:	025b      	lsls	r3, r3, #9
 800292a:	4303      	orrs	r3, r0
 800292c:	6223      	str	r3, [r4, #32]
      __HAL_RCC_BACKUPRESET_RELEASE();
 800292e:	6a23      	ldr	r3, [r4, #32]
 8002930:	480e      	ldr	r0, [pc, #56]	; (800296c <HAL_RCCEx_PeriphCLKConfig+0x100>)
      temp_reg = (RCC->BDCR & ~(RCC_BDCR_RTCSEL));
 8002932:	4031      	ands	r1, r6
      __HAL_RCC_BACKUPRESET_RELEASE();
 8002934:	4003      	ands	r3, r0
 8002936:	6223      	str	r3, [r4, #32]
      RCC->BDCR = temp_reg;
 8002938:	6221      	str	r1, [r4, #32]
      if (HAL_IS_BIT_SET(temp_reg, RCC_BDCR_LSEON))
 800293a:	07d3      	lsls	r3, r2, #31
 800293c:	d5b9      	bpl.n	80028b2 <HAL_RCCEx_PeriphCLKConfig+0x46>
        tickstart = HAL_GetTick();
 800293e:	f7ff f869 	bl	8001a14 <HAL_GetTick>
 8002942:	0007      	movs	r7, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 8002944:	2202      	movs	r2, #2
 8002946:	6a23      	ldr	r3, [r4, #32]
 8002948:	4213      	tst	r3, r2
 800294a:	d1b2      	bne.n	80028b2 <HAL_RCCEx_PeriphCLKConfig+0x46>
          if((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 800294c:	f7ff f862 	bl	8001a14 <HAL_GetTick>
 8002950:	4b07      	ldr	r3, [pc, #28]	; (8002970 <HAL_RCCEx_PeriphCLKConfig+0x104>)
 8002952:	1bc0      	subs	r0, r0, r7
 8002954:	4298      	cmp	r0, r3
 8002956:	d9f5      	bls.n	8002944 <HAL_RCCEx_PeriphCLKConfig+0xd8>
 8002958:	e7db      	b.n	8002912 <HAL_RCCEx_PeriphCLKConfig+0xa6>
 800295a:	46c0      	nop			; (mov r8, r8)
 800295c:	40021000 	.word	0x40021000
 8002960:	40007000 	.word	0x40007000
 8002964:	fffffcff 	.word	0xfffffcff
 8002968:	efffffff 	.word	0xefffffff
 800296c:	fffeffff 	.word	0xfffeffff
 8002970:	00001388 	.word	0x00001388

08002974 <SPI_WaitFifoStateUntilTimeout.part.1>:
        /* Disable the SPI and reset the CRC: the CRC value should be cleared
        on both master and slave sides in order to resynchronize the master
        and slave for their respective CRC calculation */

        /* Disable TXE, RXNE and ERR interrupts for the interrupt process */
        __HAL_SPI_DISABLE_IT(hspi, (SPI_IT_TXE | SPI_IT_RXNE | SPI_IT_ERR));
 8002974:	21e0      	movs	r1, #224	; 0xe0
 8002976:	6803      	ldr	r3, [r0, #0]
static HAL_StatusTypeDef SPI_WaitFlagStateUntilTimeout(SPI_HandleTypeDef *hspi, uint32_t Flag, FlagStatus State,
 8002978:	b510      	push	{r4, lr}
        __HAL_SPI_DISABLE_IT(hspi, (SPI_IT_TXE | SPI_IT_RXNE | SPI_IT_ERR));
 800297a:	685a      	ldr	r2, [r3, #4]
 800297c:	438a      	bics	r2, r1
 800297e:	605a      	str	r2, [r3, #4]

        if ((hspi->Init.Mode == SPI_MODE_MASTER) && ((hspi->Init.Direction == SPI_DIRECTION_1LINE)
 8002980:	2282      	movs	r2, #130	; 0x82
 8002982:	6841      	ldr	r1, [r0, #4]
 8002984:	0052      	lsls	r2, r2, #1
 8002986:	4291      	cmp	r1, r2
 8002988:	d10c      	bne.n	80029a4 <SPI_WaitFifoStateUntilTimeout.part.1+0x30>
 800298a:	2180      	movs	r1, #128	; 0x80
 800298c:	6882      	ldr	r2, [r0, #8]
 800298e:	0209      	lsls	r1, r1, #8
 8002990:	428a      	cmp	r2, r1
 8002992:	d003      	beq.n	800299c <SPI_WaitFifoStateUntilTimeout.part.1+0x28>
                                                     || (hspi->Init.Direction == SPI_DIRECTION_2LINES_RXONLY)))
 8002994:	2180      	movs	r1, #128	; 0x80
 8002996:	00c9      	lsls	r1, r1, #3
 8002998:	428a      	cmp	r2, r1
 800299a:	d103      	bne.n	80029a4 <SPI_WaitFifoStateUntilTimeout.part.1+0x30>
        {
          /* Disable SPI peripheral */
          __HAL_SPI_DISABLE(hspi);
 800299c:	2140      	movs	r1, #64	; 0x40
 800299e:	681a      	ldr	r2, [r3, #0]
 80029a0:	438a      	bics	r2, r1
 80029a2:	601a      	str	r2, [r3, #0]
        }

        /* Reset CRC Calculation */
        if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
 80029a4:	2180      	movs	r1, #128	; 0x80
 80029a6:	6a82      	ldr	r2, [r0, #40]	; 0x28
 80029a8:	0189      	lsls	r1, r1, #6
 80029aa:	428a      	cmp	r2, r1
 80029ac:	d106      	bne.n	80029bc <SPI_WaitFifoStateUntilTimeout.part.1+0x48>
        {
          SPI_RESET_CRC(hspi);
 80029ae:	6819      	ldr	r1, [r3, #0]
 80029b0:	4c07      	ldr	r4, [pc, #28]	; (80029d0 <SPI_WaitFifoStateUntilTimeout.part.1+0x5c>)
 80029b2:	4021      	ands	r1, r4
 80029b4:	6019      	str	r1, [r3, #0]
 80029b6:	6819      	ldr	r1, [r3, #0]
 80029b8:	430a      	orrs	r2, r1
 80029ba:	601a      	str	r2, [r3, #0]
        }

        hspi->State = HAL_SPI_STATE_READY;
 80029bc:	0003      	movs	r3, r0
 80029be:	2201      	movs	r2, #1
 80029c0:	335d      	adds	r3, #93	; 0x5d
 80029c2:	701a      	strb	r2, [r3, #0]

        /* Process Unlocked */
        __HAL_UNLOCK(hspi);
 80029c4:	2300      	movs	r3, #0
 80029c6:	305c      	adds	r0, #92	; 0x5c
 80029c8:	7003      	strb	r3, [r0, #0]
      }
    }
  }

  return HAL_OK;
}
 80029ca:	2003      	movs	r0, #3
 80029cc:	bd10      	pop	{r4, pc}
 80029ce:	46c0      	nop			; (mov r8, r8)
 80029d0:	ffffdfff 	.word	0xffffdfff

080029d4 <SPI_WaitFlagStateUntilTimeout.constprop.9>:
static HAL_StatusTypeDef SPI_WaitFlagStateUntilTimeout(SPI_HandleTypeDef *hspi, uint32_t Flag, FlagStatus State,
 80029d4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80029d6:	0004      	movs	r4, r0
 80029d8:	000d      	movs	r5, r1
 80029da:	0017      	movs	r7, r2
  while ((__HAL_SPI_GET_FLAG(hspi, Flag) ? SET : RESET) != State)
 80029dc:	2680      	movs	r6, #128	; 0x80
 80029de:	6823      	ldr	r3, [r4, #0]
 80029e0:	6898      	ldr	r0, [r3, #8]
 80029e2:	4030      	ands	r0, r6
 80029e4:	d009      	beq.n	80029fa <SPI_WaitFlagStateUntilTimeout.constprop.9+0x26>
    if (Timeout != HAL_MAX_DELAY)
 80029e6:	1c6a      	adds	r2, r5, #1
 80029e8:	d0fa      	beq.n	80029e0 <SPI_WaitFlagStateUntilTimeout.constprop.9+0xc>
      if (((HAL_GetTick() - Tickstart) >= Timeout) || (Timeout == 0U))
 80029ea:	f7ff f813 	bl	8001a14 <HAL_GetTick>
 80029ee:	1bc0      	subs	r0, r0, r7
 80029f0:	4285      	cmp	r5, r0
 80029f2:	d8f4      	bhi.n	80029de <SPI_WaitFlagStateUntilTimeout.constprop.9+0xa>
 80029f4:	0020      	movs	r0, r4
 80029f6:	f7ff ffbd 	bl	8002974 <SPI_WaitFifoStateUntilTimeout.part.1>
}
 80029fa:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

080029fc <SPI_WaitFifoStateUntilTimeout.constprop.10>:
  * @param  State Fifo state to check
  * @param  Timeout Timeout duration
  * @param  Tickstart tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef SPI_WaitFifoStateUntilTimeout(SPI_HandleTypeDef *hspi, uint32_t Fifo, uint32_t State,
 80029fc:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
                                                       uint32_t Timeout, uint32_t Tickstart)
{
  while ((hspi->Instance->SR & Fifo) != State)
  {
    if ((Fifo == SPI_SR_FRLVL) && (State == SPI_FRLVL_EMPTY))
 80029fe:	27c0      	movs	r7, #192	; 0xc0
static HAL_StatusTypeDef SPI_WaitFifoStateUntilTimeout(SPI_HandleTypeDef *hspi, uint32_t Fifo, uint32_t State,
 8002a00:	0005      	movs	r5, r0
 8002a02:	000c      	movs	r4, r1
 8002a04:	0016      	movs	r6, r2
 8002a06:	9301      	str	r3, [sp, #4]
    if ((Fifo == SPI_SR_FRLVL) && (State == SPI_FRLVL_EMPTY))
 8002a08:	00ff      	lsls	r7, r7, #3
  while ((hspi->Instance->SR & Fifo) != State)
 8002a0a:	682b      	ldr	r3, [r5, #0]
 8002a0c:	6898      	ldr	r0, [r3, #8]
 8002a0e:	4020      	ands	r0, r4
 8002a10:	d00d      	beq.n	8002a2e <SPI_WaitFifoStateUntilTimeout.constprop.10+0x32>
    if ((Fifo == SPI_SR_FRLVL) && (State == SPI_FRLVL_EMPTY))
 8002a12:	42bc      	cmp	r4, r7
 8002a14:	d100      	bne.n	8002a18 <SPI_WaitFifoStateUntilTimeout.constprop.10+0x1c>
    {
      /* Read 8bit CRC to flush Data Register */
      READ_REG(*((__IO uint8_t *)&hspi->Instance->DR));
 8002a16:	7b1a      	ldrb	r2, [r3, #12]
    }

    if (Timeout != HAL_MAX_DELAY)
 8002a18:	1c72      	adds	r2, r6, #1
 8002a1a:	d0f7      	beq.n	8002a0c <SPI_WaitFifoStateUntilTimeout.constprop.10+0x10>
    {
      if (((HAL_GetTick() - Tickstart) >= Timeout) || (Timeout == 0U))
 8002a1c:	f7fe fffa 	bl	8001a14 <HAL_GetTick>
 8002a20:	9b01      	ldr	r3, [sp, #4]
 8002a22:	1ac0      	subs	r0, r0, r3
 8002a24:	4286      	cmp	r6, r0
 8002a26:	d8f0      	bhi.n	8002a0a <SPI_WaitFifoStateUntilTimeout.constprop.10+0xe>
 8002a28:	0028      	movs	r0, r5
 8002a2a:	f7ff ffa3 	bl	8002974 <SPI_WaitFifoStateUntilTimeout.part.1>
      }
    }
  }

  return HAL_OK;
}
 8002a2e:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}

08002a30 <SPI_EndRxTxTransaction>:
  * @param  Timeout Timeout duration
  * @param  Tickstart tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef SPI_EndRxTxTransaction(SPI_HandleTypeDef *hspi, uint32_t Timeout, uint32_t Tickstart)
{
 8002a30:	b570      	push	{r4, r5, r6, lr}
  /* Control if the TX fifo is empty */
  if (SPI_WaitFifoStateUntilTimeout(hspi, SPI_FLAG_FTLVL, SPI_FTLVL_EMPTY, Timeout, Tickstart) != HAL_OK)
 8002a32:	0013      	movs	r3, r2
{
 8002a34:	000d      	movs	r5, r1
 8002a36:	0016      	movs	r6, r2
  if (SPI_WaitFifoStateUntilTimeout(hspi, SPI_FLAG_FTLVL, SPI_FTLVL_EMPTY, Timeout, Tickstart) != HAL_OK)
 8002a38:	000a      	movs	r2, r1
 8002a3a:	21c0      	movs	r1, #192	; 0xc0
 8002a3c:	0149      	lsls	r1, r1, #5
{
 8002a3e:	0004      	movs	r4, r0
  if (SPI_WaitFifoStateUntilTimeout(hspi, SPI_FLAG_FTLVL, SPI_FTLVL_EMPTY, Timeout, Tickstart) != HAL_OK)
 8002a40:	f7ff ffdc 	bl	80029fc <SPI_WaitFifoStateUntilTimeout.constprop.10>
 8002a44:	2800      	cmp	r0, #0
 8002a46:	d005      	beq.n	8002a54 <SPI_EndRxTxTransaction+0x24>
  }

  /* Control if the RX fifo is empty */
  if (SPI_WaitFifoStateUntilTimeout(hspi, SPI_FLAG_FRLVL, SPI_FRLVL_EMPTY, Timeout, Tickstart) != HAL_OK)
  {
    SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
 8002a48:	2320      	movs	r3, #32
 8002a4a:	6e22      	ldr	r2, [r4, #96]	; 0x60
    return HAL_TIMEOUT;
 8002a4c:	2003      	movs	r0, #3
    SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
 8002a4e:	4313      	orrs	r3, r2
 8002a50:	6623      	str	r3, [r4, #96]	; 0x60
 8002a52:	e00f      	b.n	8002a74 <SPI_EndRxTxTransaction+0x44>
  if (SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_BSY, RESET, Timeout, Tickstart) != HAL_OK)
 8002a54:	0032      	movs	r2, r6
 8002a56:	0029      	movs	r1, r5
 8002a58:	0020      	movs	r0, r4
 8002a5a:	f7ff ffbb 	bl	80029d4 <SPI_WaitFlagStateUntilTimeout.constprop.9>
 8002a5e:	2800      	cmp	r0, #0
 8002a60:	d1f2      	bne.n	8002a48 <SPI_EndRxTxTransaction+0x18>
  if (SPI_WaitFifoStateUntilTimeout(hspi, SPI_FLAG_FRLVL, SPI_FRLVL_EMPTY, Timeout, Tickstart) != HAL_OK)
 8002a62:	21c0      	movs	r1, #192	; 0xc0
 8002a64:	0033      	movs	r3, r6
 8002a66:	002a      	movs	r2, r5
 8002a68:	00c9      	lsls	r1, r1, #3
 8002a6a:	0020      	movs	r0, r4
 8002a6c:	f7ff ffc6 	bl	80029fc <SPI_WaitFifoStateUntilTimeout.constprop.10>
 8002a70:	2800      	cmp	r0, #0
 8002a72:	d1e9      	bne.n	8002a48 <SPI_EndRxTxTransaction+0x18>
  }

  return HAL_OK;
}
 8002a74:	bd70      	pop	{r4, r5, r6, pc}
	...

08002a78 <HAL_SPI_Init>:
{
 8002a78:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8002a7a:	0004      	movs	r4, r0
    return HAL_ERROR;
 8002a7c:	2001      	movs	r0, #1
  if (hspi == NULL)
 8002a7e:	2c00      	cmp	r4, #0
 8002a80:	d04e      	beq.n	8002b20 <HAL_SPI_Init+0xa8>
  hspi->Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
 8002a82:	2300      	movs	r3, #0
  if (hspi->State == HAL_SPI_STATE_RESET)
 8002a84:	0025      	movs	r5, r4
  hspi->Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
 8002a86:	62a3      	str	r3, [r4, #40]	; 0x28
  if (hspi->State == HAL_SPI_STATE_RESET)
 8002a88:	355d      	adds	r5, #93	; 0x5d
 8002a8a:	782b      	ldrb	r3, [r5, #0]
 8002a8c:	b2db      	uxtb	r3, r3
 8002a8e:	2b00      	cmp	r3, #0
 8002a90:	d105      	bne.n	8002a9e <HAL_SPI_Init+0x26>
    hspi->Lock = HAL_UNLOCKED;
 8002a92:	0022      	movs	r2, r4
 8002a94:	325c      	adds	r2, #92	; 0x5c
 8002a96:	7013      	strb	r3, [r2, #0]
    HAL_SPI_MspInit(hspi);
 8002a98:	0020      	movs	r0, r4
 8002a9a:	f7fe fcc5 	bl	8001428 <HAL_SPI_MspInit>
  hspi->State = HAL_SPI_STATE_BUSY;
 8002a9e:	2302      	movs	r3, #2
  __HAL_SPI_DISABLE(hspi);
 8002aa0:	2140      	movs	r1, #64	; 0x40
 8002aa2:	6822      	ldr	r2, [r4, #0]
  hspi->State = HAL_SPI_STATE_BUSY;
 8002aa4:	702b      	strb	r3, [r5, #0]
  __HAL_SPI_DISABLE(hspi);
 8002aa6:	6813      	ldr	r3, [r2, #0]
  if (hspi->Init.DataSize > SPI_DATASIZE_8BIT)
 8002aa8:	68e0      	ldr	r0, [r4, #12]
  __HAL_SPI_DISABLE(hspi);
 8002aaa:	438b      	bics	r3, r1
 8002aac:	21e0      	movs	r1, #224	; 0xe0
 8002aae:	6013      	str	r3, [r2, #0]
 8002ab0:	00c9      	lsls	r1, r1, #3
 8002ab2:	2300      	movs	r3, #0
  if (hspi->Init.DataSize > SPI_DATASIZE_8BIT)
 8002ab4:	4288      	cmp	r0, r1
 8002ab6:	d834      	bhi.n	8002b22 <HAL_SPI_Init+0xaa>
    frxth = SPI_RXFIFO_THRESHOLD_QF;
 8002ab8:	2680      	movs	r6, #128	; 0x80
 8002aba:	0176      	lsls	r6, r6, #5
  if ((hspi->Init.DataSize != SPI_DATASIZE_16BIT) && (hspi->Init.DataSize != SPI_DATASIZE_8BIT))
 8002abc:	4288      	cmp	r0, r1
 8002abe:	d101      	bne.n	8002ac4 <HAL_SPI_Init+0x4c>
 8002ac0:	e001      	b.n	8002ac6 <HAL_SPI_Init+0x4e>
    frxth = SPI_RXFIFO_THRESHOLD_HF;
 8002ac2:	001e      	movs	r6, r3
    hspi->Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
 8002ac4:	62a3      	str	r3, [r4, #40]	; 0x28
  if (hspi->Init.CRCLength == SPI_CRC_LENGTH_DATASIZE)
 8002ac6:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8002ac8:	2b00      	cmp	r3, #0
 8002aca:	d104      	bne.n	8002ad6 <HAL_SPI_Init+0x5e>
      hspi->Init.CRCLength = SPI_CRC_LENGTH_16BIT;
 8002acc:	3302      	adds	r3, #2
    if (hspi->Init.DataSize > SPI_DATASIZE_8BIT)
 8002ace:	4288      	cmp	r0, r1
 8002ad0:	d800      	bhi.n	8002ad4 <HAL_SPI_Init+0x5c>
      hspi->Init.CRCLength = SPI_CRC_LENGTH_8BIT;
 8002ad2:	2301      	movs	r3, #1
 8002ad4:	6323      	str	r3, [r4, #48]	; 0x30
  WRITE_REG(hspi->Instance->CR1, (hspi->Init.Mode | hspi->Init.Direction |
 8002ad6:	68a7      	ldr	r7, [r4, #8]
 8002ad8:	6863      	ldr	r3, [r4, #4]
 8002ada:	69a1      	ldr	r1, [r4, #24]
 8002adc:	433b      	orrs	r3, r7
 8002ade:	6927      	ldr	r7, [r4, #16]
 8002ae0:	433b      	orrs	r3, r7
 8002ae2:	6967      	ldr	r7, [r4, #20]
 8002ae4:	433b      	orrs	r3, r7
 8002ae6:	69e7      	ldr	r7, [r4, #28]
 8002ae8:	433b      	orrs	r3, r7
 8002aea:	6a27      	ldr	r7, [r4, #32]
 8002aec:	433b      	orrs	r3, r7
 8002aee:	6aa7      	ldr	r7, [r4, #40]	; 0x28
 8002af0:	433b      	orrs	r3, r7
 8002af2:	2780      	movs	r7, #128	; 0x80
 8002af4:	00bf      	lsls	r7, r7, #2
 8002af6:	400f      	ands	r7, r1
 8002af8:	433b      	orrs	r3, r7
 8002afa:	6013      	str	r3, [r2, #0]
  WRITE_REG(hspi->Instance->CR2, (((hspi->Init.NSS >> 16U) & SPI_CR2_SSOE) | hspi->Init.TIMode |
 8002afc:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8002afe:	0c09      	lsrs	r1, r1, #16
 8002b00:	4318      	orrs	r0, r3
 8002b02:	6b63      	ldr	r3, [r4, #52]	; 0x34
 8002b04:	4318      	orrs	r0, r3
 8002b06:	2304      	movs	r3, #4
 8002b08:	4019      	ands	r1, r3
 8002b0a:	4301      	orrs	r1, r0
 8002b0c:	430e      	orrs	r6, r1
 8002b0e:	6056      	str	r6, [r2, #4]
  CLEAR_BIT(hspi->Instance->I2SCFGR, SPI_I2SCFGR_I2SMOD);
 8002b10:	69d3      	ldr	r3, [r2, #28]
 8002b12:	4907      	ldr	r1, [pc, #28]	; (8002b30 <HAL_SPI_Init+0xb8>)
  hspi->ErrorCode = HAL_SPI_ERROR_NONE;
 8002b14:	2000      	movs	r0, #0
  CLEAR_BIT(hspi->Instance->I2SCFGR, SPI_I2SCFGR_I2SMOD);
 8002b16:	400b      	ands	r3, r1
 8002b18:	61d3      	str	r3, [r2, #28]
  hspi->State     = HAL_SPI_STATE_READY;
 8002b1a:	2301      	movs	r3, #1
  hspi->ErrorCode = HAL_SPI_ERROR_NONE;
 8002b1c:	6620      	str	r0, [r4, #96]	; 0x60
  hspi->State     = HAL_SPI_STATE_READY;
 8002b1e:	702b      	strb	r3, [r5, #0]
}
 8002b20:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  if ((hspi->Init.DataSize != SPI_DATASIZE_16BIT) && (hspi->Init.DataSize != SPI_DATASIZE_8BIT))
 8002b22:	26f0      	movs	r6, #240	; 0xf0
 8002b24:	0136      	lsls	r6, r6, #4
 8002b26:	42b0      	cmp	r0, r6
 8002b28:	d1cb      	bne.n	8002ac2 <HAL_SPI_Init+0x4a>
    frxth = SPI_RXFIFO_THRESHOLD_HF;
 8002b2a:	001e      	movs	r6, r3
 8002b2c:	e7cb      	b.n	8002ac6 <HAL_SPI_Init+0x4e>
 8002b2e:	46c0      	nop			; (mov r8, r8)
 8002b30:	fffff7ff 	.word	0xfffff7ff

08002b34 <HAL_SPI_Transmit_DMA>:
{
 8002b34:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  __HAL_LOCK(hspi);
 8002b36:	0005      	movs	r5, r0
 8002b38:	355c      	adds	r5, #92	; 0x5c
 8002b3a:	782b      	ldrb	r3, [r5, #0]
{
 8002b3c:	0004      	movs	r4, r0
  __HAL_LOCK(hspi);
 8002b3e:	2002      	movs	r0, #2
 8002b40:	2b01      	cmp	r3, #1
 8002b42:	d056      	beq.n	8002bf2 <HAL_SPI_Transmit_DMA+0xbe>
 8002b44:	2301      	movs	r3, #1
  if (hspi->State != HAL_SPI_STATE_READY)
 8002b46:	0026      	movs	r6, r4
  __HAL_LOCK(hspi);
 8002b48:	702b      	strb	r3, [r5, #0]
  if (hspi->State != HAL_SPI_STATE_READY)
 8002b4a:	365d      	adds	r6, #93	; 0x5d
 8002b4c:	7833      	ldrb	r3, [r6, #0]
 8002b4e:	b2db      	uxtb	r3, r3
 8002b50:	2b01      	cmp	r3, #1
 8002b52:	d14c      	bne.n	8002bee <HAL_SPI_Transmit_DMA+0xba>
    errorcode = HAL_ERROR;
 8002b54:	0018      	movs	r0, r3
  if ((pData == NULL) || (Size == 0U))
 8002b56:	2900      	cmp	r1, #0
 8002b58:	d049      	beq.n	8002bee <HAL_SPI_Transmit_DMA+0xba>
 8002b5a:	2a00      	cmp	r2, #0
 8002b5c:	d047      	beq.n	8002bee <HAL_SPI_Transmit_DMA+0xba>
  hspi->State       = HAL_SPI_STATE_BUSY_TX;
 8002b5e:	3302      	adds	r3, #2
 8002b60:	7033      	strb	r3, [r6, #0]
  hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
 8002b62:	2300      	movs	r3, #0
  hspi->TxXferSize  = Size;
 8002b64:	87a2      	strh	r2, [r4, #60]	; 0x3c
  hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
 8002b66:	6623      	str	r3, [r4, #96]	; 0x60
  hspi->TxXferCount = Size;
 8002b68:	87e2      	strh	r2, [r4, #62]	; 0x3e
  hspi->RxXferSize  = 0U;
 8002b6a:	1da2      	adds	r2, r4, #6
  hspi->pRxBuffPtr  = (uint8_t *)NULL;
 8002b6c:	6423      	str	r3, [r4, #64]	; 0x40
  hspi->TxISR       = NULL;
 8002b6e:	6523      	str	r3, [r4, #80]	; 0x50
  hspi->RxISR       = NULL;
 8002b70:	64e3      	str	r3, [r4, #76]	; 0x4c
  hspi->pTxBuffPtr  = (uint8_t *)pData;
 8002b72:	63a1      	str	r1, [r4, #56]	; 0x38
  hspi->RxXferCount = 0U;
 8002b74:	3202      	adds	r2, #2
  hspi->RxXferSize  = 0U;
 8002b76:	8793      	strh	r3, [r2, #60]	; 0x3c
  hspi->RxXferCount = 0U;
 8002b78:	87d3      	strh	r3, [r2, #62]	; 0x3e
  if (hspi->Init.Direction == SPI_DIRECTION_1LINE)
 8002b7a:	2380      	movs	r3, #128	; 0x80
 8002b7c:	68a0      	ldr	r0, [r4, #8]
 8002b7e:	6822      	ldr	r2, [r4, #0]
 8002b80:	021b      	lsls	r3, r3, #8
 8002b82:	4298      	cmp	r0, r3
 8002b84:	d104      	bne.n	8002b90 <HAL_SPI_Transmit_DMA+0x5c>
    SPI_1LINE_TX(hspi);
 8002b86:	2380      	movs	r3, #128	; 0x80
 8002b88:	6810      	ldr	r0, [r2, #0]
 8002b8a:	01db      	lsls	r3, r3, #7
 8002b8c:	4303      	orrs	r3, r0
 8002b8e:	6013      	str	r3, [r2, #0]
  hspi->hdmatx->XferHalfCpltCallback = SPI_DMAHalfTransmitCplt;
 8002b90:	6d60      	ldr	r0, [r4, #84]	; 0x54
 8002b92:	4b25      	ldr	r3, [pc, #148]	; (8002c28 <HAL_SPI_Transmit_DMA+0xf4>)
  CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_LDMATX);
 8002b94:	6857      	ldr	r7, [r2, #4]
  hspi->hdmatx->XferHalfCpltCallback = SPI_DMAHalfTransmitCplt;
 8002b96:	62c3      	str	r3, [r0, #44]	; 0x2c
  hspi->hdmatx->XferCpltCallback = SPI_DMATransmitCplt;
 8002b98:	4b24      	ldr	r3, [pc, #144]	; (8002c2c <HAL_SPI_Transmit_DMA+0xf8>)
 8002b9a:	6283      	str	r3, [r0, #40]	; 0x28
  hspi->hdmatx->XferErrorCallback = SPI_DMAError;
 8002b9c:	4b24      	ldr	r3, [pc, #144]	; (8002c30 <HAL_SPI_Transmit_DMA+0xfc>)
 8002b9e:	6303      	str	r3, [r0, #48]	; 0x30
  hspi->hdmatx->XferAbortCallback = NULL;
 8002ba0:	2300      	movs	r3, #0
 8002ba2:	6343      	str	r3, [r0, #52]	; 0x34
  CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_LDMATX);
 8002ba4:	4b23      	ldr	r3, [pc, #140]	; (8002c34 <HAL_SPI_Transmit_DMA+0x100>)
 8002ba6:	401f      	ands	r7, r3
 8002ba8:	469c      	mov	ip, r3
  if ((hspi->Init.DataSize <= SPI_DATASIZE_8BIT) && (hspi->hdmatx->Init.MemDataAlignment == DMA_MDATAALIGN_HALFWORD))
 8002baa:	23e0      	movs	r3, #224	; 0xe0
  CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_LDMATX);
 8002bac:	6057      	str	r7, [r2, #4]
  if ((hspi->Init.DataSize <= SPI_DATASIZE_8BIT) && (hspi->hdmatx->Init.MemDataAlignment == DMA_MDATAALIGN_HALFWORD))
 8002bae:	68e7      	ldr	r7, [r4, #12]
 8002bb0:	00db      	lsls	r3, r3, #3
 8002bb2:	429f      	cmp	r7, r3
 8002bb4:	d80e      	bhi.n	8002bd4 <HAL_SPI_Transmit_DMA+0xa0>
 8002bb6:	2380      	movs	r3, #128	; 0x80
 8002bb8:	6947      	ldr	r7, [r0, #20]
 8002bba:	00db      	lsls	r3, r3, #3
 8002bbc:	429f      	cmp	r7, r3
 8002bbe:	d109      	bne.n	8002bd4 <HAL_SPI_Transmit_DMA+0xa0>
    if ((hspi->TxXferCount & 0x1U) == 0U)
 8002bc0:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
 8002bc2:	07db      	lsls	r3, r3, #31
 8002bc4:	d416      	bmi.n	8002bf4 <HAL_SPI_Transmit_DMA+0xc0>
      CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_LDMATX);
 8002bc6:	4667      	mov	r7, ip
 8002bc8:	6853      	ldr	r3, [r2, #4]
 8002bca:	403b      	ands	r3, r7
 8002bcc:	6053      	str	r3, [r2, #4]
      hspi->TxXferCount = (hspi->TxXferCount >> 1U);
 8002bce:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
 8002bd0:	085b      	lsrs	r3, r3, #1
      hspi->TxXferCount = (hspi->TxXferCount >> 1U) + 1U;
 8002bd2:	87e3      	strh	r3, [r4, #62]	; 0x3e
                                 hspi->TxXferCount))
 8002bd4:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
  if (HAL_OK != HAL_DMA_Start_IT(hspi->hdmatx, (uint32_t)hspi->pTxBuffPtr, (uint32_t)&hspi->Instance->DR,
 8002bd6:	320c      	adds	r2, #12
                                 hspi->TxXferCount))
 8002bd8:	b29b      	uxth	r3, r3
  if (HAL_OK != HAL_DMA_Start_IT(hspi->hdmatx, (uint32_t)hspi->pTxBuffPtr, (uint32_t)&hspi->Instance->DR,
 8002bda:	f7ff f8f7 	bl	8001dcc <HAL_DMA_Start_IT>
 8002bde:	2800      	cmp	r0, #0
 8002be0:	d011      	beq.n	8002c06 <HAL_SPI_Transmit_DMA+0xd2>
    SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_DMA);
 8002be2:	2310      	movs	r3, #16
    hspi->State = HAL_SPI_STATE_READY;
 8002be4:	2001      	movs	r0, #1
    SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_DMA);
 8002be6:	6e22      	ldr	r2, [r4, #96]	; 0x60
 8002be8:	4313      	orrs	r3, r2
 8002bea:	6623      	str	r3, [r4, #96]	; 0x60
    hspi->State = HAL_SPI_STATE_READY;
 8002bec:	7030      	strb	r0, [r6, #0]
  __HAL_UNLOCK(hspi);
 8002bee:	2300      	movs	r3, #0
 8002bf0:	702b      	strb	r3, [r5, #0]
}
 8002bf2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      SET_BIT(hspi->Instance->CR2, SPI_CR2_LDMATX);
 8002bf4:	2380      	movs	r3, #128	; 0x80
 8002bf6:	6857      	ldr	r7, [r2, #4]
 8002bf8:	01db      	lsls	r3, r3, #7
 8002bfa:	433b      	orrs	r3, r7
 8002bfc:	6053      	str	r3, [r2, #4]
      hspi->TxXferCount = (hspi->TxXferCount >> 1U) + 1U;
 8002bfe:	8fe3      	ldrh	r3, [r4, #62]	; 0x3e
 8002c00:	085b      	lsrs	r3, r3, #1
 8002c02:	3301      	adds	r3, #1
 8002c04:	e7e5      	b.n	8002bd2 <HAL_SPI_Transmit_DMA+0x9e>
  if ((hspi->Instance->CR1 & SPI_CR1_SPE) != SPI_CR1_SPE)
 8002c06:	2240      	movs	r2, #64	; 0x40
 8002c08:	6823      	ldr	r3, [r4, #0]
 8002c0a:	6819      	ldr	r1, [r3, #0]
 8002c0c:	4211      	tst	r1, r2
 8002c0e:	d102      	bne.n	8002c16 <HAL_SPI_Transmit_DMA+0xe2>
    __HAL_SPI_ENABLE(hspi);
 8002c10:	6819      	ldr	r1, [r3, #0]
 8002c12:	430a      	orrs	r2, r1
 8002c14:	601a      	str	r2, [r3, #0]
  __HAL_SPI_ENABLE_IT(hspi, (SPI_IT_ERR));
 8002c16:	2220      	movs	r2, #32
 8002c18:	6859      	ldr	r1, [r3, #4]
 8002c1a:	430a      	orrs	r2, r1
 8002c1c:	605a      	str	r2, [r3, #4]
  SET_BIT(hspi->Instance->CR2, SPI_CR2_TXDMAEN);
 8002c1e:	2202      	movs	r2, #2
 8002c20:	6859      	ldr	r1, [r3, #4]
 8002c22:	430a      	orrs	r2, r1
 8002c24:	605a      	str	r2, [r3, #4]
 8002c26:	e7e2      	b.n	8002bee <HAL_SPI_Transmit_DMA+0xba>
 8002c28:	08002c3d 	.word	0x08002c3d
 8002c2c:	08002c6d 	.word	0x08002c6d
 8002c30:	08002c49 	.word	0x08002c49
 8002c34:	ffffbfff 	.word	0xffffbfff

08002c38 <HAL_SPI_TxCpltCallback>:
 8002c38:	4770      	bx	lr

08002c3a <HAL_SPI_TxHalfCpltCallback>:
 8002c3a:	4770      	bx	lr

08002c3c <SPI_DMAHalfTransmitCplt>:
{
 8002c3c:	b510      	push	{r4, lr}
  HAL_SPI_TxHalfCpltCallback(hspi);
 8002c3e:	6a40      	ldr	r0, [r0, #36]	; 0x24
 8002c40:	f7ff fffb 	bl	8002c3a <HAL_SPI_TxHalfCpltCallback>
}
 8002c44:	bd10      	pop	{r4, pc}

08002c46 <HAL_SPI_ErrorCallback>:
 8002c46:	4770      	bx	lr

08002c48 <SPI_DMAError>:
  CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_TXDMAEN | SPI_CR2_RXDMAEN);
 8002c48:	2103      	movs	r1, #3
  SPI_HandleTypeDef *hspi = (SPI_HandleTypeDef *)(((DMA_HandleTypeDef *)hdma)->Parent); /* Derogation MISRAC2012-Rule-11.5 */
 8002c4a:	6a40      	ldr	r0, [r0, #36]	; 0x24
{
 8002c4c:	b510      	push	{r4, lr}
  CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_TXDMAEN | SPI_CR2_RXDMAEN);
 8002c4e:	6802      	ldr	r2, [r0, #0]
 8002c50:	6853      	ldr	r3, [r2, #4]
 8002c52:	438b      	bics	r3, r1
 8002c54:	6053      	str	r3, [r2, #4]
  SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_DMA);
 8002c56:	2310      	movs	r3, #16
 8002c58:	6e02      	ldr	r2, [r0, #96]	; 0x60
 8002c5a:	4313      	orrs	r3, r2
 8002c5c:	6603      	str	r3, [r0, #96]	; 0x60
  hspi->State = HAL_SPI_STATE_READY;
 8002c5e:	0003      	movs	r3, r0
 8002c60:	2201      	movs	r2, #1
 8002c62:	335d      	adds	r3, #93	; 0x5d
 8002c64:	701a      	strb	r2, [r3, #0]
  HAL_SPI_ErrorCallback(hspi);
 8002c66:	f7ff ffee 	bl	8002c46 <HAL_SPI_ErrorCallback>
}
 8002c6a:	bd10      	pop	{r4, pc}

08002c6c <SPI_DMATransmitCplt>:
{
 8002c6c:	b537      	push	{r0, r1, r2, r4, r5, lr}
 8002c6e:	0005      	movs	r5, r0
  SPI_HandleTypeDef *hspi = (SPI_HandleTypeDef *)(((DMA_HandleTypeDef *)hdma)->Parent); /* Derogation MISRAC2012-Rule-11.5 */
 8002c70:	6a44      	ldr	r4, [r0, #36]	; 0x24
  tickstart = HAL_GetTick();
 8002c72:	f7fe fecf 	bl	8001a14 <HAL_GetTick>
  if ((hdma->Instance->CCR & DMA_CCR_CIRC) != DMA_CCR_CIRC)
 8002c76:	682b      	ldr	r3, [r5, #0]
 8002c78:	2520      	movs	r5, #32
 8002c7a:	681b      	ldr	r3, [r3, #0]
  tickstart = HAL_GetTick();
 8002c7c:	0002      	movs	r2, r0
  if ((hdma->Instance->CCR & DMA_CCR_CIRC) != DMA_CCR_CIRC)
 8002c7e:	422b      	tst	r3, r5
 8002c80:	d127      	bne.n	8002cd2 <SPI_DMATransmitCplt+0x66>
    CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_TXDMAEN);
 8002c82:	2002      	movs	r0, #2
    __HAL_SPI_DISABLE_IT(hspi, SPI_IT_ERR);
 8002c84:	6823      	ldr	r3, [r4, #0]
 8002c86:	6859      	ldr	r1, [r3, #4]
 8002c88:	43a9      	bics	r1, r5
 8002c8a:	6059      	str	r1, [r3, #4]
    CLEAR_BIT(hspi->Instance->CR2, SPI_CR2_TXDMAEN);
 8002c8c:	6859      	ldr	r1, [r3, #4]
 8002c8e:	4381      	bics	r1, r0
 8002c90:	6059      	str	r1, [r3, #4]
    if (SPI_EndRxTxTransaction(hspi, SPI_DEFAULT_TIMEOUT, tickstart) != HAL_OK)
 8002c92:	0020      	movs	r0, r4
 8002c94:	2164      	movs	r1, #100	; 0x64
 8002c96:	f7ff fecb 	bl	8002a30 <SPI_EndRxTxTransaction>
 8002c9a:	2800      	cmp	r0, #0
 8002c9c:	d002      	beq.n	8002ca4 <SPI_DMATransmitCplt+0x38>
      SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
 8002c9e:	6e23      	ldr	r3, [r4, #96]	; 0x60
 8002ca0:	431d      	orrs	r5, r3
 8002ca2:	6625      	str	r5, [r4, #96]	; 0x60
    if (hspi->Init.Direction == SPI_DIRECTION_2LINES)
 8002ca4:	68a3      	ldr	r3, [r4, #8]
 8002ca6:	2b00      	cmp	r3, #0
 8002ca8:	d106      	bne.n	8002cb8 <SPI_DMATransmitCplt+0x4c>
      __HAL_SPI_CLEAR_OVRFLAG(hspi);
 8002caa:	9301      	str	r3, [sp, #4]
 8002cac:	6823      	ldr	r3, [r4, #0]
 8002cae:	68da      	ldr	r2, [r3, #12]
 8002cb0:	9201      	str	r2, [sp, #4]
 8002cb2:	689b      	ldr	r3, [r3, #8]
 8002cb4:	9301      	str	r3, [sp, #4]
 8002cb6:	9b01      	ldr	r3, [sp, #4]
    hspi->TxXferCount = 0U;
 8002cb8:	2300      	movs	r3, #0
 8002cba:	87e3      	strh	r3, [r4, #62]	; 0x3e
    hspi->State = HAL_SPI_STATE_READY;
 8002cbc:	0023      	movs	r3, r4
 8002cbe:	2201      	movs	r2, #1
 8002cc0:	335d      	adds	r3, #93	; 0x5d
 8002cc2:	701a      	strb	r2, [r3, #0]
    if (hspi->ErrorCode != HAL_SPI_ERROR_NONE)
 8002cc4:	6e23      	ldr	r3, [r4, #96]	; 0x60
 8002cc6:	2b00      	cmp	r3, #0
 8002cc8:	d003      	beq.n	8002cd2 <SPI_DMATransmitCplt+0x66>
      HAL_SPI_ErrorCallback(hspi);
 8002cca:	0020      	movs	r0, r4
 8002ccc:	f7ff ffbb 	bl	8002c46 <HAL_SPI_ErrorCallback>
}
 8002cd0:	bd37      	pop	{r0, r1, r2, r4, r5, pc}
  HAL_SPI_TxCpltCallback(hspi);
 8002cd2:	0020      	movs	r0, r4
 8002cd4:	f7ff ffb0 	bl	8002c38 <HAL_SPI_TxCpltCallback>
 8002cd8:	e7fa      	b.n	8002cd0 <SPI_DMATransmitCplt+0x64>

08002cda <HAL_TIM_Base_Start_IT>:

  /* Check the parameters */
  assert_param(IS_TIM_INSTANCE(htim->Instance));

  /* Enable the TIM Update interrupt */
  __HAL_TIM_ENABLE_IT(htim, TIM_IT_UPDATE);
 8002cda:	2201      	movs	r2, #1
 8002cdc:	6803      	ldr	r3, [r0, #0]

  /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */
  tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
 8002cde:	2007      	movs	r0, #7
  __HAL_TIM_ENABLE_IT(htim, TIM_IT_UPDATE);
 8002ce0:	68d9      	ldr	r1, [r3, #12]
 8002ce2:	4311      	orrs	r1, r2
 8002ce4:	60d9      	str	r1, [r3, #12]
  tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
 8002ce6:	6899      	ldr	r1, [r3, #8]
 8002ce8:	4001      	ands	r1, r0
  if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
 8002cea:	2906      	cmp	r1, #6
 8002cec:	d002      	beq.n	8002cf4 <HAL_TIM_Base_Start_IT+0x1a>
  {
    __HAL_TIM_ENABLE(htim);
 8002cee:	6819      	ldr	r1, [r3, #0]
 8002cf0:	430a      	orrs	r2, r1
 8002cf2:	601a      	str	r2, [r3, #0]
  }

  /* Return function status */
  return HAL_OK;
}
 8002cf4:	2000      	movs	r0, #0
 8002cf6:	4770      	bx	lr

08002cf8 <HAL_TIM_Base_Stop_IT>:
HAL_StatusTypeDef HAL_TIM_Base_Stop_IT(TIM_HandleTypeDef *htim)
{
  /* Check the parameters */
  assert_param(IS_TIM_INSTANCE(htim->Instance));
  /* Disable the TIM Update interrupt */
  __HAL_TIM_DISABLE_IT(htim, TIM_IT_UPDATE);
 8002cf8:	2101      	movs	r1, #1
 8002cfa:	6803      	ldr	r3, [r0, #0]
 8002cfc:	68da      	ldr	r2, [r3, #12]
 8002cfe:	438a      	bics	r2, r1
 8002d00:	60da      	str	r2, [r3, #12]

  /* Disable the Peripheral */
  __HAL_TIM_DISABLE(htim);
 8002d02:	6a18      	ldr	r0, [r3, #32]
 8002d04:	4a05      	ldr	r2, [pc, #20]	; (8002d1c <HAL_TIM_Base_Stop_IT+0x24>)
 8002d06:	4210      	tst	r0, r2
 8002d08:	d106      	bne.n	8002d18 <HAL_TIM_Base_Stop_IT+0x20>
 8002d0a:	6a18      	ldr	r0, [r3, #32]
 8002d0c:	4a04      	ldr	r2, [pc, #16]	; (8002d20 <HAL_TIM_Base_Stop_IT+0x28>)
 8002d0e:	4210      	tst	r0, r2
 8002d10:	d102      	bne.n	8002d18 <HAL_TIM_Base_Stop_IT+0x20>
 8002d12:	681a      	ldr	r2, [r3, #0]
 8002d14:	438a      	bics	r2, r1
 8002d16:	601a      	str	r2, [r3, #0]

  /* Return function status */
  return HAL_OK;
}
 8002d18:	2000      	movs	r0, #0
 8002d1a:	4770      	bx	lr
 8002d1c:	00001111 	.word	0x00001111
 8002d20:	00000444 	.word	0x00000444

08002d24 <HAL_TIM_PeriodElapsedCallback>:
 8002d24:	4770      	bx	lr

08002d26 <HAL_TIM_OC_DelayElapsedCallback>:
 8002d26:	4770      	bx	lr

08002d28 <HAL_TIM_IC_CaptureCallback>:
 8002d28:	4770      	bx	lr

08002d2a <HAL_TIM_PWM_PulseFinishedCallback>:
 8002d2a:	4770      	bx	lr

08002d2c <HAL_TIM_TriggerCallback>:
 8002d2c:	4770      	bx	lr

08002d2e <HAL_TIM_IRQHandler>:
  * @retval None
  */
void HAL_TIM_IRQHandler(TIM_HandleTypeDef *htim)
{
  /* Capture compare 1 event */
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC1) != RESET)
 8002d2e:	2202      	movs	r2, #2
 8002d30:	6803      	ldr	r3, [r0, #0]
{
 8002d32:	b510      	push	{r4, lr}
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC1) != RESET)
 8002d34:	6919      	ldr	r1, [r3, #16]
{
 8002d36:	0004      	movs	r4, r0
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC1) != RESET)
 8002d38:	4211      	tst	r1, r2
 8002d3a:	d00e      	beq.n	8002d5a <HAL_TIM_IRQHandler+0x2c>
  {
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC1) != RESET)
 8002d3c:	68d9      	ldr	r1, [r3, #12]
 8002d3e:	4211      	tst	r1, r2
 8002d40:	d00b      	beq.n	8002d5a <HAL_TIM_IRQHandler+0x2c>
    {
      {
        __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC1);
 8002d42:	3a05      	subs	r2, #5
 8002d44:	611a      	str	r2, [r3, #16]
        htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;

        /* Input capture event */
        if ((htim->Instance->CCMR1 & TIM_CCMR1_CC1S) != 0x00U)
 8002d46:	699b      	ldr	r3, [r3, #24]
        htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;
 8002d48:	3204      	adds	r2, #4
 8002d4a:	7702      	strb	r2, [r0, #28]
        if ((htim->Instance->CCMR1 & TIM_CCMR1_CC1S) != 0x00U)
 8002d4c:	079b      	lsls	r3, r3, #30
 8002d4e:	d100      	bne.n	8002d52 <HAL_TIM_IRQHandler+0x24>
 8002d50:	e079      	b.n	8002e46 <HAL_TIM_IRQHandler+0x118>
        {
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
          htim->IC_CaptureCallback(htim);
#else
          HAL_TIM_IC_CaptureCallback(htim);
 8002d52:	f7ff ffe9 	bl	8002d28 <HAL_TIM_IC_CaptureCallback>
#else
          HAL_TIM_OC_DelayElapsedCallback(htim);
          HAL_TIM_PWM_PulseFinishedCallback(htim);
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
        }
        htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 8002d56:	2300      	movs	r3, #0
 8002d58:	7723      	strb	r3, [r4, #28]
      }
    }
  }
  /* Capture compare 2 event */
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC2) != RESET)
 8002d5a:	2204      	movs	r2, #4
 8002d5c:	6823      	ldr	r3, [r4, #0]
 8002d5e:	6919      	ldr	r1, [r3, #16]
 8002d60:	4211      	tst	r1, r2
 8002d62:	d010      	beq.n	8002d86 <HAL_TIM_IRQHandler+0x58>
  {
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC2) != RESET)
 8002d64:	68d9      	ldr	r1, [r3, #12]
 8002d66:	4211      	tst	r1, r2
 8002d68:	d00d      	beq.n	8002d86 <HAL_TIM_IRQHandler+0x58>
    {
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC2);
 8002d6a:	3a09      	subs	r2, #9
 8002d6c:	611a      	str	r2, [r3, #16]
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;
 8002d6e:	3207      	adds	r2, #7
 8002d70:	7722      	strb	r2, [r4, #28]
      /* Input capture event */
      if ((htim->Instance->CCMR1 & TIM_CCMR1_CC2S) != 0x00U)
 8002d72:	699a      	ldr	r2, [r3, #24]
 8002d74:	23c0      	movs	r3, #192	; 0xc0
 8002d76:	009b      	lsls	r3, r3, #2
      {
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
        htim->IC_CaptureCallback(htim);
#else
        HAL_TIM_IC_CaptureCallback(htim);
 8002d78:	0020      	movs	r0, r4
      if ((htim->Instance->CCMR1 & TIM_CCMR1_CC2S) != 0x00U)
 8002d7a:	421a      	tst	r2, r3
 8002d7c:	d069      	beq.n	8002e52 <HAL_TIM_IRQHandler+0x124>
        HAL_TIM_IC_CaptureCallback(htim);
 8002d7e:	f7ff ffd3 	bl	8002d28 <HAL_TIM_IC_CaptureCallback>
#else
        HAL_TIM_OC_DelayElapsedCallback(htim);
        HAL_TIM_PWM_PulseFinishedCallback(htim);
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
      }
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 8002d82:	2300      	movs	r3, #0
 8002d84:	7723      	strb	r3, [r4, #28]
    }
  }
  /* Capture compare 3 event */
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC3) != RESET)
 8002d86:	2208      	movs	r2, #8
 8002d88:	6823      	ldr	r3, [r4, #0]
 8002d8a:	6919      	ldr	r1, [r3, #16]
 8002d8c:	4211      	tst	r1, r2
 8002d8e:	d00e      	beq.n	8002dae <HAL_TIM_IRQHandler+0x80>
  {
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC3) != RESET)
 8002d90:	68d9      	ldr	r1, [r3, #12]
 8002d92:	4211      	tst	r1, r2
 8002d94:	d00b      	beq.n	8002dae <HAL_TIM_IRQHandler+0x80>
    {
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC3);
 8002d96:	3a11      	subs	r2, #17
 8002d98:	611a      	str	r2, [r3, #16]
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;
      /* Input capture event */
      if ((htim->Instance->CCMR2 & TIM_CCMR2_CC3S) != 0x00U)
 8002d9a:	69db      	ldr	r3, [r3, #28]
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;
 8002d9c:	320d      	adds	r2, #13
 8002d9e:	7722      	strb	r2, [r4, #28]
      {
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
        htim->IC_CaptureCallback(htim);
#else
        HAL_TIM_IC_CaptureCallback(htim);
 8002da0:	0020      	movs	r0, r4
      if ((htim->Instance->CCMR2 & TIM_CCMR2_CC3S) != 0x00U)
 8002da2:	079b      	lsls	r3, r3, #30
 8002da4:	d05b      	beq.n	8002e5e <HAL_TIM_IRQHandler+0x130>
        HAL_TIM_IC_CaptureCallback(htim);
 8002da6:	f7ff ffbf 	bl	8002d28 <HAL_TIM_IC_CaptureCallback>
#else
        HAL_TIM_OC_DelayElapsedCallback(htim);
        HAL_TIM_PWM_PulseFinishedCallback(htim);
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
      }
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 8002daa:	2300      	movs	r3, #0
 8002dac:	7723      	strb	r3, [r4, #28]
    }
  }
  /* Capture compare 4 event */
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC4) != RESET)
 8002dae:	2210      	movs	r2, #16
 8002db0:	6823      	ldr	r3, [r4, #0]
 8002db2:	6919      	ldr	r1, [r3, #16]
 8002db4:	4211      	tst	r1, r2
 8002db6:	d010      	beq.n	8002dda <HAL_TIM_IRQHandler+0xac>
  {
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC4) != RESET)
 8002db8:	68d9      	ldr	r1, [r3, #12]
 8002dba:	4211      	tst	r1, r2
 8002dbc:	d00d      	beq.n	8002dda <HAL_TIM_IRQHandler+0xac>
    {
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC4);
 8002dbe:	3a21      	subs	r2, #33	; 0x21
 8002dc0:	611a      	str	r2, [r3, #16]
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_4;
 8002dc2:	3219      	adds	r2, #25
 8002dc4:	7722      	strb	r2, [r4, #28]
      /* Input capture event */
      if ((htim->Instance->CCMR2 & TIM_CCMR2_CC4S) != 0x00U)
 8002dc6:	69da      	ldr	r2, [r3, #28]
 8002dc8:	23c0      	movs	r3, #192	; 0xc0
 8002dca:	009b      	lsls	r3, r3, #2
      {
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
        htim->IC_CaptureCallback(htim);
#else
        HAL_TIM_IC_CaptureCallback(htim);
 8002dcc:	0020      	movs	r0, r4
      if ((htim->Instance->CCMR2 & TIM_CCMR2_CC4S) != 0x00U)
 8002dce:	421a      	tst	r2, r3
 8002dd0:	d04b      	beq.n	8002e6a <HAL_TIM_IRQHandler+0x13c>
        HAL_TIM_IC_CaptureCallback(htim);
 8002dd2:	f7ff ffa9 	bl	8002d28 <HAL_TIM_IC_CaptureCallback>
#else
        HAL_TIM_OC_DelayElapsedCallback(htim);
        HAL_TIM_PWM_PulseFinishedCallback(htim);
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
      }
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 8002dd6:	2300      	movs	r3, #0
 8002dd8:	7723      	strb	r3, [r4, #28]
    }
  }
  /* TIM Update event */
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_UPDATE) != RESET)
 8002dda:	2201      	movs	r2, #1
 8002ddc:	6823      	ldr	r3, [r4, #0]
 8002dde:	6919      	ldr	r1, [r3, #16]
 8002de0:	4211      	tst	r1, r2
 8002de2:	d007      	beq.n	8002df4 <HAL_TIM_IRQHandler+0xc6>
  {
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_UPDATE) != RESET)
 8002de4:	68d9      	ldr	r1, [r3, #12]
 8002de6:	4211      	tst	r1, r2
 8002de8:	d004      	beq.n	8002df4 <HAL_TIM_IRQHandler+0xc6>
    {
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_UPDATE);
 8002dea:	3a03      	subs	r2, #3
 8002dec:	611a      	str	r2, [r3, #16]
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
      htim->PeriodElapsedCallback(htim);
#else
      HAL_TIM_PeriodElapsedCallback(htim);
 8002dee:	0020      	movs	r0, r4
 8002df0:	f7ff ff98 	bl	8002d24 <HAL_TIM_PeriodElapsedCallback>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
    }
  }
  /* TIM Break input event */
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_BREAK) != RESET)
 8002df4:	2280      	movs	r2, #128	; 0x80
 8002df6:	6823      	ldr	r3, [r4, #0]
 8002df8:	6919      	ldr	r1, [r3, #16]
 8002dfa:	4211      	tst	r1, r2
 8002dfc:	d008      	beq.n	8002e10 <HAL_TIM_IRQHandler+0xe2>
  {
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_BREAK) != RESET)
 8002dfe:	68d9      	ldr	r1, [r3, #12]
 8002e00:	4211      	tst	r1, r2
 8002e02:	d005      	beq.n	8002e10 <HAL_TIM_IRQHandler+0xe2>
    {
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_BREAK);
 8002e04:	3a02      	subs	r2, #2
 8002e06:	3aff      	subs	r2, #255	; 0xff
 8002e08:	611a      	str	r2, [r3, #16]
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
      htim->BreakCallback(htim);
#else
      HAL_TIMEx_BreakCallback(htim);
 8002e0a:	0020      	movs	r0, r4
 8002e0c:	f000 f95d 	bl	80030ca <HAL_TIMEx_BreakCallback>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
    }
  }
  /* TIM Trigger detection event */
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_TRIGGER) != RESET)
 8002e10:	2240      	movs	r2, #64	; 0x40
 8002e12:	6823      	ldr	r3, [r4, #0]
 8002e14:	6919      	ldr	r1, [r3, #16]
 8002e16:	4211      	tst	r1, r2
 8002e18:	d007      	beq.n	8002e2a <HAL_TIM_IRQHandler+0xfc>
  {
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_TRIGGER) != RESET)
 8002e1a:	68d9      	ldr	r1, [r3, #12]
 8002e1c:	4211      	tst	r1, r2
 8002e1e:	d004      	beq.n	8002e2a <HAL_TIM_IRQHandler+0xfc>
    {
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_TRIGGER);
 8002e20:	3a81      	subs	r2, #129	; 0x81
 8002e22:	611a      	str	r2, [r3, #16]
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
      htim->TriggerCallback(htim);
#else
      HAL_TIM_TriggerCallback(htim);
 8002e24:	0020      	movs	r0, r4
 8002e26:	f7ff ff81 	bl	8002d2c <HAL_TIM_TriggerCallback>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
    }
  }
  /* TIM commutation event */
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_COM) != RESET)
 8002e2a:	2220      	movs	r2, #32
 8002e2c:	6823      	ldr	r3, [r4, #0]
 8002e2e:	6919      	ldr	r1, [r3, #16]
 8002e30:	4211      	tst	r1, r2
 8002e32:	d007      	beq.n	8002e44 <HAL_TIM_IRQHandler+0x116>
  {
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_COM) != RESET)
 8002e34:	68d9      	ldr	r1, [r3, #12]
 8002e36:	4211      	tst	r1, r2
 8002e38:	d004      	beq.n	8002e44 <HAL_TIM_IRQHandler+0x116>
    {
      __HAL_TIM_CLEAR_IT(htim, TIM_FLAG_COM);
 8002e3a:	3a41      	subs	r2, #65	; 0x41
 8002e3c:	611a      	str	r2, [r3, #16]
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
      htim->CommutationCallback(htim);
#else
      HAL_TIMEx_CommutCallback(htim);
 8002e3e:	0020      	movs	r0, r4
 8002e40:	f000 f942 	bl	80030c8 <HAL_TIMEx_CommutCallback>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
    }
  }
}
 8002e44:	bd10      	pop	{r4, pc}
          HAL_TIM_OC_DelayElapsedCallback(htim);
 8002e46:	f7ff ff6e 	bl	8002d26 <HAL_TIM_OC_DelayElapsedCallback>
          HAL_TIM_PWM_PulseFinishedCallback(htim);
 8002e4a:	0020      	movs	r0, r4
 8002e4c:	f7ff ff6d 	bl	8002d2a <HAL_TIM_PWM_PulseFinishedCallback>
 8002e50:	e781      	b.n	8002d56 <HAL_TIM_IRQHandler+0x28>
        HAL_TIM_OC_DelayElapsedCallback(htim);
 8002e52:	f7ff ff68 	bl	8002d26 <HAL_TIM_OC_DelayElapsedCallback>
        HAL_TIM_PWM_PulseFinishedCallback(htim);
 8002e56:	0020      	movs	r0, r4
 8002e58:	f7ff ff67 	bl	8002d2a <HAL_TIM_PWM_PulseFinishedCallback>
 8002e5c:	e791      	b.n	8002d82 <HAL_TIM_IRQHandler+0x54>
        HAL_TIM_OC_DelayElapsedCallback(htim);
 8002e5e:	f7ff ff62 	bl	8002d26 <HAL_TIM_OC_DelayElapsedCallback>
        HAL_TIM_PWM_PulseFinishedCallback(htim);
 8002e62:	0020      	movs	r0, r4
 8002e64:	f7ff ff61 	bl	8002d2a <HAL_TIM_PWM_PulseFinishedCallback>
 8002e68:	e79f      	b.n	8002daa <HAL_TIM_IRQHandler+0x7c>
        HAL_TIM_OC_DelayElapsedCallback(htim);
 8002e6a:	f7ff ff5c 	bl	8002d26 <HAL_TIM_OC_DelayElapsedCallback>
        HAL_TIM_PWM_PulseFinishedCallback(htim);
 8002e6e:	0020      	movs	r0, r4
 8002e70:	f7ff ff5b 	bl	8002d2a <HAL_TIM_PWM_PulseFinishedCallback>
 8002e74:	e7af      	b.n	8002dd6 <HAL_TIM_IRQHandler+0xa8>
	...

08002e78 <TIM_Base_SetConfig>:
{
  uint32_t tmpcr1;
  tmpcr1 = TIMx->CR1;

  /* Set TIM Time Base Unit parameters ---------------------------------------*/
  if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
 8002e78:	4a19      	ldr	r2, [pc, #100]	; (8002ee0 <TIM_Base_SetConfig+0x68>)
{
 8002e7a:	b510      	push	{r4, lr}
  tmpcr1 = TIMx->CR1;
 8002e7c:	6803      	ldr	r3, [r0, #0]
  if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
 8002e7e:	4290      	cmp	r0, r2
 8002e80:	d002      	beq.n	8002e88 <TIM_Base_SetConfig+0x10>
 8002e82:	4c18      	ldr	r4, [pc, #96]	; (8002ee4 <TIM_Base_SetConfig+0x6c>)
 8002e84:	42a0      	cmp	r0, r4
 8002e86:	d108      	bne.n	8002e9a <TIM_Base_SetConfig+0x22>
  {
    /* Select the Counter Mode */
    tmpcr1 &= ~(TIM_CR1_DIR | TIM_CR1_CMS);
 8002e88:	2470      	movs	r4, #112	; 0x70
 8002e8a:	43a3      	bics	r3, r4
    tmpcr1 |= Structure->CounterMode;
 8002e8c:	684c      	ldr	r4, [r1, #4]
 8002e8e:	4323      	orrs	r3, r4
  }

  if (IS_TIM_CLOCK_DIVISION_INSTANCE(TIMx))
 8002e90:	4290      	cmp	r0, r2
 8002e92:	d00b      	beq.n	8002eac <TIM_Base_SetConfig+0x34>
 8002e94:	4c13      	ldr	r4, [pc, #76]	; (8002ee4 <TIM_Base_SetConfig+0x6c>)
 8002e96:	42a0      	cmp	r0, r4
 8002e98:	d008      	beq.n	8002eac <TIM_Base_SetConfig+0x34>
 8002e9a:	4c13      	ldr	r4, [pc, #76]	; (8002ee8 <TIM_Base_SetConfig+0x70>)
 8002e9c:	42a0      	cmp	r0, r4
 8002e9e:	d005      	beq.n	8002eac <TIM_Base_SetConfig+0x34>
 8002ea0:	4c12      	ldr	r4, [pc, #72]	; (8002eec <TIM_Base_SetConfig+0x74>)
 8002ea2:	42a0      	cmp	r0, r4
 8002ea4:	d002      	beq.n	8002eac <TIM_Base_SetConfig+0x34>
 8002ea6:	4c12      	ldr	r4, [pc, #72]	; (8002ef0 <TIM_Base_SetConfig+0x78>)
 8002ea8:	42a0      	cmp	r0, r4
 8002eaa:	d103      	bne.n	8002eb4 <TIM_Base_SetConfig+0x3c>
  {
    /* Set the clock division */
    tmpcr1 &= ~TIM_CR1_CKD;
 8002eac:	4c11      	ldr	r4, [pc, #68]	; (8002ef4 <TIM_Base_SetConfig+0x7c>)
 8002eae:	4023      	ands	r3, r4
    tmpcr1 |= (uint32_t)Structure->ClockDivision;
 8002eb0:	68cc      	ldr	r4, [r1, #12]
 8002eb2:	4323      	orrs	r3, r4
  }

  /* Set the auto-reload preload */
  MODIFY_REG(tmpcr1, TIM_CR1_ARPE, Structure->AutoReloadPreload);
 8002eb4:	2480      	movs	r4, #128	; 0x80
 8002eb6:	43a3      	bics	r3, r4
 8002eb8:	694c      	ldr	r4, [r1, #20]
 8002eba:	4323      	orrs	r3, r4

  TIMx->CR1 = tmpcr1;
 8002ebc:	6003      	str	r3, [r0, #0]

  /* Set the Autoreload value */
  TIMx->ARR = (uint32_t)Structure->Period ;
 8002ebe:	688b      	ldr	r3, [r1, #8]
 8002ec0:	62c3      	str	r3, [r0, #44]	; 0x2c

  /* Set the Prescaler value */
  TIMx->PSC = Structure->Prescaler;
 8002ec2:	680b      	ldr	r3, [r1, #0]
 8002ec4:	6283      	str	r3, [r0, #40]	; 0x28

  if (IS_TIM_REPETITION_COUNTER_INSTANCE(TIMx))
 8002ec6:	4290      	cmp	r0, r2
 8002ec8:	d005      	beq.n	8002ed6 <TIM_Base_SetConfig+0x5e>
 8002eca:	4b08      	ldr	r3, [pc, #32]	; (8002eec <TIM_Base_SetConfig+0x74>)
 8002ecc:	4298      	cmp	r0, r3
 8002ece:	d002      	beq.n	8002ed6 <TIM_Base_SetConfig+0x5e>
 8002ed0:	4b07      	ldr	r3, [pc, #28]	; (8002ef0 <TIM_Base_SetConfig+0x78>)
 8002ed2:	4298      	cmp	r0, r3
 8002ed4:	d101      	bne.n	8002eda <TIM_Base_SetConfig+0x62>
  {
    /* Set the Repetition Counter value */
    TIMx->RCR = Structure->RepetitionCounter;
 8002ed6:	690b      	ldr	r3, [r1, #16]
 8002ed8:	6303      	str	r3, [r0, #48]	; 0x30
  }

  /* Generate an update event to reload the Prescaler
     and the repetition counter (only for advanced timer) value immediately */
  TIMx->EGR = TIM_EGR_UG;
 8002eda:	2301      	movs	r3, #1
 8002edc:	6143      	str	r3, [r0, #20]
}
 8002ede:	bd10      	pop	{r4, pc}
 8002ee0:	40012c00 	.word	0x40012c00
 8002ee4:	40000400 	.word	0x40000400
 8002ee8:	40002000 	.word	0x40002000
 8002eec:	40014400 	.word	0x40014400
 8002ef0:	40014800 	.word	0x40014800
 8002ef4:	fffffcff 	.word	0xfffffcff

08002ef8 <HAL_TIM_Base_Init>:
{
 8002ef8:	b570      	push	{r4, r5, r6, lr}
 8002efa:	0004      	movs	r4, r0
    return HAL_ERROR;
 8002efc:	2001      	movs	r0, #1
  if (htim == NULL)
 8002efe:	2c00      	cmp	r4, #0
 8002f00:	d014      	beq.n	8002f2c <HAL_TIM_Base_Init+0x34>
  if (htim->State == HAL_TIM_STATE_RESET)
 8002f02:	0025      	movs	r5, r4
 8002f04:	353d      	adds	r5, #61	; 0x3d
 8002f06:	782b      	ldrb	r3, [r5, #0]
 8002f08:	b2db      	uxtb	r3, r3
 8002f0a:	2b00      	cmp	r3, #0
 8002f0c:	d105      	bne.n	8002f1a <HAL_TIM_Base_Init+0x22>
    htim->Lock = HAL_UNLOCKED;
 8002f0e:	0022      	movs	r2, r4
 8002f10:	323c      	adds	r2, #60	; 0x3c
 8002f12:	7013      	strb	r3, [r2, #0]
    HAL_TIM_Base_MspInit(htim);
 8002f14:	0020      	movs	r0, r4
 8002f16:	f7fe fad1 	bl	80014bc <HAL_TIM_Base_MspInit>
  htim->State = HAL_TIM_STATE_BUSY;
 8002f1a:	2302      	movs	r3, #2
  TIM_Base_SetConfig(htim->Instance, &htim->Init);
 8002f1c:	6820      	ldr	r0, [r4, #0]
  htim->State = HAL_TIM_STATE_BUSY;
 8002f1e:	702b      	strb	r3, [r5, #0]
  TIM_Base_SetConfig(htim->Instance, &htim->Init);
 8002f20:	1d21      	adds	r1, r4, #4
 8002f22:	f7ff ffa9 	bl	8002e78 <TIM_Base_SetConfig>
  htim->State = HAL_TIM_STATE_READY;
 8002f26:	2301      	movs	r3, #1
  return HAL_OK;
 8002f28:	2000      	movs	r0, #0
  htim->State = HAL_TIM_STATE_READY;
 8002f2a:	702b      	strb	r3, [r5, #0]
}
 8002f2c:	bd70      	pop	{r4, r5, r6, pc}
	...

08002f30 <TIM_ETR_SetConfig>:
  *          This parameter must be a value between 0x00 and 0x0F
  * @retval None
  */
void TIM_ETR_SetConfig(TIM_TypeDef *TIMx, uint32_t TIM_ExtTRGPrescaler,
                       uint32_t TIM_ExtTRGPolarity, uint32_t ExtTRGFilter)
{
 8002f30:	b530      	push	{r4, r5, lr}
  uint32_t tmpsmcr;

  tmpsmcr = TIMx->SMCR;
 8002f32:	6884      	ldr	r4, [r0, #8]

  /* Reset the ETR Bits */
  tmpsmcr &= ~(TIM_SMCR_ETF | TIM_SMCR_ETPS | TIM_SMCR_ECE | TIM_SMCR_ETP);
 8002f34:	4d03      	ldr	r5, [pc, #12]	; (8002f44 <TIM_ETR_SetConfig+0x14>)

  /* Set the Prescaler, the Filter value and the Polarity */
  tmpsmcr |= (uint32_t)(TIM_ExtTRGPrescaler | (TIM_ExtTRGPolarity | (ExtTRGFilter << 8U)));
 8002f36:	430a      	orrs	r2, r1
 8002f38:	021b      	lsls	r3, r3, #8
  tmpsmcr &= ~(TIM_SMCR_ETF | TIM_SMCR_ETPS | TIM_SMCR_ECE | TIM_SMCR_ETP);
 8002f3a:	402c      	ands	r4, r5
  tmpsmcr |= (uint32_t)(TIM_ExtTRGPrescaler | (TIM_ExtTRGPolarity | (ExtTRGFilter << 8U)));
 8002f3c:	4313      	orrs	r3, r2
 8002f3e:	4323      	orrs	r3, r4

  /* Write to TIMx SMCR */
  TIMx->SMCR = tmpsmcr;
 8002f40:	6083      	str	r3, [r0, #8]
}
 8002f42:	bd30      	pop	{r4, r5, pc}
 8002f44:	ffff00ff 	.word	0xffff00ff

08002f48 <HAL_TIM_ConfigClockSource>:
{
 8002f48:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  __HAL_LOCK(htim);
 8002f4a:	0005      	movs	r5, r0
 8002f4c:	2302      	movs	r3, #2
 8002f4e:	353c      	adds	r5, #60	; 0x3c
 8002f50:	782a      	ldrb	r2, [r5, #0]
{
 8002f52:	0004      	movs	r4, r0
  __HAL_LOCK(htim);
 8002f54:	0018      	movs	r0, r3
 8002f56:	2a01      	cmp	r2, #1
 8002f58:	d016      	beq.n	8002f88 <HAL_TIM_ConfigClockSource+0x40>
  htim->State = HAL_TIM_STATE_BUSY;
 8002f5a:	0026      	movs	r6, r4
  __HAL_LOCK(htim);
 8002f5c:	2701      	movs	r7, #1
  tmpsmcr = htim->Instance->SMCR;
 8002f5e:	6820      	ldr	r0, [r4, #0]
  htim->State = HAL_TIM_STATE_BUSY;
 8002f60:	363d      	adds	r6, #61	; 0x3d
  __HAL_LOCK(htim);
 8002f62:	702f      	strb	r7, [r5, #0]
  htim->State = HAL_TIM_STATE_BUSY;
 8002f64:	7033      	strb	r3, [r6, #0]
  tmpsmcr = htim->Instance->SMCR;
 8002f66:	6883      	ldr	r3, [r0, #8]
  tmpsmcr &= ~(TIM_SMCR_ETF | TIM_SMCR_ETPS | TIM_SMCR_ECE | TIM_SMCR_ETP);
 8002f68:	4a40      	ldr	r2, [pc, #256]	; (800306c <HAL_TIM_ConfigClockSource+0x124>)
 8002f6a:	4013      	ands	r3, r2
  htim->Instance->SMCR = tmpsmcr;
 8002f6c:	6083      	str	r3, [r0, #8]
  switch (sClockSourceConfig->ClockSource)
 8002f6e:	680b      	ldr	r3, [r1, #0]
 8002f70:	2b40      	cmp	r3, #64	; 0x40
 8002f72:	d065      	beq.n	8003040 <HAL_TIM_ConfigClockSource+0xf8>
 8002f74:	d814      	bhi.n	8002fa0 <HAL_TIM_ConfigClockSource+0x58>
 8002f76:	2b10      	cmp	r3, #16
 8002f78:	d00b      	beq.n	8002f92 <HAL_TIM_ConfigClockSource+0x4a>
 8002f7a:	d806      	bhi.n	8002f8a <HAL_TIM_ConfigClockSource+0x42>
 8002f7c:	2b00      	cmp	r3, #0
 8002f7e:	d008      	beq.n	8002f92 <HAL_TIM_ConfigClockSource+0x4a>
  htim->State = HAL_TIM_STATE_READY;
 8002f80:	2301      	movs	r3, #1
  __HAL_UNLOCK(htim);
 8002f82:	2000      	movs	r0, #0
  htim->State = HAL_TIM_STATE_READY;
 8002f84:	7033      	strb	r3, [r6, #0]
  __HAL_UNLOCK(htim);
 8002f86:	7028      	strb	r0, [r5, #0]
}
 8002f88:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  switch (sClockSourceConfig->ClockSource)
 8002f8a:	2b20      	cmp	r3, #32
 8002f8c:	d001      	beq.n	8002f92 <HAL_TIM_ConfigClockSource+0x4a>
 8002f8e:	2b30      	cmp	r3, #48	; 0x30
 8002f90:	d1f6      	bne.n	8002f80 <HAL_TIM_ConfigClockSource+0x38>
  tmpsmcr &= ~TIM_SMCR_TS;
 8002f92:	2270      	movs	r2, #112	; 0x70
  tmpsmcr = TIMx->SMCR;
 8002f94:	6881      	ldr	r1, [r0, #8]
  tmpsmcr &= ~TIM_SMCR_TS;
 8002f96:	4391      	bics	r1, r2
  tmpsmcr |= (InputTriggerSource | TIM_SLAVEMODE_EXTERNAL1);
 8002f98:	3a69      	subs	r2, #105	; 0x69
 8002f9a:	4313      	orrs	r3, r2
 8002f9c:	430b      	orrs	r3, r1
 8002f9e:	e01a      	b.n	8002fd6 <HAL_TIM_ConfigClockSource+0x8e>
  switch (sClockSourceConfig->ClockSource)
 8002fa0:	2b60      	cmp	r3, #96	; 0x60
 8002fa2:	d035      	beq.n	8003010 <HAL_TIM_ConfigClockSource+0xc8>
 8002fa4:	d819      	bhi.n	8002fda <HAL_TIM_ConfigClockSource+0x92>
 8002fa6:	2b50      	cmp	r3, #80	; 0x50
 8002fa8:	d1ea      	bne.n	8002f80 <HAL_TIM_ConfigClockSource+0x38>
      TIM_TI1_ConfigInputStage(htim->Instance,
 8002faa:	684a      	ldr	r2, [r1, #4]
 8002fac:	68cb      	ldr	r3, [r1, #12]
  tmpccer = TIMx->CCER;
 8002fae:	6a01      	ldr	r1, [r0, #32]
  TIMx->CCER &= ~TIM_CCER_CC1E;
 8002fb0:	6a04      	ldr	r4, [r0, #32]
  tmpccmr1 |= (TIM_ICFilter << 4U);
 8002fb2:	011b      	lsls	r3, r3, #4
  TIMx->CCER &= ~TIM_CCER_CC1E;
 8002fb4:	43bc      	bics	r4, r7
  tmpccmr1 &= ~TIM_CCMR1_IC1F;
 8002fb6:	27f0      	movs	r7, #240	; 0xf0
  TIMx->CCER &= ~TIM_CCER_CC1E;
 8002fb8:	6204      	str	r4, [r0, #32]
  tmpccmr1 = TIMx->CCMR1;
 8002fba:	6984      	ldr	r4, [r0, #24]
  tmpccmr1 &= ~TIM_CCMR1_IC1F;
 8002fbc:	43bc      	bics	r4, r7
  tmpccmr1 |= (TIM_ICFilter << 4U);
 8002fbe:	4323      	orrs	r3, r4
  tmpccer &= ~(TIM_CCER_CC1P | TIM_CCER_CC1NP);
 8002fc0:	240a      	movs	r4, #10
 8002fc2:	43a1      	bics	r1, r4
  tmpccer |= TIM_ICPolarity;
 8002fc4:	430a      	orrs	r2, r1
  TIMx->CCMR1 = tmpccmr1;
 8002fc6:	6183      	str	r3, [r0, #24]
  TIMx->CCER = tmpccer;
 8002fc8:	6202      	str	r2, [r0, #32]
  tmpsmcr &= ~TIM_SMCR_TS;
 8002fca:	2270      	movs	r2, #112	; 0x70
  tmpsmcr = TIMx->SMCR;
 8002fcc:	6883      	ldr	r3, [r0, #8]
  tmpsmcr &= ~TIM_SMCR_TS;
 8002fce:	4393      	bics	r3, r2
 8002fd0:	001a      	movs	r2, r3
  tmpsmcr |= (InputTriggerSource | TIM_SLAVEMODE_EXTERNAL1);
 8002fd2:	2357      	movs	r3, #87	; 0x57
 8002fd4:	4313      	orrs	r3, r2
  TIMx->SMCR = tmpsmcr;
 8002fd6:	6083      	str	r3, [r0, #8]
 8002fd8:	e7d2      	b.n	8002f80 <HAL_TIM_ConfigClockSource+0x38>
  switch (sClockSourceConfig->ClockSource)
 8002fda:	2b70      	cmp	r3, #112	; 0x70
 8002fdc:	d00d      	beq.n	8002ffa <HAL_TIM_ConfigClockSource+0xb2>
 8002fde:	2280      	movs	r2, #128	; 0x80
 8002fe0:	0192      	lsls	r2, r2, #6
 8002fe2:	4293      	cmp	r3, r2
 8002fe4:	d1cc      	bne.n	8002f80 <HAL_TIM_ConfigClockSource+0x38>
      TIM_ETR_SetConfig(htim->Instance,
 8002fe6:	68cb      	ldr	r3, [r1, #12]
 8002fe8:	684a      	ldr	r2, [r1, #4]
 8002fea:	6889      	ldr	r1, [r1, #8]
 8002fec:	f7ff ffa0 	bl	8002f30 <TIM_ETR_SetConfig>
      htim->Instance->SMCR |= TIM_SMCR_ECE;
 8002ff0:	2380      	movs	r3, #128	; 0x80
 8002ff2:	6822      	ldr	r2, [r4, #0]
 8002ff4:	01db      	lsls	r3, r3, #7
 8002ff6:	6891      	ldr	r1, [r2, #8]
 8002ff8:	e007      	b.n	800300a <HAL_TIM_ConfigClockSource+0xc2>
      TIM_ETR_SetConfig(htim->Instance,
 8002ffa:	68cb      	ldr	r3, [r1, #12]
 8002ffc:	684a      	ldr	r2, [r1, #4]
 8002ffe:	6889      	ldr	r1, [r1, #8]
 8003000:	f7ff ff96 	bl	8002f30 <TIM_ETR_SetConfig>
      tmpsmcr |= (TIM_SLAVEMODE_EXTERNAL1 | TIM_CLOCKSOURCE_ETRMODE1);
 8003004:	2377      	movs	r3, #119	; 0x77
      tmpsmcr = htim->Instance->SMCR;
 8003006:	6822      	ldr	r2, [r4, #0]
 8003008:	6891      	ldr	r1, [r2, #8]
      htim->Instance->SMCR |= TIM_SMCR_ECE;
 800300a:	430b      	orrs	r3, r1
 800300c:	6093      	str	r3, [r2, #8]
      break;
 800300e:	e7b7      	b.n	8002f80 <HAL_TIM_ConfigClockSource+0x38>
  TIMx->CCER &= ~TIM_CCER_CC2E;
 8003010:	2410      	movs	r4, #16
      TIM_TI2_ConfigInputStage(htim->Instance,
 8003012:	684b      	ldr	r3, [r1, #4]
 8003014:	68ca      	ldr	r2, [r1, #12]
  TIMx->CCER &= ~TIM_CCER_CC2E;
 8003016:	6a01      	ldr	r1, [r0, #32]
  tmpccmr1 &= ~TIM_CCMR1_IC2F;
 8003018:	4f15      	ldr	r7, [pc, #84]	; (8003070 <HAL_TIM_ConfigClockSource+0x128>)
  TIMx->CCER &= ~TIM_CCER_CC2E;
 800301a:	43a1      	bics	r1, r4
 800301c:	6201      	str	r1, [r0, #32]
  tmpccmr1 = TIMx->CCMR1;
 800301e:	6984      	ldr	r4, [r0, #24]
  tmpccmr1 |= (TIM_ICFilter << 12U);
 8003020:	0312      	lsls	r2, r2, #12
  tmpccmr1 &= ~TIM_CCMR1_IC2F;
 8003022:	403c      	ands	r4, r7
  tmpccmr1 |= (TIM_ICFilter << 12U);
 8003024:	4322      	orrs	r2, r4
  tmpccer &= ~(TIM_CCER_CC2P | TIM_CCER_CC2NP);
 8003026:	24a0      	movs	r4, #160	; 0xa0
  tmpccer = TIMx->CCER;
 8003028:	6a01      	ldr	r1, [r0, #32]
  TIMx->CCMR1 = tmpccmr1 ;
 800302a:	6182      	str	r2, [r0, #24]
  tmpsmcr &= ~TIM_SMCR_TS;
 800302c:	2270      	movs	r2, #112	; 0x70
  tmpccer &= ~(TIM_CCER_CC2P | TIM_CCER_CC2NP);
 800302e:	43a1      	bics	r1, r4
  tmpccer |= (TIM_ICPolarity << 4U);
 8003030:	011b      	lsls	r3, r3, #4
 8003032:	430b      	orrs	r3, r1
  TIMx->CCER = tmpccer;
 8003034:	6203      	str	r3, [r0, #32]
  tmpsmcr = TIMx->SMCR;
 8003036:	6883      	ldr	r3, [r0, #8]
  tmpsmcr &= ~TIM_SMCR_TS;
 8003038:	4393      	bics	r3, r2
 800303a:	001a      	movs	r2, r3
  tmpsmcr |= (InputTriggerSource | TIM_SLAVEMODE_EXTERNAL1);
 800303c:	2367      	movs	r3, #103	; 0x67
 800303e:	e7c9      	b.n	8002fd4 <HAL_TIM_ConfigClockSource+0x8c>
      TIM_TI1_ConfigInputStage(htim->Instance,
 8003040:	684a      	ldr	r2, [r1, #4]
 8003042:	68cb      	ldr	r3, [r1, #12]
  tmpccer = TIMx->CCER;
 8003044:	6a01      	ldr	r1, [r0, #32]
  TIMx->CCER &= ~TIM_CCER_CC1E;
 8003046:	6a04      	ldr	r4, [r0, #32]
  tmpccmr1 |= (TIM_ICFilter << 4U);
 8003048:	011b      	lsls	r3, r3, #4
  TIMx->CCER &= ~TIM_CCER_CC1E;
 800304a:	43bc      	bics	r4, r7
  tmpccmr1 &= ~TIM_CCMR1_IC1F;
 800304c:	27f0      	movs	r7, #240	; 0xf0
  TIMx->CCER &= ~TIM_CCER_CC1E;
 800304e:	6204      	str	r4, [r0, #32]
  tmpccmr1 = TIMx->CCMR1;
 8003050:	6984      	ldr	r4, [r0, #24]
  tmpccmr1 &= ~TIM_CCMR1_IC1F;
 8003052:	43bc      	bics	r4, r7
  tmpccmr1 |= (TIM_ICFilter << 4U);
 8003054:	4323      	orrs	r3, r4
  tmpccer &= ~(TIM_CCER_CC1P | TIM_CCER_CC1NP);
 8003056:	240a      	movs	r4, #10
 8003058:	43a1      	bics	r1, r4
  tmpccer |= TIM_ICPolarity;
 800305a:	430a      	orrs	r2, r1
  TIMx->CCMR1 = tmpccmr1;
 800305c:	6183      	str	r3, [r0, #24]
  TIMx->CCER = tmpccer;
 800305e:	6202      	str	r2, [r0, #32]
  tmpsmcr &= ~TIM_SMCR_TS;
 8003060:	2270      	movs	r2, #112	; 0x70
  tmpsmcr = TIMx->SMCR;
 8003062:	6883      	ldr	r3, [r0, #8]
  tmpsmcr &= ~TIM_SMCR_TS;
 8003064:	4393      	bics	r3, r2
 8003066:	001a      	movs	r2, r3
  tmpsmcr |= (InputTriggerSource | TIM_SLAVEMODE_EXTERNAL1);
 8003068:	2347      	movs	r3, #71	; 0x47
 800306a:	e7b3      	b.n	8002fd4 <HAL_TIM_ConfigClockSource+0x8c>
 800306c:	ffff0088 	.word	0xffff0088
 8003070:	ffff0fff 	.word	0xffff0fff

08003074 <HAL_TIMEx_MasterConfigSynchronization>:
  *         mode.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIMEx_MasterConfigSynchronization(TIM_HandleTypeDef *htim,
                                                        TIM_MasterConfigTypeDef *sMasterConfig)
{
 8003074:	b570      	push	{r4, r5, r6, lr}
  assert_param(IS_TIM_MASTER_INSTANCE(htim->Instance));
  assert_param(IS_TIM_TRGO_SOURCE(sMasterConfig->MasterOutputTrigger));
  assert_param(IS_TIM_MSM_STATE(sMasterConfig->MasterSlaveMode));

  /* Check input state */
  __HAL_LOCK(htim);
 8003076:	0004      	movs	r4, r0
 8003078:	2202      	movs	r2, #2
 800307a:	343c      	adds	r4, #60	; 0x3c
 800307c:	7825      	ldrb	r5, [r4, #0]
{
 800307e:	0003      	movs	r3, r0
  __HAL_LOCK(htim);
 8003080:	0010      	movs	r0, r2
 8003082:	2d01      	cmp	r5, #1
 8003084:	d01b      	beq.n	80030be <HAL_TIMEx_MasterConfigSynchronization+0x4a>

  /* Change the handler state */
  htim->State = HAL_TIM_STATE_BUSY;
 8003086:	001d      	movs	r5, r3

  /* Get the TIMx SMCR register value */
  tmpsmcr = htim->Instance->SMCR;

  /* Reset the MMS Bits */
  tmpcr2 &= ~TIM_CR2_MMS;
 8003088:	2670      	movs	r6, #112	; 0x70
  tmpcr2 = htim->Instance->CR2;
 800308a:	681b      	ldr	r3, [r3, #0]
  __HAL_LOCK(htim);
 800308c:	3801      	subs	r0, #1
  htim->State = HAL_TIM_STATE_BUSY;
 800308e:	353d      	adds	r5, #61	; 0x3d
  __HAL_LOCK(htim);
 8003090:	7020      	strb	r0, [r4, #0]
  htim->State = HAL_TIM_STATE_BUSY;
 8003092:	702a      	strb	r2, [r5, #0]
  tmpcr2 = htim->Instance->CR2;
 8003094:	6858      	ldr	r0, [r3, #4]
  tmpsmcr = htim->Instance->SMCR;
 8003096:	689a      	ldr	r2, [r3, #8]
  tmpcr2 &= ~TIM_CR2_MMS;
 8003098:	43b0      	bics	r0, r6
  /* Select the TRGO source */
  tmpcr2 |=  sMasterConfig->MasterOutputTrigger;
 800309a:	680e      	ldr	r6, [r1, #0]
 800309c:	4330      	orrs	r0, r6

  /* Update TIMx CR2 */
  htim->Instance->CR2 = tmpcr2;
 800309e:	6058      	str	r0, [r3, #4]

  if (IS_TIM_SLAVE_INSTANCE(htim->Instance))
 80030a0:	4807      	ldr	r0, [pc, #28]	; (80030c0 <HAL_TIMEx_MasterConfigSynchronization+0x4c>)
 80030a2:	4283      	cmp	r3, r0
 80030a4:	d002      	beq.n	80030ac <HAL_TIMEx_MasterConfigSynchronization+0x38>
 80030a6:	4807      	ldr	r0, [pc, #28]	; (80030c4 <HAL_TIMEx_MasterConfigSynchronization+0x50>)
 80030a8:	4283      	cmp	r3, r0
 80030aa:	d104      	bne.n	80030b6 <HAL_TIMEx_MasterConfigSynchronization+0x42>
  {
    /* Reset the MSM Bit */
    tmpsmcr &= ~TIM_SMCR_MSM;
 80030ac:	2080      	movs	r0, #128	; 0x80
    /* Set master mode */
    tmpsmcr |= sMasterConfig->MasterSlaveMode;
 80030ae:	6849      	ldr	r1, [r1, #4]
    tmpsmcr &= ~TIM_SMCR_MSM;
 80030b0:	4382      	bics	r2, r0
    tmpsmcr |= sMasterConfig->MasterSlaveMode;
 80030b2:	430a      	orrs	r2, r1

    /* Update TIMx SMCR */
    htim->Instance->SMCR = tmpsmcr;
 80030b4:	609a      	str	r2, [r3, #8]
  }

  /* Change the htim state */
  htim->State = HAL_TIM_STATE_READY;
 80030b6:	2301      	movs	r3, #1

  __HAL_UNLOCK(htim);
 80030b8:	2000      	movs	r0, #0
  htim->State = HAL_TIM_STATE_READY;
 80030ba:	702b      	strb	r3, [r5, #0]
  __HAL_UNLOCK(htim);
 80030bc:	7020      	strb	r0, [r4, #0]

  return HAL_OK;
}
 80030be:	bd70      	pop	{r4, r5, r6, pc}
 80030c0:	40012c00 	.word	0x40012c00
 80030c4:	40000400 	.word	0x40000400

080030c8 <HAL_TIMEx_CommutCallback>:
 80030c8:	4770      	bx	lr

080030ca <HAL_TIMEx_BreakCallback>:
 80030ca:	4770      	bx	lr

080030cc <UART_EndRxTransfer>:
  * @retval None
  */
static void UART_EndRxTransfer(UART_HandleTypeDef *huart)
{
  /* Disable RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts */
  CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE));
 80030cc:	6803      	ldr	r3, [r0, #0]
 80030ce:	4907      	ldr	r1, [pc, #28]	; (80030ec <UART_EndRxTransfer+0x20>)
 80030d0:	681a      	ldr	r2, [r3, #0]
 80030d2:	400a      	ands	r2, r1
 80030d4:	601a      	str	r2, [r3, #0]
  CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 80030d6:	689a      	ldr	r2, [r3, #8]
 80030d8:	3123      	adds	r1, #35	; 0x23
 80030da:	31ff      	adds	r1, #255	; 0xff
 80030dc:	438a      	bics	r2, r1
 80030de:	609a      	str	r2, [r3, #8]

  /* At end of Rx process, restore huart->RxState to Ready */
  huart->RxState = HAL_UART_STATE_READY;
 80030e0:	2320      	movs	r3, #32
 80030e2:	6783      	str	r3, [r0, #120]	; 0x78

  /* Reset RxIsr function pointer */
  huart->RxISR = NULL;
 80030e4:	2300      	movs	r3, #0
 80030e6:	6603      	str	r3, [r0, #96]	; 0x60
}
 80030e8:	4770      	bx	lr
 80030ea:	46c0      	nop			; (mov r8, r8)
 80030ec:	fffffedf 	.word	0xfffffedf

080030f0 <HAL_UART_Receive_IT>:
{
 80030f0:	b570      	push	{r4, r5, r6, lr}
  if (huart->RxState == HAL_UART_STATE_READY)
 80030f2:	6f84      	ldr	r4, [r0, #120]	; 0x78
{
 80030f4:	0003      	movs	r3, r0
    return HAL_BUSY;
 80030f6:	2002      	movs	r0, #2
  if (huart->RxState == HAL_UART_STATE_READY)
 80030f8:	2c20      	cmp	r4, #32
 80030fa:	d141      	bne.n	8003180 <HAL_UART_Receive_IT+0x90>
      return HAL_ERROR;
 80030fc:	3801      	subs	r0, #1
    if ((pData == NULL) || (Size == 0U))
 80030fe:	2900      	cmp	r1, #0
 8003100:	d03e      	beq.n	8003180 <HAL_UART_Receive_IT+0x90>
 8003102:	2a00      	cmp	r2, #0
 8003104:	d03c      	beq.n	8003180 <HAL_UART_Receive_IT+0x90>
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
 8003106:	2580      	movs	r5, #128	; 0x80
 8003108:	689c      	ldr	r4, [r3, #8]
 800310a:	016d      	lsls	r5, r5, #5
 800310c:	42ac      	cmp	r4, r5
 800310e:	d104      	bne.n	800311a <HAL_UART_Receive_IT+0x2a>
 8003110:	691d      	ldr	r5, [r3, #16]
 8003112:	2d00      	cmp	r5, #0
 8003114:	d101      	bne.n	800311a <HAL_UART_Receive_IT+0x2a>
      if ((((uint32_t)pData) & 1U) != 0U)
 8003116:	4201      	tst	r1, r0
 8003118:	d132      	bne.n	8003180 <HAL_UART_Receive_IT+0x90>
    __HAL_LOCK(huart);
 800311a:	001d      	movs	r5, r3
 800311c:	3570      	adds	r5, #112	; 0x70
 800311e:	782e      	ldrb	r6, [r5, #0]
    return HAL_BUSY;
 8003120:	2002      	movs	r0, #2
    __HAL_LOCK(huart);
 8003122:	2e01      	cmp	r6, #1
 8003124:	d02c      	beq.n	8003180 <HAL_UART_Receive_IT+0x90>
 8003126:	3801      	subs	r0, #1
 8003128:	7028      	strb	r0, [r5, #0]
    huart->pRxBuffPtr  = pData;
 800312a:	6559      	str	r1, [r3, #84]	; 0x54
    huart->RxXferSize  = Size;
 800312c:	0019      	movs	r1, r3
 800312e:	3158      	adds	r1, #88	; 0x58
 8003130:	800a      	strh	r2, [r1, #0]
    huart->RxXferCount = Size;
 8003132:	804a      	strh	r2, [r1, #2]
    UART_MASK_COMPUTATION(huart);
 8003134:	2080      	movs	r0, #128	; 0x80
    huart->RxISR       = NULL;
 8003136:	2100      	movs	r1, #0
 8003138:	001a      	movs	r2, r3
 800313a:	6619      	str	r1, [r3, #96]	; 0x60
    UART_MASK_COMPUTATION(huart);
 800313c:	0140      	lsls	r0, r0, #5
 800313e:	325c      	adds	r2, #92	; 0x5c
 8003140:	4284      	cmp	r4, r0
 8003142:	d120      	bne.n	8003186 <HAL_UART_Receive_IT+0x96>
 8003144:	6919      	ldr	r1, [r3, #16]
 8003146:	2900      	cmp	r1, #0
 8003148:	d11b      	bne.n	8003182 <HAL_UART_Receive_IT+0x92>
 800314a:	4913      	ldr	r1, [pc, #76]	; (8003198 <HAL_UART_Receive_IT+0xa8>)
 800314c:	8011      	strh	r1, [r2, #0]
    huart->ErrorCode = HAL_UART_ERROR_NONE;
 800314e:	2200      	movs	r2, #0
    SET_BIT(huart->Instance->CR3, USART_CR3_EIE);
 8003150:	2101      	movs	r1, #1
    huart->ErrorCode = HAL_UART_ERROR_NONE;
 8003152:	67da      	str	r2, [r3, #124]	; 0x7c
    huart->RxState = HAL_UART_STATE_BUSY_RX;
 8003154:	3222      	adds	r2, #34	; 0x22
 8003156:	679a      	str	r2, [r3, #120]	; 0x78
    SET_BIT(huart->Instance->CR3, USART_CR3_EIE);
 8003158:	681a      	ldr	r2, [r3, #0]
 800315a:	6890      	ldr	r0, [r2, #8]
 800315c:	4301      	orrs	r1, r0
 800315e:	6091      	str	r1, [r2, #8]
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
 8003160:	2180      	movs	r1, #128	; 0x80
 8003162:	0149      	lsls	r1, r1, #5
 8003164:	428c      	cmp	r4, r1
 8003166:	d115      	bne.n	8003194 <HAL_UART_Receive_IT+0xa4>
 8003168:	6919      	ldr	r1, [r3, #16]
 800316a:	2900      	cmp	r1, #0
 800316c:	d112      	bne.n	8003194 <HAL_UART_Receive_IT+0xa4>
      huart->RxISR = UART_RxISR_16BIT;
 800316e:	490b      	ldr	r1, [pc, #44]	; (800319c <HAL_UART_Receive_IT+0xac>)
      huart->RxISR = UART_RxISR_8BIT;
 8003170:	6619      	str	r1, [r3, #96]	; 0x60
    SET_BIT(huart->Instance->CR1, USART_CR1_PEIE | USART_CR1_RXNEIE);
 8003172:	2390      	movs	r3, #144	; 0x90
    __HAL_UNLOCK(huart);
 8003174:	2000      	movs	r0, #0
    SET_BIT(huart->Instance->CR1, USART_CR1_PEIE | USART_CR1_RXNEIE);
 8003176:	6811      	ldr	r1, [r2, #0]
 8003178:	005b      	lsls	r3, r3, #1
 800317a:	430b      	orrs	r3, r1
    __HAL_UNLOCK(huart);
 800317c:	7028      	strb	r0, [r5, #0]
    SET_BIT(huart->Instance->CR1, USART_CR1_PEIE | USART_CR1_RXNEIE);
 800317e:	6013      	str	r3, [r2, #0]
}
 8003180:	bd70      	pop	{r4, r5, r6, pc}
    UART_MASK_COMPUTATION(huart);
 8003182:	21ff      	movs	r1, #255	; 0xff
 8003184:	e7e2      	b.n	800314c <HAL_UART_Receive_IT+0x5c>
 8003186:	2c00      	cmp	r4, #0
 8003188:	d1e0      	bne.n	800314c <HAL_UART_Receive_IT+0x5c>
 800318a:	6919      	ldr	r1, [r3, #16]
 800318c:	2900      	cmp	r1, #0
 800318e:	d0f8      	beq.n	8003182 <HAL_UART_Receive_IT+0x92>
 8003190:	217f      	movs	r1, #127	; 0x7f
 8003192:	e7db      	b.n	800314c <HAL_UART_Receive_IT+0x5c>
      huart->RxISR = UART_RxISR_8BIT;
 8003194:	4902      	ldr	r1, [pc, #8]	; (80031a0 <HAL_UART_Receive_IT+0xb0>)
 8003196:	e7eb      	b.n	8003170 <HAL_UART_Receive_IT+0x80>
 8003198:	000001ff 	.word	0x000001ff
 800319c:	08003209 	.word	0x08003209
 80031a0:	080031a9 	.word	0x080031a9

080031a4 <HAL_UART_TxCpltCallback>:
 80031a4:	4770      	bx	lr

080031a6 <HAL_UART_RxCpltCallback>:
 80031a6:	4770      	bx	lr

080031a8 <UART_RxISR_8BIT>:
{
  uint16_t uhMask = huart->Mask;
  uint16_t  uhdata;

  /* Check that a Rx process is ongoing */
  if (huart->RxState == HAL_UART_STATE_BUSY_RX)
 80031a8:	6f82      	ldr	r2, [r0, #120]	; 0x78
{
 80031aa:	b510      	push	{r4, lr}
 80031ac:	6803      	ldr	r3, [r0, #0]
  if (huart->RxState == HAL_UART_STATE_BUSY_RX)
 80031ae:	2a22      	cmp	r2, #34	; 0x22
 80031b0:	d123      	bne.n	80031fa <UART_RxISR_8BIT+0x52>
  uint16_t uhMask = huart->Mask;
 80031b2:	0002      	movs	r2, r0
 80031b4:	325c      	adds	r2, #92	; 0x5c
  {
    uhdata = (uint16_t) READ_REG(huart->Instance->RDR);
 80031b6:	8c9b      	ldrh	r3, [r3, #36]	; 0x24
    *huart->pRxBuffPtr = (uint8_t)(uhdata & (uint8_t)uhMask);
 80031b8:	8812      	ldrh	r2, [r2, #0]
 80031ba:	4013      	ands	r3, r2
 80031bc:	6d42      	ldr	r2, [r0, #84]	; 0x54
 80031be:	7013      	strb	r3, [r2, #0]
    huart->pRxBuffPtr++;
    huart->RxXferCount--;
 80031c0:	0002      	movs	r2, r0
    huart->pRxBuffPtr++;
 80031c2:	6d43      	ldr	r3, [r0, #84]	; 0x54
    huart->RxXferCount--;
 80031c4:	325a      	adds	r2, #90	; 0x5a
    huart->pRxBuffPtr++;
 80031c6:	3301      	adds	r3, #1
 80031c8:	6543      	str	r3, [r0, #84]	; 0x54
    huart->RxXferCount--;
 80031ca:	8813      	ldrh	r3, [r2, #0]
 80031cc:	3b01      	subs	r3, #1
 80031ce:	b29b      	uxth	r3, r3
 80031d0:	8013      	strh	r3, [r2, #0]

    if (huart->RxXferCount == 0U)
 80031d2:	8813      	ldrh	r3, [r2, #0]
 80031d4:	b29b      	uxth	r3, r3
 80031d6:	2b00      	cmp	r3, #0
 80031d8:	d10e      	bne.n	80031f8 <UART_RxISR_8BIT+0x50>
    {
      /* Disable the UART Parity Error Interrupt and RXNE interrupts */
      CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE));
 80031da:	6802      	ldr	r2, [r0, #0]
 80031dc:	4c09      	ldr	r4, [pc, #36]	; (8003204 <UART_RxISR_8BIT+0x5c>)
 80031de:	6811      	ldr	r1, [r2, #0]
 80031e0:	4021      	ands	r1, r4
 80031e2:	6011      	str	r1, [r2, #0]

      /* Disable the UART Error Interrupt: (Frame error, noise error, overrun error) */
      CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 80031e4:	6891      	ldr	r1, [r2, #8]
 80031e6:	3423      	adds	r4, #35	; 0x23
 80031e8:	34ff      	adds	r4, #255	; 0xff
 80031ea:	43a1      	bics	r1, r4
 80031ec:	6091      	str	r1, [r2, #8]

      /* Rx process is completed, restore huart->RxState to Ready */
      huart->RxState = HAL_UART_STATE_READY;
 80031ee:	2220      	movs	r2, #32

      /* Clear RxISR function pointer */
      huart->RxISR = NULL;
 80031f0:	6603      	str	r3, [r0, #96]	; 0x60
      huart->RxState = HAL_UART_STATE_READY;
 80031f2:	6782      	str	r2, [r0, #120]	; 0x78
#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
      /*Call registered Rx complete callback*/
      huart->RxCpltCallback(huart);
#else
      /*Call legacy weak Rx complete callback*/
      HAL_UART_RxCpltCallback(huart);
 80031f4:	f7ff ffd7 	bl	80031a6 <HAL_UART_RxCpltCallback>
  else
  {
    /* Clear RXNE interrupt flag */
    __HAL_UART_SEND_REQ(huart, UART_RXDATA_FLUSH_REQUEST);
  }
}
 80031f8:	bd10      	pop	{r4, pc}
    __HAL_UART_SEND_REQ(huart, UART_RXDATA_FLUSH_REQUEST);
 80031fa:	2208      	movs	r2, #8
 80031fc:	6999      	ldr	r1, [r3, #24]
 80031fe:	430a      	orrs	r2, r1
 8003200:	619a      	str	r2, [r3, #24]
}
 8003202:	e7f9      	b.n	80031f8 <UART_RxISR_8BIT+0x50>
 8003204:	fffffedf 	.word	0xfffffedf

08003208 <UART_RxISR_16BIT>:
  uint16_t *tmp;
  uint16_t uhMask = huart->Mask;
  uint16_t  uhdata;

  /* Check that a Rx process is ongoing */
  if (huart->RxState == HAL_UART_STATE_BUSY_RX)
 8003208:	6f82      	ldr	r2, [r0, #120]	; 0x78
{
 800320a:	b510      	push	{r4, lr}
 800320c:	6803      	ldr	r3, [r0, #0]
  if (huart->RxState == HAL_UART_STATE_BUSY_RX)
 800320e:	2a22      	cmp	r2, #34	; 0x22
 8003210:	d121      	bne.n	8003256 <UART_RxISR_16BIT+0x4e>
  uint16_t uhMask = huart->Mask;
 8003212:	0001      	movs	r1, r0
 8003214:	315c      	adds	r1, #92	; 0x5c
  {
    uhdata = (uint16_t) READ_REG(huart->Instance->RDR);
 8003216:	8c9c      	ldrh	r4, [r3, #36]	; 0x24
    tmp = (uint16_t *) huart->pRxBuffPtr ;
    *tmp = (uint16_t)(uhdata & uhMask);
 8003218:	8809      	ldrh	r1, [r1, #0]
    tmp = (uint16_t *) huart->pRxBuffPtr ;
 800321a:	6d42      	ldr	r2, [r0, #84]	; 0x54
    *tmp = (uint16_t)(uhdata & uhMask);
 800321c:	4021      	ands	r1, r4
 800321e:	8011      	strh	r1, [r2, #0]
    huart->pRxBuffPtr += 2U;
    huart->RxXferCount--;
 8003220:	0001      	movs	r1, r0
    huart->pRxBuffPtr += 2U;
 8003222:	3202      	adds	r2, #2
 8003224:	6542      	str	r2, [r0, #84]	; 0x54
    huart->RxXferCount--;
 8003226:	315a      	adds	r1, #90	; 0x5a
 8003228:	880a      	ldrh	r2, [r1, #0]
 800322a:	3a01      	subs	r2, #1
 800322c:	b292      	uxth	r2, r2
 800322e:	800a      	strh	r2, [r1, #0]

    if (huart->RxXferCount == 0U)
 8003230:	880a      	ldrh	r2, [r1, #0]
 8003232:	b292      	uxth	r2, r2
 8003234:	2a00      	cmp	r2, #0
 8003236:	d10d      	bne.n	8003254 <UART_RxISR_16BIT+0x4c>
    {
      /* Disable the UART Parity Error Interrupt and RXNE interrupt*/
      CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE));
 8003238:	6819      	ldr	r1, [r3, #0]
 800323a:	4c09      	ldr	r4, [pc, #36]	; (8003260 <UART_RxISR_16BIT+0x58>)
 800323c:	4021      	ands	r1, r4
 800323e:	6019      	str	r1, [r3, #0]

      /* Disable the UART Error Interrupt: (Frame error, noise error, overrun error) */
      CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 8003240:	6899      	ldr	r1, [r3, #8]
 8003242:	3423      	adds	r4, #35	; 0x23
 8003244:	34ff      	adds	r4, #255	; 0xff
 8003246:	43a1      	bics	r1, r4
 8003248:	6099      	str	r1, [r3, #8]

      /* Rx process is completed, restore huart->RxState to Ready */
      huart->RxState = HAL_UART_STATE_READY;
 800324a:	2320      	movs	r3, #32

      /* Clear RxISR function pointer */
      huart->RxISR = NULL;
 800324c:	6602      	str	r2, [r0, #96]	; 0x60
      huart->RxState = HAL_UART_STATE_READY;
 800324e:	6783      	str	r3, [r0, #120]	; 0x78
#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
      /*Call registered Rx complete callback*/
      huart->RxCpltCallback(huart);
#else
      /*Call legacy weak Rx complete callback*/
      HAL_UART_RxCpltCallback(huart);
 8003250:	f7ff ffa9 	bl	80031a6 <HAL_UART_RxCpltCallback>
  else
  {
    /* Clear RXNE interrupt flag */
    __HAL_UART_SEND_REQ(huart, UART_RXDATA_FLUSH_REQUEST);
  }
}
 8003254:	bd10      	pop	{r4, pc}
    __HAL_UART_SEND_REQ(huart, UART_RXDATA_FLUSH_REQUEST);
 8003256:	2208      	movs	r2, #8
 8003258:	6999      	ldr	r1, [r3, #24]
 800325a:	430a      	orrs	r2, r1
 800325c:	619a      	str	r2, [r3, #24]
}
 800325e:	e7f9      	b.n	8003254 <UART_RxISR_16BIT+0x4c>
 8003260:	fffffedf 	.word	0xfffffedf

08003264 <HAL_UART_ErrorCallback>:
 8003264:	4770      	bx	lr
	...

08003268 <HAL_UART_IRQHandler>:
  uint32_t isrflags   = READ_REG(huart->Instance->ISR);
 8003268:	6803      	ldr	r3, [r0, #0]
{
 800326a:	b570      	push	{r4, r5, r6, lr}
  uint32_t isrflags   = READ_REG(huart->Instance->ISR);
 800326c:	69da      	ldr	r2, [r3, #28]
{
 800326e:	0004      	movs	r4, r0
  errorflags = (isrflags & (uint32_t)(USART_ISR_PE | USART_ISR_FE | USART_ISR_ORE | USART_ISR_NE | USART_ISR_RTOF));
 8003270:	484a      	ldr	r0, [pc, #296]	; (800339c <HAL_UART_IRQHandler+0x134>)
  uint32_t cr1its     = READ_REG(huart->Instance->CR1);
 8003272:	6819      	ldr	r1, [r3, #0]
  uint32_t cr3its     = READ_REG(huart->Instance->CR3);
 8003274:	689d      	ldr	r5, [r3, #8]
  if (errorflags == 0U)
 8003276:	4202      	tst	r2, r0
 8003278:	d10b      	bne.n	8003292 <HAL_UART_IRQHandler+0x2a>
    if (((isrflags & USART_ISR_RXNE) != 0U)
 800327a:	2020      	movs	r0, #32
 800327c:	4202      	tst	r2, r0
 800327e:	d100      	bne.n	8003282 <HAL_UART_IRQHandler+0x1a>
 8003280:	e075      	b.n	800336e <HAL_UART_IRQHandler+0x106>
        && ((cr1its & USART_CR1_RXNEIE) != 0U))
 8003282:	4201      	tst	r1, r0
 8003284:	d100      	bne.n	8003288 <HAL_UART_IRQHandler+0x20>
 8003286:	e072      	b.n	800336e <HAL_UART_IRQHandler+0x106>
      if (huart->RxISR != NULL)
 8003288:	6e23      	ldr	r3, [r4, #96]	; 0x60
      huart->TxISR(huart);
 800328a:	0020      	movs	r0, r4
    if (huart->TxISR != NULL)
 800328c:	2b00      	cmp	r3, #0
 800328e:	d164      	bne.n	800335a <HAL_UART_IRQHandler+0xf2>
 8003290:	e064      	b.n	800335c <HAL_UART_IRQHandler+0xf4>
      && (((cr3its & USART_CR3_EIE) != 0U)
 8003292:	2001      	movs	r0, #1
 8003294:	4005      	ands	r5, r0
 8003296:	d103      	bne.n	80032a0 <HAL_UART_IRQHandler+0x38>
          || ((cr1its & (USART_CR1_RXNEIE | USART_CR1_PEIE)) != 0U)))
 8003298:	2690      	movs	r6, #144	; 0x90
 800329a:	0076      	lsls	r6, r6, #1
 800329c:	4231      	tst	r1, r6
 800329e:	d066      	beq.n	800336e <HAL_UART_IRQHandler+0x106>
    if (((isrflags & USART_ISR_PE) != 0U) && ((cr1its & USART_CR1_PEIE) != 0U))
 80032a0:	4202      	tst	r2, r0
 80032a2:	d005      	beq.n	80032b0 <HAL_UART_IRQHandler+0x48>
 80032a4:	05ce      	lsls	r6, r1, #23
 80032a6:	d503      	bpl.n	80032b0 <HAL_UART_IRQHandler+0x48>
      __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_PEF);
 80032a8:	6218      	str	r0, [r3, #32]
      huart->ErrorCode |= HAL_UART_ERROR_PE;
 80032aa:	6fe6      	ldr	r6, [r4, #124]	; 0x7c
 80032ac:	4330      	orrs	r0, r6
 80032ae:	67e0      	str	r0, [r4, #124]	; 0x7c
    if (((isrflags & USART_ISR_FE) != 0U) && ((cr3its & USART_CR3_EIE) != 0U))
 80032b0:	2002      	movs	r0, #2
 80032b2:	4202      	tst	r2, r0
 80032b4:	d006      	beq.n	80032c4 <HAL_UART_IRQHandler+0x5c>
 80032b6:	2d00      	cmp	r5, #0
 80032b8:	d004      	beq.n	80032c4 <HAL_UART_IRQHandler+0x5c>
      __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_FEF);
 80032ba:	6218      	str	r0, [r3, #32]
      huart->ErrorCode |= HAL_UART_ERROR_FE;
 80032bc:	6fe6      	ldr	r6, [r4, #124]	; 0x7c
 80032be:	1800      	adds	r0, r0, r0
 80032c0:	4330      	orrs	r0, r6
 80032c2:	67e0      	str	r0, [r4, #124]	; 0x7c
    if (((isrflags & USART_ISR_NE) != 0U) && ((cr3its & USART_CR3_EIE) != 0U))
 80032c4:	2004      	movs	r0, #4
 80032c6:	4202      	tst	r2, r0
 80032c8:	d006      	beq.n	80032d8 <HAL_UART_IRQHandler+0x70>
 80032ca:	2d00      	cmp	r5, #0
 80032cc:	d004      	beq.n	80032d8 <HAL_UART_IRQHandler+0x70>
      __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_NEF);
 80032ce:	6218      	str	r0, [r3, #32]
      huart->ErrorCode |= HAL_UART_ERROR_NE;
 80032d0:	6fe6      	ldr	r6, [r4, #124]	; 0x7c
 80032d2:	3802      	subs	r0, #2
 80032d4:	4330      	orrs	r0, r6
 80032d6:	67e0      	str	r0, [r4, #124]	; 0x7c
    if (((isrflags & USART_ISR_ORE) != 0U)
 80032d8:	0710      	lsls	r0, r2, #28
 80032da:	d508      	bpl.n	80032ee <HAL_UART_IRQHandler+0x86>
        && (((cr1its & USART_CR1_RXNEIE) != 0U) ||
 80032dc:	0688      	lsls	r0, r1, #26
 80032de:	d401      	bmi.n	80032e4 <HAL_UART_IRQHandler+0x7c>
 80032e0:	2d00      	cmp	r5, #0
 80032e2:	d004      	beq.n	80032ee <HAL_UART_IRQHandler+0x86>
      __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_OREF);
 80032e4:	2008      	movs	r0, #8
 80032e6:	6218      	str	r0, [r3, #32]
      huart->ErrorCode |= HAL_UART_ERROR_ORE;
 80032e8:	6fe5      	ldr	r5, [r4, #124]	; 0x7c
 80032ea:	4328      	orrs	r0, r5
 80032ec:	67e0      	str	r0, [r4, #124]	; 0x7c
    if (((isrflags & USART_ISR_RTOF) != 0U) && ((cr1its & USART_CR1_RTOIE) != 0U))
 80032ee:	2080      	movs	r0, #128	; 0x80
 80032f0:	0100      	lsls	r0, r0, #4
 80032f2:	4202      	tst	r2, r0
 80032f4:	d006      	beq.n	8003304 <HAL_UART_IRQHandler+0x9c>
 80032f6:	014d      	lsls	r5, r1, #5
 80032f8:	d504      	bpl.n	8003304 <HAL_UART_IRQHandler+0x9c>
      __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_RTOF);
 80032fa:	6218      	str	r0, [r3, #32]
      huart->ErrorCode |= HAL_UART_ERROR_RTO;
 80032fc:	2320      	movs	r3, #32
 80032fe:	6fe0      	ldr	r0, [r4, #124]	; 0x7c
 8003300:	4303      	orrs	r3, r0
 8003302:	67e3      	str	r3, [r4, #124]	; 0x7c
    if (huart->ErrorCode != HAL_UART_ERROR_NONE)
 8003304:	6fe3      	ldr	r3, [r4, #124]	; 0x7c
 8003306:	2b00      	cmp	r3, #0
 8003308:	d028      	beq.n	800335c <HAL_UART_IRQHandler+0xf4>
      if (((isrflags & USART_ISR_RXNE) != 0U)
 800330a:	2320      	movs	r3, #32
 800330c:	421a      	tst	r2, r3
 800330e:	d006      	beq.n	800331e <HAL_UART_IRQHandler+0xb6>
          && ((cr1its & USART_CR1_RXNEIE) != 0U))
 8003310:	4219      	tst	r1, r3
 8003312:	d004      	beq.n	800331e <HAL_UART_IRQHandler+0xb6>
        if (huart->RxISR != NULL)
 8003314:	6e23      	ldr	r3, [r4, #96]	; 0x60
 8003316:	2b00      	cmp	r3, #0
 8003318:	d001      	beq.n	800331e <HAL_UART_IRQHandler+0xb6>
          huart->RxISR(huart);
 800331a:	0020      	movs	r0, r4
 800331c:	4798      	blx	r3
      if ((HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR)) ||
 800331e:	6823      	ldr	r3, [r4, #0]
      errorcode = huart->ErrorCode;
 8003320:	6fe5      	ldr	r5, [r4, #124]	; 0x7c
      if ((HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR)) ||
 8003322:	689b      	ldr	r3, [r3, #8]
        UART_EndRxTransfer(huart);
 8003324:	0020      	movs	r0, r4
      if ((HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR)) ||
 8003326:	065b      	lsls	r3, r3, #25
 8003328:	d402      	bmi.n	8003330 <HAL_UART_IRQHandler+0xc8>
          ((errorcode & (HAL_UART_ERROR_RTO | HAL_UART_ERROR_ORE)) != 0U))
 800332a:	2328      	movs	r3, #40	; 0x28
 800332c:	401d      	ands	r5, r3
      if ((HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR)) ||
 800332e:	d01a      	beq.n	8003366 <HAL_UART_IRQHandler+0xfe>
        UART_EndRxTransfer(huart);
 8003330:	f7ff fecc 	bl	80030cc <UART_EndRxTransfer>
        if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
 8003334:	2140      	movs	r1, #64	; 0x40
 8003336:	6823      	ldr	r3, [r4, #0]
 8003338:	689a      	ldr	r2, [r3, #8]
 800333a:	420a      	tst	r2, r1
 800333c:	d00f      	beq.n	800335e <HAL_UART_IRQHandler+0xf6>
          CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
 800333e:	689a      	ldr	r2, [r3, #8]
          if (huart->hdmarx != NULL)
 8003340:	6ee0      	ldr	r0, [r4, #108]	; 0x6c
          CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
 8003342:	438a      	bics	r2, r1
 8003344:	609a      	str	r2, [r3, #8]
          if (huart->hdmarx != NULL)
 8003346:	2800      	cmp	r0, #0
 8003348:	d009      	beq.n	800335e <HAL_UART_IRQHandler+0xf6>
            huart->hdmarx->XferAbortCallback = UART_DMAAbortOnError;
 800334a:	4b15      	ldr	r3, [pc, #84]	; (80033a0 <HAL_UART_IRQHandler+0x138>)
 800334c:	6343      	str	r3, [r0, #52]	; 0x34
            if (HAL_DMA_Abort_IT(huart->hdmarx) != HAL_OK)
 800334e:	f7fe fd79 	bl	8001e44 <HAL_DMA_Abort_IT>
 8003352:	2800      	cmp	r0, #0
 8003354:	d002      	beq.n	800335c <HAL_UART_IRQHandler+0xf4>
              huart->hdmarx->XferAbortCallback(huart->hdmarx);
 8003356:	6ee0      	ldr	r0, [r4, #108]	; 0x6c
 8003358:	6b43      	ldr	r3, [r0, #52]	; 0x34
 800335a:	4798      	blx	r3
}
 800335c:	bd70      	pop	{r4, r5, r6, pc}
            HAL_UART_ErrorCallback(huart);
 800335e:	0020      	movs	r0, r4
 8003360:	f7ff ff80 	bl	8003264 <HAL_UART_ErrorCallback>
 8003364:	e7fa      	b.n	800335c <HAL_UART_IRQHandler+0xf4>
        HAL_UART_ErrorCallback(huart);
 8003366:	f7ff ff7d 	bl	8003264 <HAL_UART_ErrorCallback>
        huart->ErrorCode = HAL_UART_ERROR_NONE;
 800336a:	67e5      	str	r5, [r4, #124]	; 0x7c
 800336c:	e7f6      	b.n	800335c <HAL_UART_IRQHandler+0xf4>
  if (((isrflags & USART_ISR_TXE) != 0U)
 800336e:	2080      	movs	r0, #128	; 0x80
 8003370:	4202      	tst	r2, r0
 8003372:	d003      	beq.n	800337c <HAL_UART_IRQHandler+0x114>
      && ((cr1its & USART_CR1_TXEIE) != 0U))
 8003374:	4201      	tst	r1, r0
 8003376:	d001      	beq.n	800337c <HAL_UART_IRQHandler+0x114>
    if (huart->TxISR != NULL)
 8003378:	6e63      	ldr	r3, [r4, #100]	; 0x64
 800337a:	e786      	b.n	800328a <HAL_UART_IRQHandler+0x22>
  if (((isrflags & USART_ISR_TC) != 0U) && ((cr1its & USART_CR1_TCIE) != 0U))
 800337c:	2040      	movs	r0, #64	; 0x40
 800337e:	4202      	tst	r2, r0
 8003380:	d0ec      	beq.n	800335c <HAL_UART_IRQHandler+0xf4>
 8003382:	4201      	tst	r1, r0
 8003384:	d0ea      	beq.n	800335c <HAL_UART_IRQHandler+0xf4>
  CLEAR_BIT(huart->Instance->CR1, USART_CR1_TCIE);
 8003386:	681a      	ldr	r2, [r3, #0]
 8003388:	4382      	bics	r2, r0
 800338a:	601a      	str	r2, [r3, #0]
  huart->gState = HAL_UART_STATE_READY;
 800338c:	2320      	movs	r3, #32
 800338e:	6763      	str	r3, [r4, #116]	; 0x74
  huart->TxISR = NULL;
 8003390:	2300      	movs	r3, #0
  HAL_UART_TxCpltCallback(huart);
 8003392:	0020      	movs	r0, r4
  huart->TxISR = NULL;
 8003394:	6663      	str	r3, [r4, #100]	; 0x64
  HAL_UART_TxCpltCallback(huart);
 8003396:	f7ff ff05 	bl	80031a4 <HAL_UART_TxCpltCallback>
 800339a:	e7df      	b.n	800335c <HAL_UART_IRQHandler+0xf4>
 800339c:	0000080f 	.word	0x0000080f
 80033a0:	080033a5 	.word	0x080033a5

080033a4 <UART_DMAAbortOnError>:
  UART_HandleTypeDef *huart = (UART_HandleTypeDef *)(hdma->Parent);
 80033a4:	6a40      	ldr	r0, [r0, #36]	; 0x24
  huart->RxXferCount = 0U;
 80033a6:	2300      	movs	r3, #0
 80033a8:	0002      	movs	r2, r0
{
 80033aa:	b510      	push	{r4, lr}
  huart->RxXferCount = 0U;
 80033ac:	325a      	adds	r2, #90	; 0x5a
 80033ae:	8013      	strh	r3, [r2, #0]
  huart->TxXferCount = 0U;
 80033b0:	3a08      	subs	r2, #8
 80033b2:	8013      	strh	r3, [r2, #0]
  HAL_UART_ErrorCallback(huart);
 80033b4:	f7ff ff56 	bl	8003264 <HAL_UART_ErrorCallback>
}
 80033b8:	bd10      	pop	{r4, pc}
	...

080033bc <UART_SetConfig>:
{
 80033bc:	b570      	push	{r4, r5, r6, lr}
 80033be:	0004      	movs	r4, r0
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling ;
 80033c0:	6925      	ldr	r5, [r4, #16]
 80033c2:	68a3      	ldr	r3, [r4, #8]
  MODIFY_REG(huart->Instance->CR1, USART_CR1_FIELDS, tmpreg);
 80033c4:	6802      	ldr	r2, [r0, #0]
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling ;
 80033c6:	432b      	orrs	r3, r5
 80033c8:	6965      	ldr	r5, [r4, #20]
 80033ca:	69c1      	ldr	r1, [r0, #28]
 80033cc:	432b      	orrs	r3, r5
  MODIFY_REG(huart->Instance->CR1, USART_CR1_FIELDS, tmpreg);
 80033ce:	6810      	ldr	r0, [r2, #0]
 80033d0:	4d3e      	ldr	r5, [pc, #248]	; (80034cc <UART_SetConfig+0x110>)
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling ;
 80033d2:	430b      	orrs	r3, r1
  MODIFY_REG(huart->Instance->CR1, USART_CR1_FIELDS, tmpreg);
 80033d4:	4028      	ands	r0, r5
 80033d6:	4303      	orrs	r3, r0
 80033d8:	6013      	str	r3, [r2, #0]
  MODIFY_REG(huart->Instance->CR2, USART_CR2_STOP, huart->Init.StopBits);
 80033da:	6853      	ldr	r3, [r2, #4]
 80033dc:	483c      	ldr	r0, [pc, #240]	; (80034d0 <UART_SetConfig+0x114>)
  tmpreg |= huart->Init.OneBitSampling;
 80033de:	6a25      	ldr	r5, [r4, #32]
  MODIFY_REG(huart->Instance->CR2, USART_CR2_STOP, huart->Init.StopBits);
 80033e0:	4003      	ands	r3, r0
 80033e2:	68e0      	ldr	r0, [r4, #12]
 80033e4:	4303      	orrs	r3, r0
 80033e6:	6053      	str	r3, [r2, #4]
  tmpreg |= huart->Init.OneBitSampling;
 80033e8:	69a3      	ldr	r3, [r4, #24]
  MODIFY_REG(huart->Instance->CR3, USART_CR3_FIELDS, tmpreg);
 80033ea:	6890      	ldr	r0, [r2, #8]
  tmpreg |= huart->Init.OneBitSampling;
 80033ec:	432b      	orrs	r3, r5
  MODIFY_REG(huart->Instance->CR3, USART_CR3_FIELDS, tmpreg);
 80033ee:	4d39      	ldr	r5, [pc, #228]	; (80034d4 <UART_SetConfig+0x118>)
 80033f0:	4028      	ands	r0, r5
 80033f2:	4303      	orrs	r3, r0
 80033f4:	6093      	str	r3, [r2, #8]
  UART_GETCLOCKSOURCE(huart, clocksource);
 80033f6:	2203      	movs	r2, #3
 80033f8:	4b37      	ldr	r3, [pc, #220]	; (80034d8 <UART_SetConfig+0x11c>)
 80033fa:	4d38      	ldr	r5, [pc, #224]	; (80034dc <UART_SetConfig+0x120>)
 80033fc:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80033fe:	4013      	ands	r3, r2
 8003400:	4a37      	ldr	r2, [pc, #220]	; (80034e0 <UART_SetConfig+0x124>)
 8003402:	5cd0      	ldrb	r0, [r2, r3]
  if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 8003404:	2380      	movs	r3, #128	; 0x80
 8003406:	021b      	lsls	r3, r3, #8
 8003408:	4299      	cmp	r1, r3
 800340a:	d135      	bne.n	8003478 <UART_SetConfig+0xbc>
    switch (clocksource)
 800340c:	2808      	cmp	r0, #8
 800340e:	d826      	bhi.n	800345e <UART_SetConfig+0xa2>
 8003410:	f7fc fe84 	bl	800011c <__gnu_thumb1_case_uqi>
 8003414:	250b2505 	.word	0x250b2505
 8003418:	2525251d 	.word	0x2525251d
 800341c:	20          	.byte	0x20
 800341d:	00          	.byte	0x00
        pclk = HAL_RCC_GetPCLK1Freq();
 800341e:	f7ff fa15 	bl	800284c <HAL_RCC_GetPCLK1Freq>
        usartdiv = (uint16_t)(UART_DIV_SAMPLING8(pclk, huart->Init.BaudRate));
 8003422:	6863      	ldr	r3, [r4, #4]
 8003424:	0040      	lsls	r0, r0, #1
 8003426:	085b      	lsrs	r3, r3, #1
 8003428:	e002      	b.n	8003430 <UART_SetConfig+0x74>
        usartdiv = (uint16_t)(UART_DIV_SAMPLING8(HSI_VALUE, huart->Init.BaudRate));
 800342a:	6863      	ldr	r3, [r4, #4]
 800342c:	0858      	lsrs	r0, r3, #1
 800342e:	4b2d      	ldr	r3, [pc, #180]	; (80034e4 <UART_SetConfig+0x128>)
        usartdiv = (uint16_t)(UART_DIV_SAMPLING8(LSE_VALUE, huart->Init.BaudRate));
 8003430:	18c0      	adds	r0, r0, r3
 8003432:	6861      	ldr	r1, [r4, #4]
 8003434:	f7fc fe7c 	bl	8000130 <__udivsi3>
 8003438:	b283      	uxth	r3, r0
  HAL_StatusTypeDef ret               = HAL_OK;
 800343a:	2000      	movs	r0, #0
    if ((usartdiv >= UART_BRR_MIN) && (usartdiv <= UART_BRR_MAX))
 800343c:	001a      	movs	r2, r3
 800343e:	3a10      	subs	r2, #16
 8003440:	42aa      	cmp	r2, r5
 8003442:	d90f      	bls.n	8003464 <UART_SetConfig+0xa8>
      ret = HAL_ERROR;
 8003444:	2001      	movs	r0, #1
  huart->RxISR = NULL;
 8003446:	2300      	movs	r3, #0
 8003448:	6623      	str	r3, [r4, #96]	; 0x60
  huart->TxISR = NULL;
 800344a:	6663      	str	r3, [r4, #100]	; 0x64
}
 800344c:	bd70      	pop	{r4, r5, r6, pc}
        pclk = HAL_RCC_GetSysClockFreq();
 800344e:	f7ff f947 	bl	80026e0 <HAL_RCC_GetSysClockFreq>
 8003452:	e7e6      	b.n	8003422 <UART_SetConfig+0x66>
        usartdiv = (uint16_t)(UART_DIV_SAMPLING8(LSE_VALUE, huart->Init.BaudRate));
 8003454:	6863      	ldr	r3, [r4, #4]
 8003456:	0858      	lsrs	r0, r3, #1
 8003458:	2380      	movs	r3, #128	; 0x80
 800345a:	025b      	lsls	r3, r3, #9
 800345c:	e7e8      	b.n	8003430 <UART_SetConfig+0x74>
        ret = HAL_ERROR;
 800345e:	2001      	movs	r0, #1
  uint32_t usartdiv                   = 0x00000000U;
 8003460:	2300      	movs	r3, #0
 8003462:	e7eb      	b.n	800343c <UART_SetConfig+0x80>
      brrtemp = (uint16_t)(usartdiv & 0xFFF0U);
 8003464:	220f      	movs	r2, #15
 8003466:	0019      	movs	r1, r3
 8003468:	4391      	bics	r1, r2
 800346a:	000a      	movs	r2, r1
      brrtemp |= (uint16_t)((usartdiv & (uint16_t)0x000FU) >> 1U);
 800346c:	071b      	lsls	r3, r3, #28
      huart->Instance->BRR = brrtemp;
 800346e:	6821      	ldr	r1, [r4, #0]
      brrtemp |= (uint16_t)((usartdiv & (uint16_t)0x000FU) >> 1U);
 8003470:	0f5b      	lsrs	r3, r3, #29
      huart->Instance->BRR = brrtemp;
 8003472:	4313      	orrs	r3, r2
 8003474:	60cb      	str	r3, [r1, #12]
 8003476:	e7e6      	b.n	8003446 <UART_SetConfig+0x8a>
    switch (clocksource)
 8003478:	2808      	cmp	r0, #8
 800347a:	d823      	bhi.n	80034c4 <UART_SetConfig+0x108>
 800347c:	f7fc fe4e 	bl	800011c <__gnu_thumb1_case_uqi>
 8003480:	220a2205 	.word	0x220a2205
 8003484:	2222221a 	.word	0x2222221a
 8003488:	1d          	.byte	0x1d
 8003489:	00          	.byte	0x00
        pclk = HAL_RCC_GetPCLK1Freq();
 800348a:	f7ff f9df 	bl	800284c <HAL_RCC_GetPCLK1Freq>
        usartdiv = (uint16_t)(UART_DIV_SAMPLING16(pclk, huart->Init.BaudRate));
 800348e:	6863      	ldr	r3, [r4, #4]
 8003490:	085b      	lsrs	r3, r3, #1
 8003492:	e002      	b.n	800349a <UART_SetConfig+0xde>
        usartdiv = (uint16_t)(UART_DIV_SAMPLING16(HSI_VALUE, huart->Init.BaudRate));
 8003494:	6863      	ldr	r3, [r4, #4]
 8003496:	0858      	lsrs	r0, r3, #1
 8003498:	4b13      	ldr	r3, [pc, #76]	; (80034e8 <UART_SetConfig+0x12c>)
        usartdiv = (uint16_t)(UART_DIV_SAMPLING16(LSE_VALUE, huart->Init.BaudRate));
 800349a:	18c0      	adds	r0, r0, r3
 800349c:	6861      	ldr	r1, [r4, #4]
 800349e:	f7fc fe47 	bl	8000130 <__udivsi3>
 80034a2:	b283      	uxth	r3, r0
  HAL_StatusTypeDef ret               = HAL_OK;
 80034a4:	2000      	movs	r0, #0
    if ((usartdiv >= UART_BRR_MIN) && (usartdiv <= UART_BRR_MAX))
 80034a6:	001a      	movs	r2, r3
 80034a8:	3a10      	subs	r2, #16
 80034aa:	42aa      	cmp	r2, r5
 80034ac:	d8ca      	bhi.n	8003444 <UART_SetConfig+0x88>
      huart->Instance->BRR = usartdiv;
 80034ae:	6822      	ldr	r2, [r4, #0]
 80034b0:	60d3      	str	r3, [r2, #12]
 80034b2:	e7c8      	b.n	8003446 <UART_SetConfig+0x8a>
        pclk = HAL_RCC_GetSysClockFreq();
 80034b4:	f7ff f914 	bl	80026e0 <HAL_RCC_GetSysClockFreq>
 80034b8:	e7e9      	b.n	800348e <UART_SetConfig+0xd2>
        usartdiv = (uint16_t)(UART_DIV_SAMPLING16(LSE_VALUE, huart->Init.BaudRate));
 80034ba:	6863      	ldr	r3, [r4, #4]
 80034bc:	0858      	lsrs	r0, r3, #1
 80034be:	2380      	movs	r3, #128	; 0x80
 80034c0:	021b      	lsls	r3, r3, #8
 80034c2:	e7ea      	b.n	800349a <UART_SetConfig+0xde>
        ret = HAL_ERROR;
 80034c4:	2001      	movs	r0, #1
  uint32_t usartdiv                   = 0x00000000U;
 80034c6:	2300      	movs	r3, #0
 80034c8:	e7ed      	b.n	80034a6 <UART_SetConfig+0xea>
 80034ca:	46c0      	nop			; (mov r8, r8)
 80034cc:	ffff69f3 	.word	0xffff69f3
 80034d0:	ffffcfff 	.word	0xffffcfff
 80034d4:	fffff4ff 	.word	0xfffff4ff
 80034d8:	40021000 	.word	0x40021000
 80034dc:	0000ffef 	.word	0x0000ffef
 80034e0:	08003abf 	.word	0x08003abf
 80034e4:	00f42400 	.word	0x00f42400
 80034e8:	007a1200 	.word	0x007a1200

080034ec <UART_AdvFeatureConfig>:
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_TXINVERT_INIT))
 80034ec:	6a43      	ldr	r3, [r0, #36]	; 0x24
{
 80034ee:	b530      	push	{r4, r5, lr}
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_TXINVERT_INIT))
 80034f0:	07da      	lsls	r2, r3, #31
 80034f2:	d506      	bpl.n	8003502 <UART_AdvFeatureConfig+0x16>
    MODIFY_REG(huart->Instance->CR2, USART_CR2_TXINV, huart->AdvancedInit.TxPinLevelInvert);
 80034f4:	6801      	ldr	r1, [r0, #0]
 80034f6:	4c28      	ldr	r4, [pc, #160]	; (8003598 <UART_AdvFeatureConfig+0xac>)
 80034f8:	684a      	ldr	r2, [r1, #4]
 80034fa:	4022      	ands	r2, r4
 80034fc:	6a84      	ldr	r4, [r0, #40]	; 0x28
 80034fe:	4322      	orrs	r2, r4
 8003500:	604a      	str	r2, [r1, #4]
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_RXINVERT_INIT))
 8003502:	079a      	lsls	r2, r3, #30
 8003504:	d506      	bpl.n	8003514 <UART_AdvFeatureConfig+0x28>
    MODIFY_REG(huart->Instance->CR2, USART_CR2_RXINV, huart->AdvancedInit.RxPinLevelInvert);
 8003506:	6801      	ldr	r1, [r0, #0]
 8003508:	4c24      	ldr	r4, [pc, #144]	; (800359c <UART_AdvFeatureConfig+0xb0>)
 800350a:	684a      	ldr	r2, [r1, #4]
 800350c:	4022      	ands	r2, r4
 800350e:	6ac4      	ldr	r4, [r0, #44]	; 0x2c
 8003510:	4322      	orrs	r2, r4
 8003512:	604a      	str	r2, [r1, #4]
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_DATAINVERT_INIT))
 8003514:	075a      	lsls	r2, r3, #29
 8003516:	d506      	bpl.n	8003526 <UART_AdvFeatureConfig+0x3a>
    MODIFY_REG(huart->Instance->CR2, USART_CR2_DATAINV, huart->AdvancedInit.DataInvert);
 8003518:	6801      	ldr	r1, [r0, #0]
 800351a:	4c21      	ldr	r4, [pc, #132]	; (80035a0 <UART_AdvFeatureConfig+0xb4>)
 800351c:	684a      	ldr	r2, [r1, #4]
 800351e:	4022      	ands	r2, r4
 8003520:	6b04      	ldr	r4, [r0, #48]	; 0x30
 8003522:	4322      	orrs	r2, r4
 8003524:	604a      	str	r2, [r1, #4]
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_SWAP_INIT))
 8003526:	071a      	lsls	r2, r3, #28
 8003528:	d506      	bpl.n	8003538 <UART_AdvFeatureConfig+0x4c>
    MODIFY_REG(huart->Instance->CR2, USART_CR2_SWAP, huart->AdvancedInit.Swap);
 800352a:	6801      	ldr	r1, [r0, #0]
 800352c:	4c1d      	ldr	r4, [pc, #116]	; (80035a4 <UART_AdvFeatureConfig+0xb8>)
 800352e:	684a      	ldr	r2, [r1, #4]
 8003530:	4022      	ands	r2, r4
 8003532:	6b44      	ldr	r4, [r0, #52]	; 0x34
 8003534:	4322      	orrs	r2, r4
 8003536:	604a      	str	r2, [r1, #4]
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_RXOVERRUNDISABLE_INIT))
 8003538:	06da      	lsls	r2, r3, #27
 800353a:	d506      	bpl.n	800354a <UART_AdvFeatureConfig+0x5e>
    MODIFY_REG(huart->Instance->CR3, USART_CR3_OVRDIS, huart->AdvancedInit.OverrunDisable);
 800353c:	6801      	ldr	r1, [r0, #0]
 800353e:	4c1a      	ldr	r4, [pc, #104]	; (80035a8 <UART_AdvFeatureConfig+0xbc>)
 8003540:	688a      	ldr	r2, [r1, #8]
 8003542:	4022      	ands	r2, r4
 8003544:	6b84      	ldr	r4, [r0, #56]	; 0x38
 8003546:	4322      	orrs	r2, r4
 8003548:	608a      	str	r2, [r1, #8]
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_DMADISABLEONERROR_INIT))
 800354a:	069a      	lsls	r2, r3, #26
 800354c:	d506      	bpl.n	800355c <UART_AdvFeatureConfig+0x70>
    MODIFY_REG(huart->Instance->CR3, USART_CR3_DDRE, huart->AdvancedInit.DMADisableonRxError);
 800354e:	6801      	ldr	r1, [r0, #0]
 8003550:	4c16      	ldr	r4, [pc, #88]	; (80035ac <UART_AdvFeatureConfig+0xc0>)
 8003552:	688a      	ldr	r2, [r1, #8]
 8003554:	4022      	ands	r2, r4
 8003556:	6bc4      	ldr	r4, [r0, #60]	; 0x3c
 8003558:	4322      	orrs	r2, r4
 800355a:	608a      	str	r2, [r1, #8]
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_AUTOBAUDRATE_INIT))
 800355c:	065a      	lsls	r2, r3, #25
 800355e:	d510      	bpl.n	8003582 <UART_AdvFeatureConfig+0x96>
    MODIFY_REG(huart->Instance->CR2, USART_CR2_ABREN, huart->AdvancedInit.AutoBaudRateEnable);
 8003560:	6801      	ldr	r1, [r0, #0]
 8003562:	4d13      	ldr	r5, [pc, #76]	; (80035b0 <UART_AdvFeatureConfig+0xc4>)
 8003564:	684a      	ldr	r2, [r1, #4]
 8003566:	6c04      	ldr	r4, [r0, #64]	; 0x40
 8003568:	402a      	ands	r2, r5
 800356a:	4322      	orrs	r2, r4
 800356c:	604a      	str	r2, [r1, #4]
    if (huart->AdvancedInit.AutoBaudRateEnable == UART_ADVFEATURE_AUTOBAUDRATE_ENABLE)
 800356e:	2280      	movs	r2, #128	; 0x80
 8003570:	0352      	lsls	r2, r2, #13
 8003572:	4294      	cmp	r4, r2
 8003574:	d105      	bne.n	8003582 <UART_AdvFeatureConfig+0x96>
      MODIFY_REG(huart->Instance->CR2, USART_CR2_ABRMODE, huart->AdvancedInit.AutoBaudRateMode);
 8003576:	684a      	ldr	r2, [r1, #4]
 8003578:	4c0e      	ldr	r4, [pc, #56]	; (80035b4 <UART_AdvFeatureConfig+0xc8>)
 800357a:	4022      	ands	r2, r4
 800357c:	6c44      	ldr	r4, [r0, #68]	; 0x44
 800357e:	4322      	orrs	r2, r4
 8003580:	604a      	str	r2, [r1, #4]
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_MSBFIRST_INIT))
 8003582:	061b      	lsls	r3, r3, #24
 8003584:	d506      	bpl.n	8003594 <UART_AdvFeatureConfig+0xa8>
    MODIFY_REG(huart->Instance->CR2, USART_CR2_MSBFIRST, huart->AdvancedInit.MSBFirst);
 8003586:	6802      	ldr	r2, [r0, #0]
 8003588:	490b      	ldr	r1, [pc, #44]	; (80035b8 <UART_AdvFeatureConfig+0xcc>)
 800358a:	6853      	ldr	r3, [r2, #4]
 800358c:	400b      	ands	r3, r1
 800358e:	6c81      	ldr	r1, [r0, #72]	; 0x48
 8003590:	430b      	orrs	r3, r1
 8003592:	6053      	str	r3, [r2, #4]
}
 8003594:	bd30      	pop	{r4, r5, pc}
 8003596:	46c0      	nop			; (mov r8, r8)
 8003598:	fffdffff 	.word	0xfffdffff
 800359c:	fffeffff 	.word	0xfffeffff
 80035a0:	fffbffff 	.word	0xfffbffff
 80035a4:	ffff7fff 	.word	0xffff7fff
 80035a8:	ffffefff 	.word	0xffffefff
 80035ac:	ffffdfff 	.word	0xffffdfff
 80035b0:	ffefffff 	.word	0xffefffff
 80035b4:	ff9fffff 	.word	0xff9fffff
 80035b8:	fff7ffff 	.word	0xfff7ffff

080035bc <UART_WaitOnFlagUntilTimeout>:
{
 80035bc:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
        if (__HAL_UART_GET_FLAG(huart, UART_FLAG_RTOF) == SET)
 80035be:	2780      	movs	r7, #128	; 0x80
{
 80035c0:	0004      	movs	r4, r0
 80035c2:	000e      	movs	r6, r1
 80035c4:	0015      	movs	r5, r2
 80035c6:	9301      	str	r3, [sp, #4]
        if (__HAL_UART_GET_FLAG(huart, UART_FLAG_RTOF) == SET)
 80035c8:	013f      	lsls	r7, r7, #4
  while ((__HAL_UART_GET_FLAG(huart, Flag) ? SET : RESET) == Status)
 80035ca:	6822      	ldr	r2, [r4, #0]
 80035cc:	69d3      	ldr	r3, [r2, #28]
 80035ce:	4033      	ands	r3, r6
 80035d0:	1b9b      	subs	r3, r3, r6
 80035d2:	4259      	negs	r1, r3
 80035d4:	414b      	adcs	r3, r1
 80035d6:	42ab      	cmp	r3, r5
 80035d8:	d001      	beq.n	80035de <UART_WaitOnFlagUntilTimeout+0x22>
  return HAL_OK;
 80035da:	2000      	movs	r0, #0
 80035dc:	e01c      	b.n	8003618 <UART_WaitOnFlagUntilTimeout+0x5c>
    if (Timeout != HAL_MAX_DELAY)
 80035de:	9b08      	ldr	r3, [sp, #32]
 80035e0:	3301      	adds	r3, #1
 80035e2:	d0f3      	beq.n	80035cc <UART_WaitOnFlagUntilTimeout+0x10>
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
 80035e4:	f7fe fa16 	bl	8001a14 <HAL_GetTick>
 80035e8:	9b01      	ldr	r3, [sp, #4]
 80035ea:	9a08      	ldr	r2, [sp, #32]
 80035ec:	1ac0      	subs	r0, r0, r3
 80035ee:	6823      	ldr	r3, [r4, #0]
 80035f0:	4290      	cmp	r0, r2
 80035f2:	d801      	bhi.n	80035f8 <UART_WaitOnFlagUntilTimeout+0x3c>
 80035f4:	2a00      	cmp	r2, #0
 80035f6:	d110      	bne.n	800361a <UART_WaitOnFlagUntilTimeout+0x5e>
        CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE | USART_CR1_TXEIE));
 80035f8:	681a      	ldr	r2, [r3, #0]
 80035fa:	4913      	ldr	r1, [pc, #76]	; (8003648 <UART_WaitOnFlagUntilTimeout+0x8c>)
 80035fc:	400a      	ands	r2, r1
 80035fe:	601a      	str	r2, [r3, #0]
        CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 8003600:	689a      	ldr	r2, [r3, #8]
 8003602:	31a3      	adds	r1, #163	; 0xa3
 8003604:	31ff      	adds	r1, #255	; 0xff
 8003606:	438a      	bics	r2, r1
 8003608:	609a      	str	r2, [r3, #8]
        huart->gState = HAL_UART_STATE_READY;
 800360a:	2320      	movs	r3, #32
 800360c:	6763      	str	r3, [r4, #116]	; 0x74
        huart->RxState = HAL_UART_STATE_READY;
 800360e:	67a3      	str	r3, [r4, #120]	; 0x78
          __HAL_UNLOCK(huart);
 8003610:	2300      	movs	r3, #0
          return HAL_TIMEOUT;
 8003612:	2003      	movs	r0, #3
          __HAL_UNLOCK(huart);
 8003614:	3470      	adds	r4, #112	; 0x70
 8003616:	7023      	strb	r3, [r4, #0]
}
 8003618:	bdfe      	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
      if (READ_BIT(huart->Instance->CR1, USART_CR1_RE) != 0U)
 800361a:	2104      	movs	r1, #4
 800361c:	681a      	ldr	r2, [r3, #0]
 800361e:	420a      	tst	r2, r1
 8003620:	d0d3      	beq.n	80035ca <UART_WaitOnFlagUntilTimeout+0xe>
        if (__HAL_UART_GET_FLAG(huart, UART_FLAG_RTOF) == SET)
 8003622:	69da      	ldr	r2, [r3, #28]
 8003624:	423a      	tst	r2, r7
 8003626:	d0d0      	beq.n	80035ca <UART_WaitOnFlagUntilTimeout+0xe>
          __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_RTOF);
 8003628:	621f      	str	r7, [r3, #32]
          CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE | USART_CR1_TXEIE));
 800362a:	681a      	ldr	r2, [r3, #0]
 800362c:	4906      	ldr	r1, [pc, #24]	; (8003648 <UART_WaitOnFlagUntilTimeout+0x8c>)
 800362e:	400a      	ands	r2, r1
 8003630:	601a      	str	r2, [r3, #0]
          CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 8003632:	689a      	ldr	r2, [r3, #8]
 8003634:	31a3      	adds	r1, #163	; 0xa3
 8003636:	31ff      	adds	r1, #255	; 0xff
 8003638:	438a      	bics	r2, r1
 800363a:	609a      	str	r2, [r3, #8]
          huart->gState = HAL_UART_STATE_READY;
 800363c:	2320      	movs	r3, #32
 800363e:	6763      	str	r3, [r4, #116]	; 0x74
          huart->RxState = HAL_UART_STATE_READY;
 8003640:	67a3      	str	r3, [r4, #120]	; 0x78
          huart->ErrorCode = HAL_UART_ERROR_RTO;
 8003642:	67e3      	str	r3, [r4, #124]	; 0x7c
 8003644:	e7e4      	b.n	8003610 <UART_WaitOnFlagUntilTimeout+0x54>
 8003646:	46c0      	nop			; (mov r8, r8)
 8003648:	fffffe5f 	.word	0xfffffe5f

0800364c <HAL_UART_Transmit>:
{
 800364c:	b5f0      	push	{r4, r5, r6, r7, lr}
 800364e:	b087      	sub	sp, #28
 8003650:	9305      	str	r3, [sp, #20]
  if (huart->gState == HAL_UART_STATE_READY)
 8003652:	6f43      	ldr	r3, [r0, #116]	; 0x74
{
 8003654:	0004      	movs	r4, r0
 8003656:	000d      	movs	r5, r1
 8003658:	0017      	movs	r7, r2
    return HAL_BUSY;
 800365a:	2002      	movs	r0, #2
  if (huart->gState == HAL_UART_STATE_READY)
 800365c:	2b20      	cmp	r3, #32
 800365e:	d149      	bne.n	80036f4 <HAL_UART_Transmit+0xa8>
      return  HAL_ERROR;
 8003660:	3801      	subs	r0, #1
    if ((pData == NULL) || (Size == 0U))
 8003662:	2900      	cmp	r1, #0
 8003664:	d046      	beq.n	80036f4 <HAL_UART_Transmit+0xa8>
 8003666:	2a00      	cmp	r2, #0
 8003668:	d044      	beq.n	80036f4 <HAL_UART_Transmit+0xa8>
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
 800366a:	2380      	movs	r3, #128	; 0x80
 800366c:	68a2      	ldr	r2, [r4, #8]
 800366e:	015b      	lsls	r3, r3, #5
 8003670:	429a      	cmp	r2, r3
 8003672:	d104      	bne.n	800367e <HAL_UART_Transmit+0x32>
 8003674:	6923      	ldr	r3, [r4, #16]
 8003676:	2b00      	cmp	r3, #0
 8003678:	d101      	bne.n	800367e <HAL_UART_Transmit+0x32>
      if ((((uint32_t)pData) & 1U) != 0U)
 800367a:	4201      	tst	r1, r0
 800367c:	d13a      	bne.n	80036f4 <HAL_UART_Transmit+0xa8>
    __HAL_LOCK(huart);
 800367e:	0023      	movs	r3, r4
 8003680:	3370      	adds	r3, #112	; 0x70
 8003682:	781a      	ldrb	r2, [r3, #0]
    return HAL_BUSY;
 8003684:	2002      	movs	r0, #2
    __HAL_LOCK(huart);
 8003686:	2a01      	cmp	r2, #1
 8003688:	d034      	beq.n	80036f4 <HAL_UART_Transmit+0xa8>
 800368a:	2201      	movs	r2, #1
    huart->ErrorCode = HAL_UART_ERROR_NONE;
 800368c:	2600      	movs	r6, #0
    __HAL_LOCK(huart);
 800368e:	701a      	strb	r2, [r3, #0]
    huart->gState = HAL_UART_STATE_BUSY_TX;
 8003690:	2321      	movs	r3, #33	; 0x21
    huart->ErrorCode = HAL_UART_ERROR_NONE;
 8003692:	67e6      	str	r6, [r4, #124]	; 0x7c
    huart->gState = HAL_UART_STATE_BUSY_TX;
 8003694:	6763      	str	r3, [r4, #116]	; 0x74
    tickstart = HAL_GetTick();
 8003696:	f7fe f9bd 	bl	8001a14 <HAL_GetTick>
    huart->TxXferSize  = Size;
 800369a:	0023      	movs	r3, r4
 800369c:	3350      	adds	r3, #80	; 0x50
 800369e:	801f      	strh	r7, [r3, #0]
    huart->TxXferCount = Size;
 80036a0:	3302      	adds	r3, #2
 80036a2:	9303      	str	r3, [sp, #12]
 80036a4:	801f      	strh	r7, [r3, #0]
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
 80036a6:	2380      	movs	r3, #128	; 0x80
 80036a8:	68a2      	ldr	r2, [r4, #8]
    tickstart = HAL_GetTick();
 80036aa:	9004      	str	r0, [sp, #16]
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
 80036ac:	015b      	lsls	r3, r3, #5
 80036ae:	429a      	cmp	r2, r3
 80036b0:	d104      	bne.n	80036bc <HAL_UART_Transmit+0x70>
 80036b2:	6923      	ldr	r3, [r4, #16]
 80036b4:	42b3      	cmp	r3, r6
 80036b6:	d101      	bne.n	80036bc <HAL_UART_Transmit+0x70>
 80036b8:	002e      	movs	r6, r5
      pdata8bits  = NULL;
 80036ba:	001d      	movs	r5, r3
    while (huart->TxXferCount > 0U)
 80036bc:	0023      	movs	r3, r4
 80036be:	3352      	adds	r3, #82	; 0x52
 80036c0:	881a      	ldrh	r2, [r3, #0]
      if (UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TXE, RESET, tickstart, Timeout) != HAL_OK)
 80036c2:	9b05      	ldr	r3, [sp, #20]
    while (huart->TxXferCount > 0U)
 80036c4:	b292      	uxth	r2, r2
      if (UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TXE, RESET, tickstart, Timeout) != HAL_OK)
 80036c6:	9300      	str	r3, [sp, #0]
 80036c8:	9b04      	ldr	r3, [sp, #16]
    while (huart->TxXferCount > 0U)
 80036ca:	2a00      	cmp	r2, #0
 80036cc:	d10a      	bne.n	80036e4 <HAL_UART_Transmit+0x98>
    if (UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TC, RESET, tickstart, Timeout) != HAL_OK)
 80036ce:	2140      	movs	r1, #64	; 0x40
 80036d0:	0020      	movs	r0, r4
 80036d2:	f7ff ff73 	bl	80035bc <UART_WaitOnFlagUntilTimeout>
 80036d6:	2800      	cmp	r0, #0
 80036d8:	d10b      	bne.n	80036f2 <HAL_UART_Transmit+0xa6>
    huart->gState = HAL_UART_STATE_READY;
 80036da:	2320      	movs	r3, #32
    __HAL_UNLOCK(huart);
 80036dc:	3470      	adds	r4, #112	; 0x70
    huart->gState = HAL_UART_STATE_READY;
 80036de:	6063      	str	r3, [r4, #4]
    __HAL_UNLOCK(huart);
 80036e0:	7020      	strb	r0, [r4, #0]
    return HAL_OK;
 80036e2:	e007      	b.n	80036f4 <HAL_UART_Transmit+0xa8>
      if (UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TXE, RESET, tickstart, Timeout) != HAL_OK)
 80036e4:	2200      	movs	r2, #0
 80036e6:	2180      	movs	r1, #128	; 0x80
 80036e8:	0020      	movs	r0, r4
 80036ea:	f7ff ff67 	bl	80035bc <UART_WaitOnFlagUntilTimeout>
 80036ee:	2800      	cmp	r0, #0
 80036f0:	d002      	beq.n	80036f8 <HAL_UART_Transmit+0xac>
        return HAL_TIMEOUT;
 80036f2:	2003      	movs	r0, #3
}
 80036f4:	b007      	add	sp, #28
 80036f6:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80036f8:	6822      	ldr	r2, [r4, #0]
      if (pdata8bits == NULL)
 80036fa:	2d00      	cmp	r5, #0
 80036fc:	d10b      	bne.n	8003716 <HAL_UART_Transmit+0xca>
        huart->Instance->TDR = (uint16_t)(*pdata16bits & 0x01FFU);
 80036fe:	8833      	ldrh	r3, [r6, #0]
        pdata16bits++;
 8003700:	3602      	adds	r6, #2
        huart->Instance->TDR = (uint16_t)(*pdata16bits & 0x01FFU);
 8003702:	05db      	lsls	r3, r3, #23
 8003704:	0ddb      	lsrs	r3, r3, #23
 8003706:	8513      	strh	r3, [r2, #40]	; 0x28
      huart->TxXferCount--;
 8003708:	9b03      	ldr	r3, [sp, #12]
 800370a:	9a03      	ldr	r2, [sp, #12]
 800370c:	881b      	ldrh	r3, [r3, #0]
 800370e:	3b01      	subs	r3, #1
 8003710:	b29b      	uxth	r3, r3
 8003712:	8013      	strh	r3, [r2, #0]
 8003714:	e7d2      	b.n	80036bc <HAL_UART_Transmit+0x70>
        huart->Instance->TDR = (uint8_t)(*pdata8bits & 0xFFU);
 8003716:	782b      	ldrb	r3, [r5, #0]
        pdata8bits++;
 8003718:	3501      	adds	r5, #1
        huart->Instance->TDR = (uint8_t)(*pdata8bits & 0xFFU);
 800371a:	8513      	strh	r3, [r2, #40]	; 0x28
 800371c:	e7f4      	b.n	8003708 <HAL_UART_Transmit+0xbc>
	...

08003720 <UART_CheckIdleState>:
{
 8003720:	b573      	push	{r0, r1, r4, r5, r6, lr}
  huart->ErrorCode = HAL_UART_ERROR_NONE;
 8003722:	2600      	movs	r6, #0
{
 8003724:	0004      	movs	r4, r0
  huart->ErrorCode = HAL_UART_ERROR_NONE;
 8003726:	67c6      	str	r6, [r0, #124]	; 0x7c
  tickstart = HAL_GetTick();
 8003728:	f7fe f974 	bl	8001a14 <HAL_GetTick>
  if ((huart->Instance->CR1 & USART_CR1_TE) == USART_CR1_TE)
 800372c:	6823      	ldr	r3, [r4, #0]
  tickstart = HAL_GetTick();
 800372e:	0005      	movs	r5, r0
  if ((huart->Instance->CR1 & USART_CR1_TE) == USART_CR1_TE)
 8003730:	681b      	ldr	r3, [r3, #0]
 8003732:	071b      	lsls	r3, r3, #28
 8003734:	d415      	bmi.n	8003762 <UART_CheckIdleState+0x42>
  if ((huart->Instance->CR1 & USART_CR1_RE) == USART_CR1_RE)
 8003736:	6823      	ldr	r3, [r4, #0]
 8003738:	681b      	ldr	r3, [r3, #0]
 800373a:	075b      	lsls	r3, r3, #29
 800373c:	d50a      	bpl.n	8003754 <UART_CheckIdleState+0x34>
    if (UART_WaitOnFlagUntilTimeout(huart, USART_ISR_REACK, RESET, tickstart, HAL_UART_TIMEOUT_VALUE) != HAL_OK)
 800373e:	2180      	movs	r1, #128	; 0x80
 8003740:	4b0e      	ldr	r3, [pc, #56]	; (800377c <UART_CheckIdleState+0x5c>)
 8003742:	2200      	movs	r2, #0
 8003744:	9300      	str	r3, [sp, #0]
 8003746:	03c9      	lsls	r1, r1, #15
 8003748:	002b      	movs	r3, r5
 800374a:	0020      	movs	r0, r4
 800374c:	f7ff ff36 	bl	80035bc <UART_WaitOnFlagUntilTimeout>
 8003750:	2800      	cmp	r0, #0
 8003752:	d111      	bne.n	8003778 <UART_CheckIdleState+0x58>
  huart->gState = HAL_UART_STATE_READY;
 8003754:	2320      	movs	r3, #32
  __HAL_UNLOCK(huart);
 8003756:	2000      	movs	r0, #0
  huart->gState = HAL_UART_STATE_READY;
 8003758:	6763      	str	r3, [r4, #116]	; 0x74
  huart->RxState = HAL_UART_STATE_READY;
 800375a:	67a3      	str	r3, [r4, #120]	; 0x78
  __HAL_UNLOCK(huart);
 800375c:	3470      	adds	r4, #112	; 0x70
 800375e:	7020      	strb	r0, [r4, #0]
  return HAL_OK;
 8003760:	e00b      	b.n	800377a <UART_CheckIdleState+0x5a>
    if (UART_WaitOnFlagUntilTimeout(huart, USART_ISR_TEACK, RESET, tickstart, HAL_UART_TIMEOUT_VALUE) != HAL_OK)
 8003762:	2180      	movs	r1, #128	; 0x80
 8003764:	4b05      	ldr	r3, [pc, #20]	; (800377c <UART_CheckIdleState+0x5c>)
 8003766:	0032      	movs	r2, r6
 8003768:	9300      	str	r3, [sp, #0]
 800376a:	0389      	lsls	r1, r1, #14
 800376c:	0003      	movs	r3, r0
 800376e:	0020      	movs	r0, r4
 8003770:	f7ff ff24 	bl	80035bc <UART_WaitOnFlagUntilTimeout>
 8003774:	2800      	cmp	r0, #0
 8003776:	d0de      	beq.n	8003736 <UART_CheckIdleState+0x16>
      return HAL_TIMEOUT;
 8003778:	2003      	movs	r0, #3
}
 800377a:	bd76      	pop	{r1, r2, r4, r5, r6, pc}
 800377c:	01ffffff 	.word	0x01ffffff

08003780 <HAL_UART_Init>:
{
 8003780:	b510      	push	{r4, lr}
 8003782:	1e04      	subs	r4, r0, #0
  if (huart == NULL)
 8003784:	d101      	bne.n	800378a <HAL_UART_Init+0xa>
    return HAL_ERROR;
 8003786:	2001      	movs	r0, #1
}
 8003788:	bd10      	pop	{r4, pc}
  if (huart->gState == HAL_UART_STATE_RESET)
 800378a:	6f43      	ldr	r3, [r0, #116]	; 0x74
 800378c:	2b00      	cmp	r3, #0
 800378e:	d104      	bne.n	800379a <HAL_UART_Init+0x1a>
    huart->Lock = HAL_UNLOCKED;
 8003790:	0002      	movs	r2, r0
 8003792:	3270      	adds	r2, #112	; 0x70
 8003794:	7013      	strb	r3, [r2, #0]
    HAL_UART_MspInit(huart);
 8003796:	f7fd fed5 	bl	8001544 <HAL_UART_MspInit>
  huart->gState = HAL_UART_STATE_BUSY;
 800379a:	2324      	movs	r3, #36	; 0x24
  __HAL_UART_DISABLE(huart);
 800379c:	2101      	movs	r1, #1
 800379e:	6822      	ldr	r2, [r4, #0]
  huart->gState = HAL_UART_STATE_BUSY;
 80037a0:	6763      	str	r3, [r4, #116]	; 0x74
  __HAL_UART_DISABLE(huart);
 80037a2:	6813      	ldr	r3, [r2, #0]
  if (UART_SetConfig(huart) == HAL_ERROR)
 80037a4:	0020      	movs	r0, r4
  __HAL_UART_DISABLE(huart);
 80037a6:	438b      	bics	r3, r1
 80037a8:	6013      	str	r3, [r2, #0]
  if (UART_SetConfig(huart) == HAL_ERROR)
 80037aa:	f7ff fe07 	bl	80033bc <UART_SetConfig>
 80037ae:	2801      	cmp	r0, #1
 80037b0:	d0e9      	beq.n	8003786 <HAL_UART_Init+0x6>
  if (huart->AdvancedInit.AdvFeatureInit != UART_ADVFEATURE_NO_INIT)
 80037b2:	6a63      	ldr	r3, [r4, #36]	; 0x24
 80037b4:	2b00      	cmp	r3, #0
 80037b6:	d002      	beq.n	80037be <HAL_UART_Init+0x3e>
    UART_AdvFeatureConfig(huart);
 80037b8:	0020      	movs	r0, r4
 80037ba:	f7ff fe97 	bl	80034ec <UART_AdvFeatureConfig>
  CLEAR_BIT(huart->Instance->CR2, USART_CR2_CLKEN);
 80037be:	6823      	ldr	r3, [r4, #0]
 80037c0:	4907      	ldr	r1, [pc, #28]	; (80037e0 <HAL_UART_Init+0x60>)
 80037c2:	685a      	ldr	r2, [r3, #4]
  return (UART_CheckIdleState(huart));
 80037c4:	0020      	movs	r0, r4
  CLEAR_BIT(huart->Instance->CR2, USART_CR2_CLKEN);
 80037c6:	400a      	ands	r2, r1
  CLEAR_BIT(huart->Instance->CR3, USART_CR3_HDSEL);
 80037c8:	2108      	movs	r1, #8
  CLEAR_BIT(huart->Instance->CR2, USART_CR2_CLKEN);
 80037ca:	605a      	str	r2, [r3, #4]
  CLEAR_BIT(huart->Instance->CR3, USART_CR3_HDSEL);
 80037cc:	689a      	ldr	r2, [r3, #8]
 80037ce:	438a      	bics	r2, r1
 80037d0:	609a      	str	r2, [r3, #8]
  __HAL_UART_ENABLE(huart);
 80037d2:	2201      	movs	r2, #1
 80037d4:	6819      	ldr	r1, [r3, #0]
 80037d6:	430a      	orrs	r2, r1
 80037d8:	601a      	str	r2, [r3, #0]
  return (UART_CheckIdleState(huart));
 80037da:	f7ff ffa1 	bl	8003720 <UART_CheckIdleState>
 80037de:	e7d3      	b.n	8003788 <HAL_UART_Init+0x8>
 80037e0:	fffff7ff 	.word	0xfffff7ff

080037e4 <__libc_init_array>:
 80037e4:	b570      	push	{r4, r5, r6, lr}
 80037e6:	2600      	movs	r6, #0
 80037e8:	4d0c      	ldr	r5, [pc, #48]	; (800381c <__libc_init_array+0x38>)
 80037ea:	4c0d      	ldr	r4, [pc, #52]	; (8003820 <__libc_init_array+0x3c>)
 80037ec:	1b64      	subs	r4, r4, r5
 80037ee:	10a4      	asrs	r4, r4, #2
 80037f0:	42a6      	cmp	r6, r4
 80037f2:	d109      	bne.n	8003808 <__libc_init_array+0x24>
 80037f4:	2600      	movs	r6, #0
 80037f6:	f000 f843 	bl	8003880 <_init>
 80037fa:	4d0a      	ldr	r5, [pc, #40]	; (8003824 <__libc_init_array+0x40>)
 80037fc:	4c0a      	ldr	r4, [pc, #40]	; (8003828 <__libc_init_array+0x44>)
 80037fe:	1b64      	subs	r4, r4, r5
 8003800:	10a4      	asrs	r4, r4, #2
 8003802:	42a6      	cmp	r6, r4
 8003804:	d105      	bne.n	8003812 <__libc_init_array+0x2e>
 8003806:	bd70      	pop	{r4, r5, r6, pc}
 8003808:	00b3      	lsls	r3, r6, #2
 800380a:	58eb      	ldr	r3, [r5, r3]
 800380c:	4798      	blx	r3
 800380e:	3601      	adds	r6, #1
 8003810:	e7ee      	b.n	80037f0 <__libc_init_array+0xc>
 8003812:	00b3      	lsls	r3, r6, #2
 8003814:	58eb      	ldr	r3, [r5, r3]
 8003816:	4798      	blx	r3
 8003818:	3601      	adds	r6, #1
 800381a:	e7f2      	b.n	8003802 <__libc_init_array+0x1e>
 800381c:	08003ac4 	.word	0x08003ac4
 8003820:	08003ac4 	.word	0x08003ac4
 8003824:	08003ac4 	.word	0x08003ac4
 8003828:	08003ac8 	.word	0x08003ac8

0800382c <memcpy>:
 800382c:	2300      	movs	r3, #0
 800382e:	b510      	push	{r4, lr}
 8003830:	429a      	cmp	r2, r3
 8003832:	d100      	bne.n	8003836 <memcpy+0xa>
 8003834:	bd10      	pop	{r4, pc}
 8003836:	5ccc      	ldrb	r4, [r1, r3]
 8003838:	54c4      	strb	r4, [r0, r3]
 800383a:	3301      	adds	r3, #1
 800383c:	e7f8      	b.n	8003830 <memcpy+0x4>

0800383e <memset>:
 800383e:	0003      	movs	r3, r0
 8003840:	1812      	adds	r2, r2, r0
 8003842:	4293      	cmp	r3, r2
 8003844:	d100      	bne.n	8003848 <memset+0xa>
 8003846:	4770      	bx	lr
 8003848:	7019      	strb	r1, [r3, #0]
 800384a:	3301      	adds	r3, #1
 800384c:	e7f9      	b.n	8003842 <memset+0x4>

0800384e <strcpy>:
 800384e:	0003      	movs	r3, r0
 8003850:	780a      	ldrb	r2, [r1, #0]
 8003852:	3101      	adds	r1, #1
 8003854:	701a      	strb	r2, [r3, #0]
 8003856:	3301      	adds	r3, #1
 8003858:	2a00      	cmp	r2, #0
 800385a:	d1f9      	bne.n	8003850 <strcpy+0x2>
 800385c:	4770      	bx	lr

0800385e <strncmp>:
 800385e:	2300      	movs	r3, #0
 8003860:	b530      	push	{r4, r5, lr}
 8003862:	429a      	cmp	r2, r3
 8003864:	d00a      	beq.n	800387c <strncmp+0x1e>
 8003866:	3a01      	subs	r2, #1
 8003868:	5cc4      	ldrb	r4, [r0, r3]
 800386a:	5ccd      	ldrb	r5, [r1, r3]
 800386c:	42ac      	cmp	r4, r5
 800386e:	d104      	bne.n	800387a <strncmp+0x1c>
 8003870:	4293      	cmp	r3, r2
 8003872:	d002      	beq.n	800387a <strncmp+0x1c>
 8003874:	3301      	adds	r3, #1
 8003876:	2c00      	cmp	r4, #0
 8003878:	d1f6      	bne.n	8003868 <strncmp+0xa>
 800387a:	1b63      	subs	r3, r4, r5
 800387c:	0018      	movs	r0, r3
 800387e:	bd30      	pop	{r4, r5, pc}

08003880 <_init>:
 8003880:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8003882:	46c0      	nop			; (mov r8, r8)
 8003884:	bcf8      	pop	{r3, r4, r5, r6, r7}
 8003886:	bc08      	pop	{r3}
 8003888:	469e      	mov	lr, r3
 800388a:	4770      	bx	lr

0800388c <_fini>:
 800388c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800388e:	46c0      	nop			; (mov r8, r8)
 8003890:	bcf8      	pop	{r3, r4, r5, r6, r7}
 8003892:	bc08      	pop	{r3}
 8003894:	469e      	mov	lr, r3
 8003896:	4770      	bx	lr
